[{"title":"AES知道某一轮次密钥反推主密钥","url":"/posts/17732/","content":"从轮密钥逆推主密钥首先讨论AES-128这里用上上篇对称加密算法AES原理及分析里面用到的密钥0123456789abcdef0123456789abcdef生成的10轮子密钥做分析\nK00:0123456789abcdef0123456789abcdefK01:629e9ac0eb35572fea16124863bddfa7K02:1a00c63bf13591141b23835c789e5cfbK03:154ac987e47f5893ff5cdbcf87c28734K04:385dd190dc228903237e52cca4bcd5f8K05:4d5e90d9917c19dab2024b1616be9eeeK06:c355b89e5229a144e02bea52f69574bcK07:a9c7dddcfbee7c981bc596caed50e276K08:7a5fe58981b199119a740fdb7724edadK09:570a707cd6bbe96d4ccfe6b63beb0b1bK10:8821df9e5e9a36f31255d04529bedb5e\n\n假如获取到的是K0，那不用说。如果获取到的是K10呢？8821df9e5e9a36f31255d04529bedb5e，首先我们会到W数组的视图，看W10密钥怎么编排出来的\nK10是W40,W41,W42,W43拼起来的，我们已知K10，即已知W40,W41,W42,W43有没有办法求K9？如果可以，那么同理可以逆推到K0，即求得了主密钥\n我们不妨先复习一下异或的基本性质，异或作用与比特位上，对应的比特位相同则为0，相异则为1。\n因为相同为0，相异为1，那么一个数和自身异或时，因为每个比特位都相同，所以结果为0。而当某个数和0异或时，自身为0的比特0^0得0，自身为1的比特位1^0得1，这就导致结果和没异或前一样。 \n除此之外，异或并不看谁先谁后，A ^ B 与 B ^ A 显然无区别，即具有交换律。\n\n看看异或的多角度理解：如何理解「异或」的含义。下面做变换，左右W42异或\nK10中涉及到的四个式子均可以做变化 \nK10 = 8821df9e5e9a36f31255d04529bedb5e，切成四块\nW40 = 8821df9e\nW41 = 5e9a36f3\nW42 = 1255d045\nW43 = 29bedb5e\n\n&gt;&gt;&gt; hex(0x8821df9e^0x5e9a36f3)'0xd6bbe96d'&gt;&gt;&gt; hex(0x5e9a36f3^0x1255d045)'0x4ccfe6b6'&gt;&gt;&gt; hex(0x1255d045^0x29bedb5e)'0x3beb0b1b'\n\n所以W37 = 0xd6bbe96dW38 = 0x4ccfe6b6W39 = 0x3beb0b1b求出了W37,W38,W39，即K9的后大半部分，和真实情况比对后发现一致。K09:570a707cd6bbe96d4ccfe6b63beb0b1b那么W36呢？再复习一下g函数吧首先循环左移一字节，3beb0b1b 变成 eb0b1b3b然后逐字节S盒替换，得e92bafe2\n&gt;&gt;&gt; SBox = [...     0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,...     0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,...     0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,...     0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,...     0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,...     0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,...     0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,...     0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,...     0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,...     0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,...     0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,...     0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,...     0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,...     0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,...     0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,...     0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16... ]&gt;&gt;&gt; hex(SBox[0xeb])'0xe9'&gt;&gt;&gt; hex(SBox[0x0b])'0x2b'&gt;&gt;&gt; hex(SBox[0x1b])'0xaf'&gt;&gt;&gt; hex(SBox[0x3b])'0xe2'\n最后是首字节和Rcon中的一个字节异或，这是最后一次变换，即用0x36\nrcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]\n即\n&gt;&gt;&gt; hex(0xe9^0x36)'0xdf'\ng函数的结果即是0xdf2bafe2那上面W36=g(W39) xor W40 = 0xdf2bafe2 xor 0x8821df9e\n&gt;&gt;&gt; hex(0xdf2bafe2^0x8821df9e)'0x570a707c'\n所以完整的K9：570a707cd6bbe96d4ccfe6b63beb0b1b，就被我们分析出来了，跟一开始的K表里的K9是一致的。可以继续往上推出K0，获得主密钥。即AES可以依靠轮密钥逆推出主密钥。严肃的说，AES-128可以通过一轮轮密钥逆推出主密钥，AES-192需要一轮半，AES-256需要两轮轮密钥。\n接下来顺便下讨论DES的DES密钥长八字节，在密钥编排时，会舍弃每个字节的最后1比特。因此实际参与密钥编排的是56比特，我们可以验证这一点。假设密钥是\n11 22 33 44 55 66 77 88 (hex)\n二进制即 00010001 00100010 00110011 01000100 01010101 01100110 01110111 10001000我们将末尾1比特翻转，即0变1，1变0。如果AES密钥中每个字节的最后一位被“丢弃”，那么翻转后也并不会对程序有任何影响，反之加密结果应该不同。00010000 00100011 00110010 01000101 01010100 01100111 01110110 10001001转成十六进制即\n10 23 32 45 54 67 76 89 (hex)\n在Cyberchef中，使用这两个密钥进行DES加密，结果完全一致。\n\n对于DES而言，已知两轮或两轮以上的子密钥，就可逆推出初始密钥，具体代码见 DES 子密钥逆推初始密钥 一文。对于主密钥中无法复原的八比特，随便补什么都行，反正不影响结果。在实际场景中，当我们需要基于AES/DES的轮密钥恢复主密钥时，我们用 SideChannelMarvels/Stark 这个开源项目，用户体验很好。在另外一些情况中，目标加密算法可以基于某个轮密钥逆推出全体轮密钥，但没法恢复出主密钥，那怎么办呢——这不就是一开始说的吗\n轮密钥所处的内存块可区分吗首先得考虑一个代码编写的问题，在大多数加密实现中，出于模块化以及效率的考量，密钥编排作为一个整体性的、前置的步骤，在明文的运算前就被完全算出来。以AES -128为例，Key 为 16字节，密钥编排后生成11个16字节的轮密钥，这是我们刚学的。很少有程序会在明文运算中，用到了Ki再去编排生成那16字节，而是像我们的Python代码那样，提前生成所有轮密钥，供后续明文运算时使用。在Android Native开发中而言，即K0-K10紧凑的在一块内存中，装在比如 uint8_t RoundKey[176]这样的数组里。我们将全体轮密钥称为轮密钥群，这么叫比较好听。那么如果提供给我们一串字节数据，能否判断其为AES的轮密钥群？这里用上一篇某鱼直播软件使用unidbg算法分析 里面出面的轮密钥群做样例，比如如下的176字节\n0000: 30 29 28 27 26 25 24 23 22 21 00 00 00 00 00 00    0)('&amp;%$#\"!......0010: 52 4A 4B 44 74 6F 6F 67 56 4E 6F 67 56 4E 6F 67    RJKDtoogVNogVNog0020: 7F E2 CE F5 0B 8D A1 92 5D C3 CE F5 0B 8D A1 92    ........].......0030: 26 D0 81 DE 2D 5D 20 4C 70 9E EE B9 7B 13 4F 2B    &amp;...-] Lp...{.O+0040: 53 54 70 FF 7E 09 50 B3 0E 97 BE 0A 75 84 F1 21    STp.~.P.....u..!0050: 1C F5 8D 62 62 FC DD D1 6C 6B 63 DB 19 EF 92 FA    ...bb...lkc.....0060: E3 BA A0 B6 81 46 7D 67 ED 2D 1E BC F4 C2 8C 46    .....F}g.-.....F0070: 86 DE FA 09 07 98 87 6E EA B5 99 D2 1E 77 15 94    .......n.....w..0080: F3 87 D8 7B F4 1F 5F 15 1E AA C6 C7 00 DD D3 53    ...{.._........S0090: 29 E1 35 18 DD FE 6A 0D C3 54 AC CA C3 89 7F 99    ).5...j..T......00A0: B8 33 DB 36 65 CD B1 3B A6 99 1D F1 65 10 62 68    .3.6e..;....e.bh\n这个问题有什么意义？一个比较小的作用在于，在重度混淆的样本里，我们没法自上而下的分析逻辑。那么如果发现某个参数指向这么一片内存，我们可能需要办法确认——这是不是编排后的轮密钥？比较取巧的办法是验证图中橙色部分，验证w5是否等于w4^w1，w6是否等于w5^w2等等。那么比较体系化的办法呢？我们假定上面字节流的最后十六个字节是轮密钥最后一轮，然后逆推出整个轮密钥群，两相对比，如果一致就可确认是否是轮密钥群。在stark中进行验证，传入的参数中，B833DB3665CDB13BA6991DF165106268是假设的轮密钥（字节流最后十六字节），10为第几轮。\nE:\\Project\\c_project\\Stark&gt;aes_keyschedule B833DB3665CDB13BA6991DF165106268 10K00: 30292827262524232221000000000000K01: 524A4B44746F6F67564E6F67564E6F67K02: 7FE2CEF50B8DA1925DC3CEF50B8DA192K03: 26D081DE2D5D204C709EEEB97B134F2BK04: 535470FF7E0950B30E97BE0A7584F121K05: 1CF58D6262FCDDD16C6B63DB19EF92FAK06: E3BAA0B681467D67ED2D1EBCF4C28C46K07: 86DEFA090798876EEAB599D21E771594K08: F387D87BF41F5F151EAAC6C700DDD353K09: 29E13518DDFE6A0DC354ACCAC3897F99K10: B833DB3665CDB13BA6991DF165106268\n比对后可确认一致。AES中还有一个特殊之处，第一轮子密钥就是主密钥，所以密钥就是30292827262524232221000000000000。又因为AES”第一轮子密钥就是主密钥“，所以有个更简单和易懂的办法——假设可疑内存块的前十六个字节是主密钥，做密钥编排，对比两者结果是否一致。现在也有开源的工具可以更快找到密钥，这里推荐龙哥的Unidbg_FindKey\n","tags":["算法"]},{"title":"Android加壳与脱壳（二）加壳和运行时的机制","url":"/posts/7260/","content":"Android App启动流程这里就先以一张图来说明这个过程\n\n(1)点击桌面APP图标时，Launcher的startActivity()方法，通过Binder通信，调用system_server进程中AMS服务的startActivity方法，发起启动请求(2)system_server进程接收到请求后，向Zygote进程发送创建进程的请求(3)Zygote进程fork出App进程，并执行ActivityThread的main方法，创建ActivityThread线程，初始化MainLooper，主线程Handler，同时初始化ApplicationThread用于和AMS通信交互(4)App进程，通过Binder向sytem_server进程发起attachApplication请求，这里实际上就是APP进程通过Binder调用sytem_server进程中AMS的attachApplication方法,AMS的attachApplication方法的作用是将ApplicationThread对象与AMS绑定(5)system_server进程在收到attachApplication的请求，进行一些准备工作后，再通过binder IPC向App进程发送handleBindApplication请求（初始化Application并调用onCreate方法）和scheduleLaunchActivity请求（创建启动Activity）(6)App进程的binder线程（ApplicationThread）在收到请求后，通过handler向主线程发送BIND_APPLICATION和LAUNCH_ACTIVITY消息，这里注意的是AMS和主线程并不直接通信，而是AMS和主线程的内部类ApplicationThread通过Binder通信，ApplicationThread再和主线程通过Handler消息交互。(7)主线程在收到Message后，创建Application并调用onCreate方法，再通过反射机制创建目标Activity，并回调Activity.onCreate()等方法(8)到此，App便正式启动，开始进入Activity生命周期，执行完onCreate&#x2F;onStart&#x2F;onResume方法，UI渲染后显示APP主界面\n\n寒冰大佬在FART：ART环境下基于主动调用的自动化脱壳方案一文中讲述了ActivityThread.main()是进入App世界的大门，并由此展开了对加壳原理的讲述开始进行ActivityThread源码分析，了解ActivityThread的具体操作：以下代码均出自安卓8.1，链接：http://androidxref.com/8.1.0_r33/xref/frameworks/base/core/java/android/app/ActivityThread.java\n6459    public static void main(String[] args) &#123;6460        Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;ActivityThreadMain&quot;);64616462        // CloseGuard defaults to true and can be quite spammy.  We6463        // disable it here, but selectively enable it later (via6464        // StrictMode) on debug builds, but using DropBox, not logs.6465        CloseGuard.setEnabled(false);64666467        Environment.initForCurrentUser();64686469        // Set the reporter for event logging in libcore6470        EventLogger.setReporter(new EventLoggingReporter());64716472        // Make sure TrustedCertificateStore looks in the right place for CA certificates6473        final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId());6474        TrustedCertificateStore.setDefaultUserDirectory(configDir);64756476        Process.setArgV0(&quot;&lt;pre-initialized&gt;&quot;);64776478        Looper.prepareMainLooper();64796480        ActivityThread thread = new ActivityThread();6481        thread.attach(false);64826483        if (sMainThreadHandler == null) &#123;6484            sMainThreadHandler = thread.getHandler();6485        &#125;64866487        if (false) &#123;6488            Looper.myLooper().setMessageLogging(new6489                    LogPrinter(Log.DEBUG, &quot;ActivityThread&quot;));6490        &#125;64916492        // End of event ActivityThreadMain.6493        Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);6494        Looper.loop();64956496        throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);6497    &#125;\n\n根据寒冰大佬描述，在ActivityThread完成实例化操作，调用thread.attach(false)完成一系列初始化准备工作，最后主线程进入消息循环，等待接收来自系统的消息。当收到系统发送来的bindapplication的进程间调用时，调用函数handlebindapplication来处理该请求。可以查看handleMessage方法，查看参数为BIND_APPLICATION，即上面步骤第五步通过binder IPC向App进程发送handleBindApplication请求\n1580        public void handleMessage(Message msg) &#123;1581            if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&gt;&gt;&gt; handling: &quot; + codeToString(msg.what));1582            switch (msg.what) &#123;                    ......1653                case BIND_APPLICATION:1654                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, &quot;bindApplication&quot;);1655                    AppBindData data = (AppBindData)msg.obj;1656                    handleBindApplication(data);1657                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);1658                    break;                    ......1846            &#125;1847            Object obj = msg.obj;1848            if (obj instanceof SomeArgs) &#123;1849                ((SomeArgs) obj).recycle();1850            &#125;1851            if (DEBUG_MESSAGES) Slog.v(TAG, &quot;&lt;&lt;&lt; done: &quot; + codeToString(msg.what));1852        &#125;1853    &#125;\n在处理消息过程，就进入了handlebindapplication函数这里源代码有点长，我再用寒冰大佬文章的内容：\nprivate void handleBindApplication(AppBindData data) &#123;    //step 1: 创建LoadedApk对象    data.info = getPackageInfoNoCheck(data.appInfo, data.compatInfo);    ...    //step 2: 创建ContextImpl对象;    final ContextImpl appContext = ContextImpl.createAppContext(this, data.info);     //step 3: 创建Instrumentation    mInstrumentation = new Instrumentation();     //step 4: 创建Application对象;在makeApplication函数中调用了newApplication，    //在该函数中又调用了app.attach(context)，在attach函数中调用了Application.attachBaseContext函数    Application app = data.info.makeApplication(data.restrictedBackupMode, null);    mInitialApplication = app;     //step 5: 安装providers    List&lt;ProviderInfo&gt; providers = data.providers;    installContentProviders(app, providers);     //step 6: 执行Application.Create回调    mInstrumentation.callApplicationOnCreate(app);\t...&#125;\n定位第四步，Application进行实例化，然后进入makeApplication\n进入983行newApplication函数\n\n这里调用的时1084行的newApplication，但它又调用了1099行的newApplication这里可以看到做了两件事：（1）完成了Application的实例化（2）并调用Application.attach()函数继续进入Application.attach()函数\n\n调用了Application.attachBaseContext函数，回到handleBindApplication，这里就执行完第四步跟进第六步，进入callApplicationOnCreate函数\n执行了Application.onCreate()方法从上面可以看到大概的流程：初始化—&gt;Application的构造函数—&gt;Application.attachBaseContext()—&gt;Application.onCreate()最后才会进入MainActivity中的attachBaseContext函数、onCreate函数可以得出结论，app最先获得执行权限的是app中声明的Application类中的attachBaseContext和onCreate函数。因此，壳要想完成应用中加固代码的解密以及应用执行权的交付就都是在这两个函数上做文章。\n下面这张图大致讲了加壳应用的运行流程。 \n当壳在函数attachBaseContext和onCreate中执行完加密的dex文件的解密后，通过自定义的Classloader在内存中加载解密后的dex文件。为了解决后续应用在加载执行解密后的dex文件中的Class和Method的问题，接下来就是通过利用java的反射修复一系列的变量。其中最为重要的一个变量就是应用运行中的Classloader，只有Classloader被修正后，应用才能够正常的加载并调用dex中的类和方法，否则的话由于Classloader的双亲委派机制，最终会报ClassNotFound异常，应用崩溃退出，这是加固厂商不愿意看到的。由此可见Classloader是一个至关重要的变量，所有的应用中加载的dex文件最终都在应用的Classloader中。\n整体加壳原理Dex整体加壳可以理解为在加密的源Apk程序外面有套上了一层外壳，简单过程为： \n简要概括：壳dex读取源dex文件，通过加密后写进一个新的dex文件，就成为新的APK\n如何对App进行加一层外壳呢，这里就需要应用动态加载的原理，关于动态加载和类加载器，可以看下上一篇文章Android加壳与脱壳（一）ClassLoader和动态加载大概的流程就是\n\n（1）BootClassLoader加载系统核心库（2）PathClassLoader加载APP自身dex（3）进入APP自身组件，解析AndroidManifest.xml，然后查找Application代理（4）调用声明Application的attachBaseContext()对源程序进行动态加载或解密（5）调用声明Application的onCreate()对源程序进行动态加载或解密（6）进入MainActivity中的attachBaseContext()，然后进入onCreate()函数，执行源程序代码\n\n上面文章也说到：\n\nAndroid中的ClassLoader类型分为系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括3种是BootClassLoader、DexClassLoader、PathClassLoader(1)BootClassLoader:Android平台上所有Android系统启动时会使用BootClassLoader来预加载常用的类(2)BaseDexClassLoader:实际应用层类文件的加载，而真正的加载委托给pathList来完成(3)DexClassLoader:可以加载dex文件以及包含dex的压缩文件(apk,dex,jar,zip),可以安装一个未安装的apk文件，一般为自定义类加载器(4)PathClassLoader:可以加载系统类和应用程序的类，通常用来加载已安装的apk的dex文件补充：Android 提供的原生加载器叫做基础类加载器，包括：BootClassLoader，PathClassLoader，DexClassLoader，InMemoryDexClassLoader（Android 8.0 引入），DelegateLastClassLoader（Android 8.1 引入）\n\nDexClassLoader加载的类是没有组件生命周期的，例如Activity。Android 生命周期中的方法（如 onCreate(), onStart(), onResume(), 等）由系统在特定情况下自动调用。直接通过类加载器加载这些类并调用这些方法不会触发正确的生命周期行为，也不会被系统管理。两种解决方法：\n\n替换系统组件类加载器为我们的DexClassLoader，同时设置DexClassLoader的parent为系统组件类加载器。\n打破原有的双亲关系，在系统组件类加载器和BootClassLoader的中间插入我们自己的DexClassLoader即可。\n\n第一种：类加载器替换怎么去替换系统的类加载器，这就和上面分析的ActivityThread中LoadedApk有关了，LoadedApk主要负责加载一个Apk程序，我们进一步分析源码\n在LoadedApk里面就定义了ClassLoader即mClassLoader，可以通过反射获取mclassLoader，然后使用我们的DexClassLoader进行替换。\n\n总结：（1）获取ActivityThread实例（2）通过反射获取类加载器（3）获取LoadedApk（4）获取mClassLoader系统类加载器（5）替换自定义类加载器为系统类加载器\n\n大概的图如下，Android 应用的组件mclassLoader是由PathClassLoader加载的，要把mclassLoader替换成DexClassLoader就可以加载自定义的dex文件\n先新建项目loaddextest编写一个activity类\npackage com.example.loaddextest;import android.os.Bundle;import android.util.Log;import androidx.appcompat.app.AppCompatActivity;public class TestActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Log.i(&quot;zskkk&quot;, &quot;i am from com.example.loaddextest.TestActivity.onCreate&quot;);    &#125;&#125;\n\n设置让apk解压后只生成一个class.dex文件，在proguard-rules.pro中，可以添加如下配置：\n-forceprocessing-dontshrink-dontoptimize\n在 build.gradle 中添加：\nandroid &#123;    defaultConfig &#123;        ...        multiDexEnabled false    &#125;&#125;\n打包解压推送dex到sdcard下命名为2.dex\n在新项目下AndroidMainfest.xml添加读写sdcard的权限，并在application下添加TestActivity\n&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;&lt;application  ...\t&lt;activity android:name=&quot;com.example.loaddextest.TestActivity&quot;&gt;&lt;/application&gt;\n\n在MainActivity下编写如下代码：\npackage com.example.loaddex;import androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import android.util.ArrayMap;import android.util.Log;import java.io.File;import java.lang.ref.WeakReference;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import dalvik.system.DexClassLoader;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Context appContext = this.getApplicationContext();//        testDesClassLoader(appContext, &quot;/sdcard/1.dex&quot;);  // 加载普通类        staticTestActivityFirstMethod(appContext, &quot;/sdcard/2.dex&quot;);   // 加载组件类        Log.i(&quot;zskkk&quot;, String.valueOf(MainActivity.class.getClassLoader()));    &#125;    public void testDesClassLoader(Context context, String dexFilePath) &#123;        File optFile = context.getDir(&quot;opt_path&quot;, 0);  // 用于存放优化的dex文件        File libFile = context.getDir(&quot;lib_path&quot;, 0);  // 用于存放优化的dex文件        ClassLoader parentClassLoader = MainActivity.class.getClassLoader();  // 获取当前的类加载器        ClassLoader tmpClassLoader = context.getClassLoader();  // 获取当前的类加载器        // 指定了它的双亲为mainactivety的classloader,这样就可以访问到mainactivety的类        DexClassLoader dexClassLoader = new DexClassLoader(dexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), MainActivity.class.getClassLoader());  // 创建类加载器        Class&lt;?&gt; clazz = null;        try &#123;            clazz = dexClassLoader.loadClass(&quot;com.example.loaddextest.TestClass&quot;);  // 加载类        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        if (clazz != null) &#123;            try &#123;                Method testFuncMethod = clazz.getDeclaredMethod(&quot;testFunc&quot;);  // 获取方法                Object obj = clazz.newInstance();  // 创建对象                testFuncMethod.invoke(obj);  // 调用方法            &#125; catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;    public void replaceClassLoader(Context context, ClassLoader dexClassLoader) &#123;        ClassLoader classLoader = MainActivity.class.getClassLoader();        try &#123;            // 1. 获取ActivityThread的实例对象            Class&lt;?&gt; ActivityThreadClazz = classLoader.loadClass(&quot;android.app.ActivityThread&quot;);            Method currentActivityThread = ActivityThreadClazz.getDeclaredMethod(&quot;currentActivityThread&quot;);            Object activityThreadObj = currentActivityThread.invoke(null);            // 2. 通过反射获得类加载器            // final ArrayMap&lt;String, WeakReference&lt;LoadedApk&gt;&gt; mPackages = new ArrayMap&lt;&gt;();            Field mPackagesField = ActivityThreadClazz.getDeclaredField(&quot;mPackages&quot;);            mPackagesField.setAccessible(true); // 设置可访问            // 3. 拿到LoaderApk            ArrayMap mPackagesObj = (ArrayMap) mPackagesField.get(activityThreadObj); // 获取了 ActivityThread 类中名为 mPackages 的字段的值，该字段是一个 ArrayMap 类型的对象，用于存储应用程序包名与 LoadedApk 对象的映射关系            String packageName = context.getPackageName();  // 获取当前应用的包名。            WeakReference wr = (WeakReference) mPackagesObj.get(packageName);            Object LoadApkObj = wr.get();            // 4.拿到mclassLoader            Class LoadedApkClass = classLoader.loadClass(&quot;android.app.LoadedApk&quot;);            // private ClassLoader mClassLoader;            Field mClassLoaderField = LoadedApkClass.getDeclaredField(&quot;mClassLoader&quot;);            mClassLoaderField.setAccessible(true);//            Object mClassLoader = mClassLoaderField.get(LoadApkObj);  // 获取 LoadedApk 对象 LoadApkObj 中的 mClassLoader 字段值：//            Log.e(&quot;mClassLoader&quot;,mClassLoader.toString());            // 5.将系统组件ClassLoader给替换            mClassLoaderField.set(LoadApkObj, dexClassLoader);        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchMethodException e) &#123;            e.printStackTrace();        &#125; catch (InvocationTargetException e) &#123;            e.printStackTrace();        &#125; catch (IllegalAccessException e) &#123;            e.printStackTrace();        &#125; catch (NoSuchFieldException e) &#123;            e.printStackTrace();        &#125;    &#125;    public void staticTestActivityFirstMethod(Context context, String dexFilePath)&#123;        File optFile = context.getDir(&quot;opt_dex&quot;, 0);        File libFile = context.getDir(&quot;lib_path&quot;, 0);        DexClassLoader dexClassLoader = new DexClassLoader(dexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), MainActivity.class.getClassLoader());  // 创建类加载器        replaceClassLoader(context, dexClassLoader);        Class&lt;?&gt; clazz = null;        try &#123;            clazz = dexClassLoader.loadClass(&quot;com.example.loaddextest.TestActivity&quot;);  // 加载类        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        context.startActivity(new Intent(context, clazz));    &#125;&#125;// com.example.loaddex I/zskkk: dalvik.system.PathClassLoader// com.example.loaddex I/zskkk: i am from com.example.loaddextest.TestActivity.onCreate\n\n第二种：类加载器插入还有一种方案，动态加载中我们讲述了类加载器的双亲委派机制，就是说我们的类加载器刚拿到类，并不会直接进行加载，而是先判断自己是否加载，如果没有加载则给自己的父类，父类再给父类，所以我们让DexClassLoader成为PathClassLoader的父类，这样就可以解决DexClassLoader生命周期的问题大概的图如下：\n总结：（1）将DexClassloader父节点设置为BootClassLoader（2）将PathClassLoader父节点设置为DexClassloader\npublic void staticTestActivitySecondMethod(Context context, String dexFilePath)&#123;    File optFile = context.getDir(&quot;opt_dex&quot;, 0);    File libFile = context.getDir(&quot;lib_path&quot;, 0);    ClassLoader pathClassLoader = MainActivity.class.getClassLoader();    ClassLoader bootClassLoader = MainActivity.class.getClassLoader().getParent();    DexClassLoader dexClassLoader = new DexClassLoader(dexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), bootClassLoader);  // 创建类加载器    try &#123;        Field parentField = ClassLoader.class.getDeclaredField(&quot;parent&quot;);        parentField.setAccessible(true);        parentField.set(pathClassLoader, dexClassLoader);    &#125; catch (NoSuchFieldException e) &#123;        e.printStackTrace();    &#125; catch (IllegalAccessException e) &#123;        e.printStackTrace();    &#125;    Class&lt;?&gt; clazz = null;    try &#123;        clazz = dexClassLoader.loadClass(&quot;com.example.loaddextest.TestActivity&quot;);  // 加载类    &#125; catch (ClassNotFoundException e) &#123;        e.printStackTrace();    &#125;    context.startActivity(new Intent(context, clazz));&#125;\n\n加壳案例实现1. 编写源程序package com.example.loaddextest;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.util.Log;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Log.i(&quot;zskkk&quot;, &quot;i am a source dex&quot;);    &#125;&#125;\n这就是我们的源程序，源程序运行，我们会在日志中看见我们打印的信息，然后我们生成dex文件 。先打包成apk解压得到dex文件，push到sdcard。\n2. 编写壳程序编写代理类模仿上面的加壳，在attachBaseContext或onCreate中对我们的dex进行动态加载和类加载器修正即可，因为这里我们源dex并未进行加密，所以也无需解密的过程\npackage com.example.loaddex;import android.app.Application;import android.content.Context;import android.content.Intent;import android.util.ArrayMap;import android.util.Log;import java.io.File;import java.lang.ref.WeakReference;import java.lang.reflect.Field;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import dalvik.system.DexClassLoader;public class StubApplication extends Application &#123;    @Override    protected void attachBaseContext(Context base) &#123;        super.attachBaseContext(base);        String dexFilePath = &quot;/sdcard/3.dex&quot;;        File optFile = base.getDir(&quot;opt_dex&quot;, 0);        File libFile = base.getDir(&quot;lib_path&quot;, 0);        ClassLoader parentClassLoader = StubApplication.class.getClassLoader();        DexClassLoader dexClassLoader = new DexClassLoader(dexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), StubApplication.class.getClassLoader());  // 创建类加载器        // 使用上面的一种方法进行类加载器修正        replaceClassLoader(this, dexClassLoader);        try &#123;            Class&lt;?&gt; activityClass = dexClassLoader.loadClass(&quot;com.example.loaddextest.MainActivity&quot;);            startActivity(new Intent(StubApplication.this, activityClass));        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;    &#125;    public void replaceClassLoader(Context context, ClassLoader dexClassLoader)&#123;        ...    &#125;    @Override    public void onCreate() &#123;        super.onCreate();    &#125;&#125;\n在新建项目的AndroidMainfest.xml添加读写sdcard的权限，还有在application下代理类别，加入导入类的Activity\n&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;...&lt;application  android:name=&quot;.StubApplication&quot;  ...  &lt;activity android:name=&quot;com.example.loaddextest.MainActivity&quot;&gt;&lt;/activity&gt;&lt;/application&gt;\n\n运行成功，说明我们的整体加壳成功\n","tags":["脱壳"]},{"title":"App带壳重打包去强制升级","url":"/posts/44618/","content":"1.查壳打开app，弹出强制升级无法取消用jadx打开apk\n搜索包名，可以看到是加壳了\n\n2.使用dexdump进行脱壳先打开frida-server，打开objextion并加载dexdump插件，输入plugin  dexdump dump命令进行脱壳，就把dex文件脱出来了\n进入到dex文件的位置，使用grep -ril “MainActivity” *  命令搜索MainActivity再哪个dex，用jadx打开\n3.定位到弹窗代码位置https://www.jianshu.com/p/18e1f518c625根据弹出框的实现方法进行搜索对应的类打印出所有的类，然后输入cat .objection/objection.log |grep -i window 进行搜索\n由于app启动的时候就把弹窗加载出来了，所以要在没加载前hook类使用–startup-command可以重启app并进行hook\nobjection -g com.hello.qqc explore --startup-command &quot;android hooking watch class android.view.Window&quot;\n出现很多的window，无法保证加载的类就是弹窗的\n换一种方式 Dialog搜索dialog有哪些类，出来两个比较可疑的\n先对android.app.Dialog进行hook，看有没有反应查看文档发现setCancelable是不让返回，所以点后退一直没反应)hook这个类android.app.Dialog.setCancelable 查看调用\nandroid hooking watch class_method android.app.Dialog.setCancelable --dump-args --dump-backtrace --dump-return\n\n用jadx搜索观察cn.net.tokyo.ccg.ui.fragment.dialog.UpdateDialogFragment.onCreateDialog\n\n加载wallbreaker搜索该类实例\nplugin wallbreaker objectsearch cn.net.tokyo.ccg.ui.fragment.dialog.UpdateDialogFragment\n查看该对象的属性\nplugin wallbreaker objectdump --fullname 0x74e\n\n4.查找哪句代码控制弹窗查看cn.net.tokyo.ccg.ui.fr agment.dialog.UpdateDialogFragment.b 的调用栈\nandroid hooking watch class_method cn.net.tokyo.ccg.ui.fragment.dialog.UpdateDialogFragment.b --dump-args --dump-backtrace --dump-return\n查看对应smail代码，把eqz改为nez\n5.把壳脱掉重打包看能不能用解包，保留dex文件apktool -s d qqc.apk删除class.dex，把脱下来的dex替换进去\n修改dex执行的入口vim AndroidManifest.xml 修改为cn.net.tokyo.ccg.base.App打包，签名生成签名，keytool -genkey -keystore my-release-key.keystore -alias my_alias -keyalg RSA -keysize 4096 -validity 10000进行签名，jarsigner -sigalg MD5withRSA -digestalg SHA1 -keystore my-release-key.keystore -signedjar qqc.apk qqc.apk my_alias安装，看有没有报错，能不能正常使用\n6.修改smail文件重打包找到对应的smail文件tree -NCfhl |grep -i MainActivity把 if -eqz改为if-nez重打包\n","tags":["脱壳"]},{"title":"Android加壳与脱壳（一）ClassLoader和动态加载","url":"/posts/23195/","content":"三层类加载器1. 启动类加载器  Bootstrap ClassLoader负责加载存在放&lt;JAVA_HOME&gt;\\lib目录或者-Xbootclasspath指定的路径中存放的类库。比如java.lang、java.uti等这些系统类。启动类加载器无法被java程序直接引用，但可以通过在自定义类加载器时将getClassLoader的返回值设为null  将加载请求委派给启动类加载器处理。\n2. 扩展类加载器  Extensions ClassLoader它负责加载&lt;JAVA_HOME&gt;\\lib\\ext目录中或者java.ext.dirs指定的路径下的类库。Java中实现类为ExtClassLoader，提供了除了系统类之外的额外功能，可以在java里获取。\n3.应用程序类加载器  Application ClassLoader负责加载用户类路径上的所有类库。该加载器可以通过ClassLoader的静态方法getSystemLoader获得。java中的实现类为AppClassLoader，与我们接触最多的类加载器，也可以通过ClassLoader.getSystemClassLoader返回。\n自定义类加载器需要通过继承java.lang.ClassLoader类的方式来实现自己的类加载器即可。加载顺序Bootstrap ClassLoader、Extention ClassLoader、AppClassLoader。\n双亲委派模式\nprotected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException&#123;       //1.先检查是否已经加载过--findLoaded       Class&lt;?&gt; c = findLoadedClass(name);       if (c == null) &#123;           try &#123;               //2.如果自己没加载过,存在父类,则委托父类               if (parent != null) &#123;                   c = parent.loadClass(name, false);               &#125; else &#123;                   c = findBootstrapClassOrNull(name);               &#125;           &#125; catch (ClassNotFoundException e) &#123;           &#125;           if (c == null) &#123;               //3.如果父类也没加载过,则尝试本级classLoader加载               c = findClass(name);           &#125;       &#125;      return c;&#125;\n\n双亲委派模式的工作原理是如果一个类加载器收到了累加器的请求，他并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式。\n\n我们要加载一个class文件，我们定义了一个CustomerClassLoader类加载器:(1)首先会判断自己的CustomerClassLoader否加载过,如果加载过直接返回,(2)如果没有加载过则会调用父类PathClassLoader去加载,该父类同样会判断自己是否加载过,如果没有加载过则委托给父类BootClassLoader去加载,(3)这个BootClassLoader是顶级classLoader,同样会去判断自己有没有加载过,如果也没有加载过则会调用自己的findClass(name)去加载,(4)如果顶级BootClassLoader加载失败了,则会把加载这个动作向下交还给PathClassLoader,(5)这个PathClassLoader也会尝试去调用findClass(name);去加载,如果加载失败了,则会继续向下交还给CustomClassLoader来完成加载,这整个过程感觉是一个递归的过程,逐渐往上然后有逐渐往下,直到加载成功其实这个String.class在系统启动的时候已经被加载了,我们自己定义一个CustomerClassLoader去加载,其实也是父类加载的\n\n好处：1.避免重复加载，如果已经加载过一次class，可以直接读取已经加载的class。2.更加安全，无法自定义类来替代系统的类，可以防止核心api库被随意篡改。\n这种机制天生就给java类划分了带优先级的层次关系，bootstrap classloader优先级最高。假设用户自己写了一个java.lang.object类，在加载时会加载请求会委派给bootstrap classloader，它会去\\lib目录下加载jdk自带的java.lang.object类，这样不管用哪个类加载器去加载java.lang.object都会是同一个类。如果没有双亲委派的话，出现不同的java.lang.object类型，那么java类型体系中最基础的行为都无法保证。\nAndroid系统中的ClassLoader的继承关系\nAndroid系统中与ClassLoader相关的一共有8个：ClassLoader为抽象类。BootClassLoader预加载常用类继承自ClassLoader，单例模式。与Java中的BootClassLoader不同，并不是由C&#x2F;C++代码实现，而是由Java实现的。BaseDexClassLoader是PathCLassLoader、DexCLassLoader、InMemoryCLassLoader的父类，类加载器的主要逻辑都是在BaseDexClassLoader完成的。SecureClassLoader继承了抽象类CLassLoader，扩展了ClassLoader类加入了权限方面的功能，加强了安全性，其子类URLClassLOader是用URl路径和jar文件中加载类和资源。其中重点关注PathCLassLoader、DexCLassLoaderPathClassLoader是Android默认使用的类加载器，一个apk中的Activity等类便是在其中加载。DexCLassLoader可以加载任意目录下的dex&#x2F;jar&#x2F;apl&#x2F;zip文件，比PathClassLoader更灵活，是实现插件化，热修复，以及dex加壳的重点。Android8.0新引入InMemoryDexClassloader，从名字看出是直接从内存中加载dex\n通过查看Android8.0的源码，ClassLoader是一个抽象类，里面还有个parent变量，这是实现双亲委派机制的关键。对于每个继承的ClassLoader的类，都有parent来表示父节点。还定义了final，只能进行一次赋值。对于实现插件化，热修复parent是一个关键的变量。不带参的默认ClassLoader构造函数会将parent指定为systemClassLoader,也就是说在不指定 &lt;父&gt;classloader的情况下，而是每个加载器内部都有一个parent，代表它的父classloader。只有bootstrap classloader的parent为null。\n\n看下面PathCLassLoader、DexCLassLoader、InMemoryCLassLoader的源码都很少，主要逻辑都是在父类BaseDexClassLoader里。DexClassLoader\npublic class DexClassLoader extends BaseDexClassLoader &#123;    /**     * Creates a &#123;@code DexClassLoader&#125; that finds interpreted and native     * code.  Interpreted classes are found in a set of DEX files contained     * in Jar or APK files.     *     * &lt;p&gt;The path lists are separated using the character specified by the     * &#123;@code path.separator&#125; system property, which defaults to &#123;@code :&#125;.     *     * @param dexPath the list of jar/apk files containing classes and     *     resources, delimited by &#123;@code File.pathSeparator&#125;, which     *     defaults to &#123;@code &quot;:&quot;&#125; on Android     * @param optimizedDirectory directory where optimized dex files     *     should be written; must not be &#123;@code null&#125;     * @param librarySearchPath the list of directories containing native     *     libraries, delimited by &#123;@code File.pathSeparator&#125;; may be     *     &#123;@code null&#125;     * @param parent the parent class loader     */    public DexClassLoader(String dexPath, String optimizedDirectory,                          String librarySearchPath, ClassLoader parent) &#123;        super(dexPath, new File(optimizedDirectory), librarySearchPath, parent);    &#125;&#125;\n\nPathClassLoader\npublic class PathClassLoader extends BaseDexClassLoader &#123;    /**     * Creates a &#123;@code PathClassLoader&#125; that operates on a given list of files     * and directories. This method is equivalent to calling     * &#123;@link #PathClassLoader(String, String, ClassLoader)&#125; with a     * &#123;@code null&#125; value for the second argument (see description there).     *     * @param dexPath the list of jar/apk files containing classes and     * resources, delimited by &#123;@code File.pathSeparator&#125;, which     * defaults to &#123;@code &quot;:&quot;&#125; on Android     * @param parent the parent class loader     */    public PathClassLoader(String dexPath, ClassLoader parent) &#123;        super(dexPath, null, null, parent);    &#125;    /**     * Creates a &#123;@code PathClassLoader&#125; that operates on two given     * lists of files and directories. The entries of the first list     * should be one of the following:     *     * &lt;ul&gt;     * &lt;li&gt;JAR/ZIP/APK files, possibly containing a &quot;classes.dex&quot; file as     * well as arbitrary resources.     * &lt;li&gt;Raw &quot;.dex&quot; files (not inside a zip file).     * &lt;/ul&gt;     *     * The entries of the second list should be directories containing     * native library files.     *     * @param dexPath the list of jar/apk files containing classes and     * resources, delimited by &#123;@code File.pathSeparator&#125;, which     * defaults to &#123;@code &quot;:&quot;&#125; on Android     * @param librarySearchPath the list of directories containing native     * libraries, delimited by &#123;@code File.pathSeparator&#125;; may be     * &#123;@code null&#125;     * @param parent the parent class loader     */    public PathClassLoader(String dexPath, String librarySearchPath, ClassLoader parent) &#123;        super(dexPath, null, librarySearchPath, parent);    &#125;&#125;\n\nInMemoryDexClassLoader\npublic final class InMemoryDexClassLoader extends BaseDexClassLoader &#123;    /**     * Create an in-memory DEX class loader with the given dex buffers.     *     * @param dexBuffers array of buffers containing DEX files between     *                       &lt;tt&gt;buffer.position()&lt;/tt&gt; and &lt;tt&gt;buffer.limit()&lt;/tt&gt;.     * @param parent the parent class loader for delegation.     * @hide     */    public InMemoryDexClassLoader(ByteBuffer[] dexBuffers, ClassLoader parent) &#123;        super(dexBuffers, parent);    &#125;    /**     * Creates a new in-memory DEX class loader.     *     * @param dexBuffer buffer containing DEX file contents between     *                       &lt;tt&gt;buffer.position()&lt;/tt&gt; and &lt;tt&gt;buffer.limit()&lt;/tt&gt;.     * @param parent the parent class loader for delegation.     */    public InMemoryDexClassLoader(ByteBuffer dexBuffer, ClassLoader parent) &#123;        this(new ByteBuffer[] &#123; dexBuffer &#125;, parent);    &#125;&#125;\n\n代码验证public void testClassLoader()&#123;    ClassLoader thisClassloader = MainActivity.class.getClassLoader();    Log.i(&quot;ClassLoaderTag&quot;, &quot;thisClassLoader: &quot; + thisClassloader);    ClassLoader tmpClassloader = null;    ClassLoader parentClassloader = thisClassloader.getParent();    while (parentClassloader != null) &#123;        Log.i(&quot;ClassLoaderTag&quot;, &quot;this:&quot; + thisClassloader + &quot;---&quot; + parentClassloader);        tmpClassloader = parentClassloader.getParent();        thisClassloader = parentClassloader;        parentClassloader = tmpClassloader;    &#125;    Log.i(&quot;ClassLoaderTag&quot;, &quot;root:&quot; + thisClassloader);&#125;// thisClassLoader: dalvik.system.PathClassLoader// this:dalvik.system.PathClassLoader---java.lang.BootClassLoader@e2f9b5c// root:java.lang.BootClassLoader@e2f9b5c\n\n动态加载dex，调用dex的函数import android.util.Log;public class TestClass &#123;    public void testFunc()&#123;        Log.i(&quot;DexTestTag&quot;, &quot;i am from com.example.test01.TestClass.testFunc&quot;);    &#125;&#125;\n设置让apk解压后只生成一个class.dex文件，在proguard-rules.pro中，可以添加如下配置：\n-forceprocessing-dontshrink-dontoptimize\n在 build.gradle 中添加：\nandroid &#123;    defaultConfig &#123;        ...        multiDexEnabled false    &#125;&#125;\n打包解压推送dex到sdcard下命名为1.dex\n再新建个项目用于加载上面dex文件里面的testFunc函数，用DexClassLoader类去加载dex文件\n// DexClassLoader方法参数：// dexPath：目标所在的apk或者jar文件的路径，装载器将从路径中寻找指定的目标类。// dexOutputDir：由于dex文件在apk或者jar文件中，所以在装载前面前先要从里面解压出dex文件，这个路径就是dex存放的路径，在android系统中，一个应用程序对应一个linux用户id，应用程序只对自己的数据目录有写的权限，所以存放在这个路径。// libPath：目标类中使用的C/C++库。// 最后一个参数是该装载器的父装载器，一般为当前类执行的装载器。\n\nimport androidx.appcompat.app.AppCompatActivity;import android.content.Context;import android.os.Bundle;import java.io.File;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;import dalvik.system.DexClassLoader;public class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        Context appContext = this.getApplicationContext();        testDesClassLoader(appContext,  &quot;/sdcard/1.dex&quot;);    &#125;    public void testDesClassLoader(Context context, String dexFilePath)&#123;        File optFile = context.getDir(&quot;opt_path&quot;, 0);  // 用于存放优化的dex文件        File libFile = context.getDir(&quot;lib_path&quot;, 0);  // 用于存放优化的dex文件        // ClassLoader parentClassLoader = MainActivity.class.getClassLoader();  // 获取当前的类加载器        // ClassLoader tmpClassLoader = context.getClassLoader();  // 获取当前的类加载器        // 指定了它的双亲为mainactivety的classloader,这样就可以访问到mainactivety的类        DexClassLoader dexClassLoader = new DexClassLoader(dexFilePath, optFile.getAbsolutePath(), libFile.getAbsolutePath(), MainActivity.class.getClassLoader());  // 创建类加载器        Class&lt;?&gt; clazz = null;        try &#123;            clazz = dexClassLoader.loadClass(&quot;com.example.test01.TestClass&quot;);  // 加载类        &#125; catch (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        if (clazz != null)&#123;            try &#123;                Method testFuncMethod = clazz.getDeclaredMethod(&quot;testFunc&quot;);  // 通过反射获取方法                Object obj = clazz.newInstance();  // 创建对象                testFuncMethod.invoke(obj);  // 调用方法            &#125; catch (NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) &#123;                e.printStackTrace();            &#125;        &#125;    &#125;&#125;// I/DexTestTag: i am from com.example.test01.TestClass.testFunc\n还要在AndroidMainfest.xml文件里添加读写sd卡的权限,并在手机设置给应用增加读取文件权限\n&lt;uses-permission android:name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot;&gt;&lt;/uses-permission&gt;\n\n这样就实现了dex通过ClassLoader加载进行调用，并指定了MainActivity.class.getClassLoader()，也就是PathClassLoader作为父节点。\n","tags":["脱壳"]},{"title":"App解固脱壳方式","url":"/posts/10237/","content":"样例app下载链接\n一、常见的壳通常是看lib文件夹下so库特征，以下是市面上常见的不同厂商对APP的加固特征：爱加密：libexec.so,libexecmain.so，ijiami.dat 梆梆： libsecexe.so,libsecmain.so , libDexHelper.so libSecShell.so360：libprotectClass.so,libjiagu.so，libjiagu_art.so，libjiagu_x86.so 百度：libbaiduprotect.so 腾讯：libshellx-2.10.6.0.so，libBugly.so，libtup.so, libexec.so，libshell.so，stub_tengxun 网易易盾：libnesec.so为什么要加固：     一定程度保护源代码加固方式：    .dex加固 .so加固 \n二、加固原理壳dex 读取源dex文件，加密后，写进一个新的dex文件\n新APK运行 先加载壳APP—&gt;壳APP读Dex文件末尾的源APKD大小—-&gt;在内存中壳APP解密出源APP—&gt;运行源APP 壳APK有自己的Application对象 源APK有自己的Application对象 壳APK启动时 在AndroidMenifest.xml里找源APK的Application 执行它的oncreate方法 启动源APK Dex文件格式：  任何类型的文件都有文件格式，对应的软件按照文件格式来就能解析出类型，.xml .json .jpeg\n三、如何查看有没有壳用apktool对apk进行反编译，或者修改apk的后缀为zip，进行解压。查看解压后的文件下的lib目录，可以看到这两个是用了腾讯的乐加固，或者我们不确定的话可以用jadx打开apk，也是可以发现的都是壳的代码。不过即使怎么加壳，它都会去调源apk的Application，打开AndroidManifest.xml文件，可以看到，上面一个是壳的，下面是源apk的Application。逆向&#x2F;脱壳方法 反编译&#x2F;Hook技术和动态调试 Hook：先取得要Hook函数&#x2F;方法的控制权，不用破坏程序 动态调试：反调试，汇编，计算内存地址\n四、Hook技术改变程序执行流程的一种技术 在函数被调用前，通过HOOK技术，先得到该函数的控制权，实现该函数的逻辑改写Hook可以在在Java层、Native层（.so库） 在代码层 寻找要Hook的地方 进行Hook 改下代码逻辑\n五、脱壳工具脱壳原理：在壳APK解密源APK后，源APK被加载前，拦截这个过程中的系统函数 把内存种Dex dump出来。\n手动脱壳：通过动态调试，跟踪计算Dex源文件的内存偏移地址，从内存中Dump出Dex文件 ，难度大，寄存器，汇编，反调试，反读写  IDA。\n工具脱壳：    HOOK技术&#x2F;内存特征寻找  简单易操作  \n基于xposed 脱壳工具：          Fdex2：Hook ClassLoader loadClass方法         通用脱壳  dumpDex：https://github.com/WrBug/dumpDex逆向框架： 筑好底层 提供开发接口xposed（Java 编译，只能在java层）  frida（Python Javascript 代码注入，可以hook住java层、Native层） \n六、开始脱壳（用FDex2脱壳）首先我们打开xposed，把FDex2打开，并选择我们要的app接下来就可以运行app，然后我们去/data/user/0/com.iCitySuzhou.suzhou001该目录下查看，多出来两个dex文件把这两个文件拉到电脑用kadx打开，第一个是壳打开第二个很明显看到这才是源apk的源码，而且可以发现它对源码进行混淆了所以到这里我们的脱壳就成功了。\n七、开始脱壳（用Frida脱壳）Frida脱壳function_address = Module.findExportByName(libname, function);Interceptor.attach(address, func);Interceptor.attach(address, onEnter: function (args) &#123; &#125;, onLeave: function (retval) &#123; &#125;)File 模块 写文件流程 new File(filepath, mode) write(data) flush() close()file = new File(&quot;yuanrenxue.dex&quot;, &quot;wb&quot;)//data 是字符串或者 arrayBuffer // readByteArray() 返回的arrayBufferfile.write(data)file.flush()file.close()//把内存里的值转成字符串Memory.readUtf8String()//把内存里的值转换成整型Memory.readInt()//以begin为起始位置，从内存中读length长度的数据出来 返回ArrayBuffer类型Memory.readByteArray(begin, length)//把地址转换成NativePointer类型 frida里操作内存地址需要NativePointer类型ptr()JS api#把其它进制转换成10进制parseInt(num, radix)\n加壳apk运行流程：app启动后–&gt;壳dex先加载起来–&gt;把源classes.dex读出来–&gt;解密源classes.dex–&gt;把源classes.dex给加载进内存–&gt;源dex运行起来下两篇文章都对dex进行了详解Dex文件格式详解 https://www.jianshu.com/p/f7f0a712ddfeART 加载dex文件 https://www.jianshu.com/p/f81242ad8cb7\ndex文件结构\n\n\n数据名称\n解释\n\n\n\nheader\ndex文件头部，记录整个dex文件的相关属性\n\n\nstring_ids\n字符串数据索引，记录了每个字符串在数据区的偏移量\n\n\ntype_ids\n类似数据索引，记录了每个类型的字符串索引\n\n\nproto_ids\n原型数据索引，记录了方法声明的字符串，返回类型字符串，参数列表\n\n\nfield_ids\n字段数据索引，记录了所属类，类型以及方法名\n\n\nmethod_ids\n类方法索引，记录方法所属类名，方法声明以及方法名等信息\n\n\nclass_defs\n类定义数据索引，记录指定类各类信息，包括接口，超类，类数据偏移量\n\n\ndata\n数据区，保存了各个类的真是数据\n\n\nlink_data\n连接数据区\n\n\nheader简单记录了dex文件的一些基本信息，以及大致的数据分布。长度固定为0x70,其中每一项信息所占用的内存空间也是固定的，好处是虚拟机在处理dex时不用考虑dex文件的多样性\n\n\n\n字段名称\n偏移值\n长度\n说明\n\n\n\nmagic\n0x0\n8\n魔数字段，值为”dex\\\n\n\n035\\0”（固定的）\n\n\n\n\n\nchecksum\n0x8\n4\n校验码\n\n\nsignature\n0xc\n20\nsha-1签名\n\n\nfile_size\n0x20\n4\ndex文件总长度\n\n\n……\n……\n…..\n……\n\n\n字段太多就不都展示出来，可以看到file_size这个就是我们要找的dex文件,因为源dex解密后会加载进内存，所以我们去Hook加载Dex的函数，把Dex从内存中dump出来。下面这个函数就是把解密后的源dex加载进内存：DexFile::OpenMemory(const uint8_t* base,   size_t size,   const std::string&amp; location,    uint32_t location_checksum,    MemMap* mem_map,&#x2F;&#x2F;nullptr const OatDexFile* oat_dex_file,    std::string* error_msg)OpenMemory()是在安卓系统/system/lib/libart.so里面，然后我们先把这个so文件拉到电脑用IDA打开打开IDA选择静态调试，打开libart.so这个文件这些就是so文件里面的函数，点击这个框，按ctrl+f进行搜索，输入OpenMemory这个函数，右键进行编辑，_ZN3art7DexFile10OpenMemoryEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_这个字符串就是OpenMemory函数在内存中对外的方法名，我们打开IDA就是为了找这个方法名。\n现在来写脚本：\nimport fridaimport syspackage = &quot;com.iCitySuzhou.suzhou001&quot;open_memory_6 = &quot;_ZN3art7DexFile10OpenMemoryEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_&quot;#OpenMemory 在libart.so中  art虚拟机(安卓5)  davlink虚拟机（安卓4）#Hook OpenMemory的导出方法名#用IDA 打开libart.so 查看OpenMemory的导出方法名#OpenMemory的第一个参数是dex文件在内存中的起始位置#根据dex文件格式 从起始位置开始 第32个字节 是该dex文件的大小#知道dex起始位置和整个文件大小，只需要把这段内存dum出来即可#适用于 安卓 6 7 8 9#文件的起始位置 文件的大小 知道了文件的结束位置def on_message(message, data):    if message[&#x27;type&#x27;] == &#x27;send&#x27;:        print(&quot;[*] &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;]))    else:        print(message)src = &quot;&quot;&quot;//找so文件某个方法地址，找openMemory的内存地址var openMemory_address = Module.findExportByName(&quot;libart.so&quot;, &quot;_ZN3art7DexFile10OpenMemoryEPKhjRKNSt3__112basic_stringIcNS3_11char_traitsIcEENS3_9allocatorIcEEEEjPNS_6MemMapEPKNS_10OatDexFileEPS9_&quot;);send(&#x27;openMemory address:&#x27;+openMemory_address)//hook openMemory地址Interceptor.attach(openMemory_address, &#123;    //一进入openMemory，就会调用onEnter方法    onEnter: function (args) &#123;        //dex文件的起始位置        var dex_begin_address = args[1]        //dex文件的前8个字节是magic字段 看dex的文件格式说明        //打印magic（会显示 &quot;dex 035&quot;） 三个字符 可以验证是否为dex文件         console.log(&quot;magic : &quot; + Memory.readUtf8String(dex_begin_address))        //把地址转换成整型（十进制） 再加32         //因为dex文件的第32个字节处存放的是 dex文件的大小        var address = parseInt(dex_begin_address, 16) + 0x20        //把address地址指向的内存值读出来 该值就是dex的文件大小        //ptr(address)转换的原因是 frida只接受 NativePointer类型指针        var dex_size = Memory.readInt(ptr(address))        console.log(&quot;dex_size :&quot; + dex_size)                //frida写文件 把内存中的数据 写到本地        var timestamp = new Date().getTime();        var file = new File(&quot;/data/data/%s/&quot; + timestamp + &quot;.dex&quot;, &quot;wb&quot;)        //Memory.readByteArray(begin, length)        //把内存里的数据读出来，从begin开始读，取length长度        file.write(Memory.readByteArray(dex_begin_address, dex_size))        file.flush()        file.close()        send(&quot;dex begin address:&quot;+parseInt(dex_begin_address,16))        send(&quot;dex file size:&quot;+dex_size)    &#125;,    onLeave: function (retval) &#123;        if (retval.toInt32() &gt; 0) &#123;        &#125;    &#125;&#125;);&quot;&quot;&quot;%(package)print(&quot;dex 导出目录为: /data/data/%s&quot;%(package))device = frida.get_usb_device()pid = device.spawn(package)session = device.attach(pid)script = session.create_script(src)script.on(&quot;message&quot; , on_message)script.load()device.resume(pid)sys.stdin.read()\n把frida-server运行起来 hook需要app运行，先把app打开，再运行脚本，我们去手机/data/data/com.iCitySuzhou.suzhou001目录下查看，会多了几个dex文件把这些dex文件拉到电脑用jadx打开看下，一个个查看后，找到了源dex到这里用frida脱壳也成功了。。。\n补充壳的种类⾮常多，根据其种类不同，使⽤的技术也不同，这⾥稍微简单分个类：\n\n⼀代整体型壳：采⽤ Dex 整体加密，动态加载运⾏的机制；\n⼆代函数抽取型壳：粒度更细，将⽅法单独抽取出来，加密保存，解密执⾏；\n三代 VMP、Dex2C 壳：独⽴虚拟机解释执⾏、语义等价语法迁移，强度最⾼。\n\n先说最难的 Dex2C ⽬前是没有办法还原的，只能跟踪进⾏分析； VMP 虚拟机解释执⾏保护的是映射表，只要⼼思细、功夫深，是可以将映射表还原的；\n⼆代壳函数抽取⽬前是可以从根本上进⾏还原的， dump 出所有的运⾏时的⽅法体，填充到 dump 下来的 dex 中去的，这也是fart的核⼼原理。\nfrida-Dexdumphttps://github.com/hluwa/FRIDA-DEXDump\n利⽤ frida 的搜索内存，通过匹配 DEX ⽂件的特征，例如 DEX ⽂件的 文件头 中的 magic — dex.035 这个特征。 frida-Dexdump 便是这种脱壳⽅法的代表作。\n\n对于于完整的 dex，采⽤暴⼒搜索 dex035 即可找到。\n⽽对于抹头的 dex，通过匹配⼀些特征来找到，然后⾃动修复⽂件头。\n\n抽取 -&gt; invoke -&gt; 还原 -&gt; 再抽取\n","tags":["脱壳"]},{"title":"Frida&反调试&反反调试","url":"/posts/14651/","content":"操作Frida的两种模式：命令，rpcFrida两种操作APP模式：spawn，attachattach：应用运行中hook，有壳也是没问题的spawn：创建进程时就hook，有壳的话就不行\n反调试Frida1.查看&#x2F;data&#x2F;local&#x2F;usr是否firda文件2.端口20742是否开启3.进程中是否有frida4.检测内存trate是否开启，因为frida调试会显示true，解决方法：使用spawn模式hook检测trate的方法，返回false\n三板斧：\n先hook、看参数和返回值：定位：命令行\n再构造参数、主动调用：利用：命令行\n最后配RPC导出结果：规模化利用：PYTHON\n\n作弊检测1.检测是否存在危险APP包名主要检测hook框架，模拟点击工具，xposed，magisk，supersu等root工具\n2.一些设备常规信息，比如电量状态，usb状态，屏幕亮度，地理位置，wifi或者sim卡信息，ip，mac等。一般批量操作或者抹机操作的时候这些值更改难度和成本比较大，所以这些指标能伪造会大大降低被风控\n3.APP加壳4.手机系统usr&#x2F;local&#x2F;tmp下是否有frida，端口27042是否开着，TracerPid值是否在调试状态（京东9.22）5.参数签名、参数加密，把加密参数放在native层，native层ollvm编译6.异常上报sdk异常上报sdk一般记录运行时所有的异常情况，并且会记录设备指纹，通过这些也能检测到作弊的一些设备。\n7.私有网络协议、protobuf等协议、私有网络证书、反代理抓包目前比较流行protobuf协议替代json，还有一些私有TCP&#x2F;Socket协议，这些协议不可直接读，需要一个解析工具或者分析还原。私有网络证书需要证书密钥配合代理抓包工具才能抓包分析，这种其实难度在于找到证书密钥和判断是否用了私有证书，一般聊天APP的IM协议常用。还有反代理抓包，比如集成OkHttp框架等的时候用Proxy.NO_Proxy来防止抓包。\n反反作弊方法及思路1.搜集设备指纹如数美易盾或者一些大的app都会内嵌搜集设备指纹的模块，通过设备指纹来确定设备的唯一性，如imei、android_id、mac、其他设备信息结合起来就能变成一个唯一的标志。\n2.搜集IP、MAC地址、蓝牙MAC、WIFI等网络指纹大量的搜集后跟其他搜集的信息结合并且不断地完善代理ip和黑ip、mac库，就能不断地能识别作弊源头。\n3.地理位置、下载渠道、授权登录地理位置和ip是否对应、基站信息是否对应、或者设备型号跟下载渠道对应、一般小米手机的软件大部分应该小米商城下载的，比如微信授权登录，QQ授权登录等、如果模拟授权登录需要破解其他给权的APP的一些协议。\n反反作弊工具和策略1.逆向工具\njava：dex2jar,jadx,jeb,android-killer等等很多\nso文件：IDA,jeb,Gidra\njs：其实nodejs加谷歌或者火狐就能搞定\n其他：unicorn,unidibug等基于qemu虚拟机的工具\n\n2.抓包工具\nCharles、Fillder：这两个其实差不多，用于http、websocket等应用层抓包\nWireShark：各种协议都能支持，需要更深入的网络协议技术基础\nBurpSuite：可以开发一些插件，会开发就各种神操作把。\n\n3.hook框架\nxposed：用户比较多，尤其云控、群控、那些化妆品，教育类、保险等销售类的都在用，市场规模大。\nfrida：一般开发者使用的多，快，无需重启，会js就会玩吧。\ncydia：hook Native层的时候多一点，老开发者用的多。\ninlinehook，xhook：这两个类似，inlinehook多用于hook b跳转的，xhook多用于系统函数。\nmagisk:安卓8以上xposed或者其他一些证书安装等工具都基于这个，这个其实未来深入研究的东西。4.模拟点击\nuiautomator ：很多模拟点击软件基于这个，跟xposed结合开发比较合适，理解安卓开发的入门比较简单。\n\n5.行业难度\nollvm混淆：逆向行业目前应该最头疼的就这个吧，主要原理时if-else改成while(true){switch() case:}了，但是逆向成本变高了，并且各种延申的东西越来越多，需要经验和技术积累才能100%还原或破解。\n\n机器学习风控策略：这个没有多年经验或者没有相当长的时间去摸索或者没跟班一个APP的成长的话很难对应，并且大部分都是通过养号，养设备等方式去对应，还有的是破解协议，并且伪造大量的设备信息，通过IP代理池，卡商和打码平台等第三方服务来维持。不过随着法律的完善和APP自身的风控体系健全对应成本越来越高，现在很难实现大批量账号登录注册。检测是否roothttps://github.com/sensepost/objection/blob/e7eb1d9b769edf6a98870c75a6d2a6123b7346fd/agent/src/android/root.ts通过命令行输入su看是否有返回\n","tags":["frida"]},{"title":"Base64编码与解码源码分析","url":"/posts/51977/","content":"介绍Base64是一种基于64个可打印字符来表示二进制数据的表示方法，是一种编码方式，提及编码方式，必然有其对应的字符集合。在Base64编码中，相互映射的两个集合是：\n\n二进制数据{0, 1}\n\n{A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, +, &#x2F;}\n\n\nBase64编码方式可使得信息在这两种字符集表示法之间相互等价转换。\n\n\nBase64编码过程由于base64的字符集大小为64，那么，需要6个比特的二进制数作为一个基本单元表示一个base64字符集中的字符。因为6个比特有2^6&#x3D;64种排列组合。\n具体来说，编码过程如下：\n\n将每三个字节作为一组，共24bit，若不足24bit在其后补充0；\n将这24个bit分为4组，每一组6个bit；\n在每组前加00扩展为8个bit，形成4个字节，每个字节表示base64字符集索引；\n扩展后的8bit表示的整数作为索引，对应base64字符集的一个字符，这就是base64编码值；在处理最后的不足3字节时，缺一个字节索引字节取3个，最后填充一个&#x3D;，；缺两个字节取2个索引字节，最后填充&#x3D;&#x3D;。\n\n解码时将过程逆向即可。\nBase64索引表：\n\n\n\nASCII码表\n\n\n\n\n\n\n编码示例示例一Man的base64编码\n\n\n第一步，’M’, ‘a’, ‘n’的ASCII值分别为77, 97, 110，对应的二进制值分别为：01001101, 01100001, 01101110；取三个字节共24bit：010011010110000101101110\n第二步，将这24bit分为4组，每组6个bit：010011, 010110, 000101, 101110\n每组前面加00，形成4个字节的，00010011, 00010110, 00000101, 00101110, 即19, 22, 5, 46\n根据索引表，对应的base64字符分别是T, W, F, u最后的base64字符串是: TWFu。\n\n解码时将过程逆向即可。\n\n\n示例二剩余两个字节，BC的base64编码 \n\n\n第一步，’B’, ‘C’的ASCII值分别为66, 64, 对应二进制值分别为：01000010, 01000011；取三个字节，不足不0，共24bit：01000010, 01000011, 00000000\n第二步，将这24bit分为4组，每组6个bit：010000, 100100, 001100, 000000\n每组前面加00，形成4个字节的，00010000, 00100100, 00001100, 00000000，即16, 36, 12, 0\n由于’B’, ‘C’只有两个字节，缺一个字节，因此取3个索引；根据索引表，对应的base64字符分别是Q, k, M，最后填充一个&#x3D;\n\n最后的base64字符串是：QkM&#x3D;\n\n\n示例三剩余一个字节，A的base64编码 \n\n\n第一步，’A’的ASCII值65, 对应二进制值为：01000001; 取三个字节，不足不0，共24bit：01000001, 00000000, 00000000\n第二步，将这24bit分为4组，每组6个bit：010000, 010000, 000000, 000000\n每组前面加00，形成4个字节的，00010000, 00010000, 00000000, 00000000，即16, 16, 0, 0\n由于’A’只有一个字节，缺两个字节，因此取2个索引；根据索引表，对应的base64字符分别是Q, Q，最后填充&#x3D;&#x3D;\n\n 最后的base64字符串是：QQ&#x3D;&#x3D;\n\n\nPython实现base64编码方式一：&quot;&quot;&quot;base64实现encode: 先编码，十进制化(汉字在utf-8编码下占三个字节，在gbk编码下占两个字节)，再转二进制进行+0填充后合并，不足6的倍数继续填充，切片，十进制化查表，拼接,不足4的倍数填充=&quot;&quot;&quot;def fillIt(string, factor, item):    &quot;&quot;&quot;    指定倍数填充指定字符    string：原字符串    factor：倍数    item：填充字符    &quot;&quot;&quot;    length = len(string)    remainder = length % factor    if remainder:        times = factor - remainder        string = string + times * item    return stringdef splitIt(string, bits):    &quot;&quot;&quot;    指定位数切片    string：原字符串    bits：每次切片数量    &quot;&quot;&quot;    length = len(string)    new_list = []    for i in range(bits, length + 1, bits):        new_list.append(string[i - bits:i])        remain = length % bits        if remain != 0:            new_list.append(string[-remain:])    return new_listdef encode(string):    string_temp = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;    # 索引编码表    base64_dict = &#123;&#125;    for i in range(2 ** 6):        base64_dict[i] = string_temp[i]        # 编码    string_encode_byte = string.encode(&#x27;utf-8&#x27;)    # 十进制化    string_digit_list = list(string_encode_byte)    # 二进制化 + 0填充到8位    string_bin_list = []    for item in string_digit_list:        string_bin_list.append(str(bin(item))[2:].zfill(8))        # 字符串合并    string_sum = &#x27;&#x27;.join(string_bin_list)    # 6 的倍数，不足 0 填充    string_fill = fillIt(string_sum, factor=6, item=&#x27;0&#x27;)    # 切片，6位一个单位    string_bin_list2 = splitIt(string_fill, bits=6)    # 十进制化    string_digit_list2 = []    for item in string_bin_list2:        string_digit_list2.append(int(item, 2))        # 查表    string_base64_list = []    for item in string_digit_list2:        string_base64_list.append(base64_dict[item])        # 拼接    string_sum2 = &#x27;&#x27;.join(string_base64_list)    # 4 的倍数，不足填充 =    string_convert = fillIt(string_sum2, factor=4, item=&#x27;=&#x27;)    return string_convertif __name__ == &#x27;__main__&#x27;:    print(encode(&quot;123啊a&quot;))\n\n\n\nbase64编码方式二：base64_charset = &#x27;ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/&#x27;def encode(string):    &quot;&quot;&quot;    将bytes类型编码为base64    :param string:需要编码的字符串    :return:base64字符串    &quot;&quot;&quot;    # 对字符串转字节    origin_bytes = string.encode()    # 将每一位bytes转换为二进制字符串, &#x27;&#123;:0&gt;8&#125;&#x27;.format(str) 填充到8位    base64_bytes = [&#x27;&#123;:0&gt;8&#125;&#x27;.format(str(bin(b)).replace(&#x27;0b&#x27;, &#x27;&#x27;)) for b in origin_bytes]    resp = &#x27;&#x27;    nums = len(base64_bytes) // 3    remain = len(base64_bytes) % 3  # 余数    integral_part = base64_bytes[0:3 * nums]  # 取3的倍数分组    while integral_part:        # 取三个字节，以每6比特，转换为4个整数（直接转换位十进制，不填充到8位在转十进制）, 对码表进行查找        tmp_unit = &#x27;&#x27;.join(integral_part[0:3])        tmp_unit = [int(tmp_unit[x: x + 6], 2) for x in [0, 6, 12, 18]]        # 取对应base64字符        resp += &#x27;&#x27;.join([base64_charset[i] for i in tmp_unit])        integral_part = integral_part[3:]    if remain:        # 补齐三个字节，每个字节补充 0000 0000        remain_part = &#x27;&#x27;.join(base64_bytes[3 * nums:]) + (3 - remain) * &#x27;0&#x27; * 8        # 取三个字节，以每6比特，转换为4个整数        # 剩余1字节可构造2个base64字符，补充==；剩余2字节可构造3个base64字符，补充=        tmp_unit = [int(remain_part[x: x + 6], 2) for x in [0, 6, 12, 18]][:remain + 1]        resp += &#x27;&#x27;.join([base64_charset[i] for i in tmp_unit]) + (3 - remain) * &#x27;=&#x27;    return respif __name__ == &#x27;__main__&#x27;:    s = &quot;123啊a&quot;print(encode(s))\n\n\n\nbase64解码方式三：def decode(base64_str):    &quot;&quot;&quot;    解码base64字符串    :param base64_str:base64字符串    :return:解码后的bytearray；若入参不是合法base64字符串，返回空bytearray    &quot;&quot;&quot;    # 判断是否符合base64的格式    if len(base64_str) % 4:        return        # 去除末尾=    while True:        if base64_str[len(base64_str)-1:] == &quot;=&quot;:            base64_str = base64_str[:len(base64_str)-1]            continue        break        # 遍历判断字符串元素是否在编码表里    for m in base64_str:        if m not in base64_str:            return            # 对每一个base64字符取下标索引，并转换为6为二进制字符串    base64_bytes = [&#x27;&#123;:0&gt;6&#125;&#x27;.format(str(bin(base64_charset.index(s))).replace(&#x27;0b&#x27;, &#x27;&#x27;)) for s in base64_str if s != &#x27;=&#x27;]    resp = bytearray()    nums = len(base64_bytes) // 4    remain = len(base64_bytes) % 4    # 截取4的整数倍    integral_part = base64_bytes[0:4 * nums]    while integral_part:        # 取4个6位base64字符，作为3个字节        tmp_unit = &#x27;&#x27;.join(integral_part[0:4])        tmp_unit = [int(tmp_unit[x: x+8], 2) for x in [0, 8, 16]]        for i in tmp_unit:            resp.append(i)        integral_part = integral_part[4:]        # 取剩余的    if remain:        remain_part = &#x27;&#x27;.join(base64_bytes[nums*4:])        tmp_unit = [int(remain_part[i*8:(i+1)*8], 2) for i in range(remain-1)]        for i in tmp_unit:            resp.append(i)    return resp.decode()\n\n\n\nc++实现//// Created by zsk on 2022/9/13.//#include &lt;iostream&gt;#include &lt;cstring&gt;class Base64 &#123;public://base64 加密static void encode(const char *data, char *out) &#123;    char Base64Code[] = &#123;    &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;, &#x27;G&#x27;, &#x27;H&#x27;, &#x27;I&#x27;, &#x27;J&#x27;, &#x27;K&#x27;, &#x27;L&#x27;, &#x27;M&#x27;, &#x27;N&#x27;, &#x27;O&#x27;, &#x27;P&#x27;,    &#x27;Q&#x27;, &#x27;R&#x27;, &#x27;S&#x27;, &#x27;T&#x27;, &#x27;U&#x27;, &#x27;V&#x27;, &#x27;W&#x27;, &#x27;X&#x27;, &#x27;Y&#x27;, &#x27;Z&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;,    &#x27;g&#x27;, &#x27;h&#x27;, &#x27;i&#x27;, &#x27;j&#x27;, &#x27;k&#x27;, &#x27;l&#x27;, &#x27;m&#x27;, &#x27;n&#x27;, &#x27;o&#x27;, &#x27;p&#x27;, &#x27;q&#x27;, &#x27;r&#x27;, &#x27;s&#x27;, &#x27;t&#x27;, &#x27;u&#x27;, &#x27;v&#x27;,    &#x27;w&#x27;, &#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;, &#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;+&#x27;, &#x27;/&#x27;,&#125;;    // 计算长度    int data_len = strlen(data);    if (data_len == 0) &#123;        out[0] = &#x27;\\0&#x27;;        return;    &#125;    int i;    //主编码循环, &amp; 同为 1 的位，结果为 1，否则结果为 0。 | 只要有1个是1的位，结果为1，否则为0    for (i = 0; i &lt; data_len / 3; ++i) &#123;        out[i * 4] = Base64Code[data[i * 3] &gt;&gt; 2];        out[i * 4 + 1] = Base64Code[((data[i * 3] &amp; 0x03) &lt;&lt; 4) | (data[i * 3 + 1] &gt;&gt; 4)];        out[i * 4 + 2] = Base64Code[((data[i * 3 + 1] &amp; 0x0F) &lt;&lt; 2) | (data[i * 3 + 2]) &gt;&gt; 6];        out[i * 4 + 3] = Base64Code[data[i * 3 + 2] &amp; 0x3F];    &#125;    //长度不为3的倍数    if (data_len % 3 == 1) &#123;        out[i * 4] = Base64Code[data[i * 3] &gt;&gt; 2];        out[i * 4 + 1] = Base64Code[((data[i * 3] &amp; 0x03) &lt;&lt; 4)];        out[i * 4 + 2] = &#x27;=&#x27;;        out[i * 4 + 3] = &#x27;=&#x27;;    &#125;    if (data_len % 3 == 2) &#123;        out[i * 4] = Base64Code[data[i * 3] &gt;&gt; 2];        out[i * 4 + 1] = Base64Code[((data[i * 3] &amp; 0x03) &lt;&lt; 4) | (data[i * 3 + 1] &gt;&gt; 4)];        out[i * 4 + 2] = Base64Code[((data[i * 3 + 1] &amp; 0x0F) &lt;&lt; 2)];        out[i * 4 + 3] = &#x27;=&#x27;;    &#125;&#125;//base64 解密static void decode(const char *data, char *out) &#123;    static char _ucode[] = &#123;    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 62, 0, 0, 0, 63,    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 0, 0, 0, 64, 0, 0,    0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14,    15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 0, 0, 0, 0, 0,    0, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,    41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 0, 0, 0, 0, 0,&#125;;    int i;    int len = strlen(data);    ptrdiff_t len2 = len / 4 * 3;    //判断末位是否有等号、有几个等号    if (&#x27;=&#x27; == data[len - 2])        len2 -= 2;    else if (&#x27;=&#x27; == data[len - 1])        len2--;    else if (len % 4)        len2 += (len % 4 - 1);    //主解密循环    for (i = 0; i &lt; len2 / 3; ++i) &#123;        out[i * 3] = (_ucode[data[i * 4]] &lt;&lt; 2) | (_ucode[data[i * 4 + 1]] &gt;&gt; 4);        out[i * 3 + 1] = ((_ucode[data[i * 4 + 1]] &amp; 0x0F) &lt;&lt; 4) | (_ucode[data[i * 4 + 2]] &gt;&gt; 2);        out[i * 3 + 2] = ((_ucode[data[i * 4 + 2]] &amp; 0x03) &lt;&lt; 6) | (_ucode[data[i * 4 + 3]]);            &#125;            //末位为一个或两个等号的情况，这时候不能通过主解密循环进行解密            if (len2 % 3 == 1) &#123;            out[i * 3] = (_ucode[data[i * 4]] &lt;&lt; 2) | (_ucode[data[i * 4 + 1]] &gt;&gt; 4);            &#125;            if (len2 % 3 == 2) &#123;            out[i * 3] = (_ucode[data[i * 4]] &lt;&lt; 2) | (_ucode[data[i * 4 + 1]] &gt;&gt; 4);            out[i * 3 + 1] = ((_ucode[data[i * 4 + 1]] &amp; 0x0F) &lt;&lt; 4) | (_ucode[data[i * 4 + 2]] &gt;&gt; 2);            &#125;            &#125;            &#125;;            int main() &#123;            const char *text = &quot;12345&quot;;            char out[100] = &#123;0&#125;;            char out2[100] = &#123;0&#125;;            Base64::encode(text, out);            printf(&quot;encode==&gt;%s\\n&quot;, out);            Base64::decode(out, out2);            printf(&quot;decode==&gt;%s&quot;, out2);            &#125;\n\n\n\n中文的base64编码\n\n其实base64编码只是在二进制与base64字符集之间映射的编码，与其他字符集毫无关系。其他字符集想要转换为base64编码，只需先将其转换为二进制，再做base64编码即可。\n\n\n那么对于Unicode字符集而言，有多种编码方式将其装换为二进制，所以在编码过程中就需要统一编码，以免造成乱码。上述Python示例就将中文转换为base64，首先使用默认编码utf-8将字符串转换为二进制（使用Python的str.encode()），再做base64编码；解码时候同样如此，先将base64字符串解码为二进制，再将二进制转换为字符串（使用Python的str.decode()）\n","tags":["算法"]},{"title":"MD5源码分析及流程","url":"/posts/14604/","content":"MD5算法实现：输入：不定长度信息（要加密的信息）\n输出：固定长度128-bits。由四个32位分组组成，将这四个32位分组级联后将生成一个128位散列值。\n基本方式为：求余、取余、调整长度、与链接变量进行循环运算。得出结果。\n\n\n\n填充在MD5算法中，首先需要对输入信息进行填充，使其位长对512求余的结果等于448，并且填充必须进行，即使其位长对512求余的结果等于448。因此，信息的位长（Bits Length）将被扩展至N*512+448，N为一个非负整数，N可以是零。\n填充的方法如下：\n\n在信息的后面填充一个1和无数个0，直到满足上面的条件时才停止用0对信息的填充。\n在这个结果后面附加一个以64位二进制表示的填充前信息长度（明文的长度，单位为Bit），如果二进制表示的填充前信息长度超过64位，则取低64位\n\n经过这两步的处理，信息的位长&#x3D;N512+448+64&#x3D;(N+1）512，即长度恰好是512的整数倍。这样做的原因是为满足后面处理中对信息长度的要求。\n\n\n初始化变量（变量值一般不变）初始的128位值为初试链接变量，这些参数用于第一轮的运算，以大端字节序来表示，他们分别为： \nA&#x3D;0x01234567，\nB&#x3D;0x89ABCDEF，\nC&#x3D;0xFEDCBA98，\nD&#x3D;0x76543210。\n（每一个变量给出的数值是高字节存于内存低地址，低字节存于内存高地址，即大端字节序。在程序中变量A、B、C、D的值分别为0x67452301，0xEFCDAB89，0x98BADCFE，0x10325476）\n\n\n处理分组数据\n\n消息分以512位为一分组进行处理，每一个分组进行上述4轮共64次计算后，将A，B，C，D分别加上计算得到的a，b，c，d。当做新的A，B，C，D，并将这4个变量赋值给a,b,c,d再进行下一分组的运算。由于填充后的消息长度为(N+1)*512，则共需计算N+1个分组。计算所有数据分组后，这4个变量为最后的结果，即MD5值。\n\n\n每一分组的算法流程如下：\n（1）第一分组需要将上面四个链接变量复制到另外四个变量中：A到a，B到b，C到c，D到d。\n（2）从第二分组开始的变量为上一分组的运算结果，即A &#x3D; a， B &#x3D; b， C &#x3D; c， D &#x3D; d。\n主循环有四轮（MD4只有三轮），每轮循环都很相似。第一轮进行16次操作。每次操作对a、b、c和d中的其中三个作一次非线性函数运算，然后将所得结果加上第四个变量，文本的一个子分组和一个常数。再将所得结果向左环移一个不定的数，并加上a、b、c或d中之一。最后用该结果取代a、b、c或d中之一。\n\n\n一个MD5运算由类似的64次循环构成，分成4组16次。\nF ：一个非线性函数，一个函数运算一次\nMi ：表示一个 32-bits 的输入数据\nKi：表示一个 32-bits 常数，用来完成每次不同的计算。\n\n说明：\n\n\n( (a + 线性函数(b,c,d) + Mj + Ki) &lt;&lt; s) + a &#x3D;&#x3D; B\n\n\n以下是每次操作中用到的四个非线性函数（每轮一个）。\nF( X ,Y ,Z ) &#x3D; ( X &amp; Y ) | ( (~X) &amp; Z )  &#x3D;&#x3D;&gt; If X then Y else Z\nG( X ,Y ,Z ) &#x3D; ( X &amp; Z ) | ( Y &amp; (~Z) )  &#x3D;&#x3D;&gt; If Z then X else Y\nH( X ,Y ,Z ) &#x3D;X ^ Y ^ Z  &#x3D;&#x3D;&gt; If X&#x3D;Y then Z else ~Z\nI( X ,Y ,Z ) &#x3D;Y ^ ( X | (~Z) )\n（&amp;是与（And），|是或（Or），~是非（Not），^是异或（Xor））\n\n\n\n\n\n\n\n\n\n&amp;\n与\n两个位都为1时，结果才为1\n\n\n|\n或\n两个位都为0时，结果才为0\n\n\n^\n异或\n两个位相同为0，相异为1\n\n\n~\n取反\n0变1，1变0\n\n\n&lt;&lt;&lt;\n循环左移\n将移出的低位放到该数的高位\n\n\n循环左移:\n\n这四个函数的说明：如果X、Y和Z的对应位是独立和均匀的，那么结果的每一位也应是独立和均匀的。F是一个逐位运算的函数。即，如果X，那么Y，否则Z。函数H是逐位奇偶操作符。假设Mj表示消息的第j个子分组（从0到15），常数ti是4294967296*abs( sin(i) ）的整数部分，i 取值从1到64，单位是弧度。（4294967296&#x3D;2^(32)）\n\n现定义：\nFF(a ,b ,c ,d ,Mj ,s ,ti ) 操作为 a = b + ( (a + F(b,c,d) + Mj + ti) < s)","tags":["算法"]},{"title":"Arm汇编","url":"/posts/22788/","content":"以下ARM笔记我基于 _周壑 大佬在b站的视频教程整理来的，推荐配合视频使用\n环境搭建arm文档下载链接：https://documentation-service.arm.com/static/644a406baa78c007af74e6fd?token=其中指令集在目录 F5.1 Alphabetical list of T32 and A32 base instruction set instructions。在android studio中创建设备，选择api17的，armeabi-v7a架构。创建后的设备默认路径在 C:\\Users\\zsk.android\\avd，snapshots保存的是快照快捷方式启动设备：    创建bat文件，输入D:\\Android\\Sdk\\emulator\\emulator.exe -avd Pixel_XL_API_17_2，运行启动设备将ida的android-server push到设备上，android-server文件在ida目录下的dbgsrvpush后修改文件权限为777，运行，端口转发：adb forward tcp:23946 tcp:23946运行后就可以在ida选择设备调试，Debugger -&gt; Attach -&gt; Remote ARMLinux&#x2F;Android debuggerhostname填localhost，没有进行端口转发则需要填手机ip，能看到进程列表则成功\nc文件编译成arm运行在window下把c文件编译为arm的前置准备hello.c\n#include &lt;stdio.h&gt;int main()&#123;\tprintf(&quot;hello\\n&quot;);    return 0;&#125;\n在同级目录下新建Application.mk，Android.mk文件https://developer.android.google.cn/ndk/guides/android_mk?hl&#x3D;zh-cnApplication.mk\nAPP_ABI := armeabi-v7aAPP_BUILD_SCRIPT := Android.mkAPP_PLATFORM := android-16\nAndroid.mk\nLOCAL_PATH := $(call my-dir)#include $(CLEAR_VARS)LOCAL_ARM_MODE := armLOCAL_MODULE := &quot;hello&quot;LOCAL_SRC_FILES := hello.cinclude $(BUILD_EXECUTABLE)\n编译，可以弄成bat方便执行\nndk-build NDK_PROJECT_PATH=. NDK_APPLICATION_MK=Application.mk\n需要在Android studio中下载ndk工具，下载好后会在sdk下有ndk文件，进入选择随便一个版本路径配置环境变量运行显示过程[armeabi-v7a] Compile thumb  : hello &lt;&#x3D; hello.c[armeabi-v7a] Executable     : hello[armeabi-v7a] Install        : hello &#x3D;&gt; libs&#x2F;armeabi-v7a&#x2F;hello结束后会在目录生成obj和libs文件，在libs下是hello可执行文件，obj下是debugger版的可执行文件，调试的话就用obj下的。将文件push到手机，修改777权限，执行运行\nroot@android:/data/local/tmp # chmod 777 helloroot@android:/data/local/tmp # ./hellohello\n这样一下子就运行玩完了，没法调试，修改代码让它一直运行\n#include &lt;stdio.h&gt;int main()&#123;    while(1)&#123;        printf(&quot;hello\\n&quot;);        getchar();    &#125;    return 0;&#125;\n重新编译并推送执行\nida调试回到ida，调试运行中的hello程序避免每次都要执行多行命令，可以整合成一个bat\nadb push D:\\Android\\arm_test\\obj\\local\\armeabi-v7a\\hello /data/local/tmp/adb shell &quot;chmod 777 /data/local/tmp/hello&quot;adb shell &quot;/data/local/tmp/hello&quot;\n\n寄存器和指令基本格式没有隐式内存操作指令，一条ARM汇编指令可以包含0到3个操作数。操作数是指执行指令时所涉及的数据或寄存器。内存操作数和里脊操作数不能同时存在，意味着在一条指令中，不能同时存在既是内存操作数又是寄存器操作数。你要么使用内存地址作为操作数，要么使用寄存器。内存操作数至多出现一次，寄存器操作数总在最前面\n\n特殊情况：\n\n读PC寄存器，arm读PC加8，thumb读PC加4\nC标志位使用\n\n\n寄存器： \n\n寄存器是计算机中一种高速的、临时的、可用于存储和操作数据的存储单元。在ARM架构中，通常使用 R0、R1、R2 等寄存器来表示通用寄存器。这些寄存器可以用来存储临时数据、地址或执行算术和逻辑运算。\n\n\n立即数： \n\n立即数是在指令中直接提供的常数值，而不是从内存中加载。在汇编语言中，可以使用 # 符号表示立即数。例如，在 MOV R0, #10 中，#10 就是一个立即数，表示将值 10 直接存储到寄存器 R0 中。\n\n\n操作数： \n\n操作数是参与运算的数据或者指令中的一个参数。在指令中，你可能会看到源操作数和目标操作数。在 MOV R0, #10 中，#10 是源操作数，表示移动的数据；而 R0 是目标操作数，表示数据要移动到的位置。\n\n\nMOV：\n\n用于将一个数值（立即数或寄存器中的值）移动到目标寄存器。    MOV R0, #10       ; 将立即数 10 移动到寄存器     R0 MOV R1, R2        ; 将寄存器 R2 中的值移动到寄存器 R1\n\n\n基本运算：\n\nADD：加法指令。\nADR：将地址加载到寄存器的伪指令。\nSUB：减法指令。\nRSB：反向减法指令。\nAND：按位与运算指令。\nBIC：按位与非运算指令。\nORR：按位或运算指令。\nEOR：按位异或运算指令。\nLSL：逻辑左移指令。\nLSR：逻辑右移指令。\nASR：算术右移指令。\n\n\n访存：\n\nLDR：从内存中加载数据到寄存器。\nSTR：将寄存器中的数据存储到内存。\n\n\n块访存：\n\nLDMFD：从内存中加载多个寄存器，然后递减栈指针。\nLDMIA：从内存中加载多个寄存器，然后递增基址寄存器。\nSTMFD：将多个寄存器的值存储到内存，然后递减栈指针。\nSTMIA：将多个寄存器的值存储到内存，然后递增基址寄存器。\n\n\n分支：\n\nB：无条件分支。\nBL：带链接的无条件分支，用于函数调用。\nBX：无条件分支并切换指令集（ARM&#x2F;Thumb）。\nBLX：带链接的无条件分支并切换指令集。\n\n\n\n在ida中按ctrl+alt+k可以修改指令\n条件和标志位响应条件指令条件指令是加在运算符后面的，如何看懂？例如机器码为：03 00 10 E3\tTST小端序排序的，前高4位是条件，看最高位也就是E，E的对应的bit为1110，也就是None，无条件，可以说E是出现最多的06 00 00 0A\tBEQ最高位0，0就是EQ，03 00 52 21\tCMPCS最高位为2，2就是0010，CS指令后缀带S的，表示执行完标志位会改变01 00 80 E0\tADD\tR0, R0, R101 00 90 E0\tADDS\tR0, R0, R101 00 40 E0\tSUB\t\tR0, R0, R101 00 50 E0\tSUBS\tR0, R0, R1S是由第20个bit控制，也就是上面的8，9\nS位为0就是不带S，为就是S大部分算术指令都可以加S，CMP不行，CMP的20位固定为1\n\n运算指令可以分为以下三种：\n第一种既要结果又要标志寄存器，subs，adds\n第二种只要结果，sub，add\n第三种只要标志寄存器，cmp，cmn\n\n\n\nMOV指令立即数Move（immediate）将立即数值写入目标寄存器。mov是不访问内存，没有写内存的功能。那就只有寄存器操作数或者立即操作数mov是把第二个操作数（可能是寄存器也可能是立即数）写到第一个操作数，那第一个操作数只能是寄存器操作数arm指令是定长32位的，也就是立即数长度肯定不会超过32位这里立即数的位数是imm4+imm12，也就是16位例如：34 82 01 E3                   MOVW            R8, #0x1234如果是超过16位，则写不进。第15-12位4位二进制的长度刚好16对应着r0-r15还有一种A1格式，立即数是可以超过16-32位的02 81 A0 E3                   MOV             R8, #0x80000000虽然这里长度比16位大，但是它的有效位只有最高位的8，这里是把2向右移动1*2位， 0010 -&gt;右移2位-&gt; 1000 -&gt; 8(十进制)01 81 A0 E3                   MOV             R8, #0x40000000把1向右移动1*2位，0001 -&gt;右移2位-&gt; 0100 -&gt; 4(十进制)02 82 A0 E3                   MOV             R8, #0x20000000把2向右移动4位，0010 -&gt;右移4位-&gt; 0010 -&gt; 2(十进制)立即数的有效位数比较密集，可以集中在8位范围内还是偶数如果真要写入32位有效数如何做？先写一条指令 mov r0, 0x5678 再写 movt r0, 0x1234 写到高16位，ida会两句合成一句伪指令78 06 05 E3 34 02 41 E3       MOV             R0, #0x12345678\n寄存器Move（register）将值从寄存器复制到目标寄存器。\n上面说的是立即数到寄存器，这个是寄存器到寄存器\n除了： 01 00 A0 E1                   MOV             R0, R1还能： 01 02 A0 E1                   MOV             R0, R1,LSL#4 （R0是一个操作数，R1,LSL#4整体是一个操作数）R1向左移动4位写到r0里看第7-11位，5位的长度也就是2的32次方来表示偏移第5-6位，stype2位的长度有4种情况，逻辑左移，逻辑右移，算术右移 ，循环移位（算术左移的逻辑和逻辑左移是一样的，循环移位不区分左右移，比如循环左移1位和循环右移32位是一样的）此指令由别名 ASRS (immediate), ASR (immediate), LSLS (immediate), LSL (immediate), LSRS (immediate), LSR (immediate), RORS (immediate), ROR (immediate), RRXS, and RRX使用. 指令lsl r0, r1,4 的效果跟 R0, R1,LSL#4 是一样的所以 ASRS, ASR, LSLS, LSL, LSRS, LSR, RORS, ROR, RRXS, RRX 实际上都可以认为是mov指令的一个宏，另一种写法，在ida中都会翻译成mov指令常用的也就是逻辑左移，逻辑右移，算术右移，都是一些数组，结构体偏移寻址的\n寄存器移位寄存器Move（寄存器移位寄存器）将寄存器移位后的寄存器值复制到目标寄存器。\n例如：11 02 A0 E1                   MOV             R0, R1,LSL R2\n基本整型运算指令基本都是3个操作数，第一个是写入，第二三个是做运算。（寄存器，寄存器，立即数）  或者是 （寄存器，寄存器，寄存器）。下面指令都有多种格式，立即数，寄存器，移位寄存器等等。只列举立即数的情况\nADD, ADDS (immediate)加法指令。\n立即数长度12，分为有效数字低8位，高4位做位移循环。这种叫A32ExpandImm，把imm12扩展成32位\nADD, ADDS (register)\nADR将地址加载到寄存器的伪指令。从PC相对地址将立即值添加到PC值以形成PC相对地址，并写入结果发送到目标寄存器。该指令由伪指令ADD（立即，到PC）和SUB（立即，从PC）使用。这个伪指令从来都不是首选的反汇编。例如指令 add, r0, pc, 4（把pc+4赋给r0）会在ida变成04 00 8F E2                   ADR             R0, loc_16FD4从pc+4会涉及到读pc，读pc  要+8，加上4就是1200016FD0 04 00 8F E2                   ADR             R0, loc_16FDC00016FDC                               loc_16FDC\nSUB减法指令。从PC中减去从对齐（PC，4）值减去立即值以形成一个PC相关地址，并将结果写入目标寄存器。02 00 41 E0                   SUB             R0, R1, R2（r0&#x3D;r1-r2）\nRSB反向减法指令。反向减法指令，反向减法（立即数）从立即数中减去寄存器值，并将结果写入目的地寄存器。08 00 61 E2                   RSB             R0, R1, #8（8-r1的值写入r0）08 00 61 E2                   RSB             R0, R1, R2（r2-r1的值写入r0）\nAND按位与运算指令。按位与(立即数)对寄存器值和立即数执行位与，并将结果写入到目标寄存器。02 00 01 E0                   AND             R0, R1, R2（r0 &#x3D; r1 &amp; r2）\nBIC按位与非运算指令。逐位清除（立即数）对寄存器值和立即数的补码执行逐位“与”运算，并将结果写入目标寄存器。相当于第二个操作数和第三个操作数取反之后取and02 00 C1 E1                   BIC             R0, R1, R2（r0 &#x3D; r1 &amp; ~r2）\nORR按位或运算指令。逐位OR（立即数）执行寄存器值和立即数的逐位（包括）OR，并将结果写入目标寄存器。02 00 81 E1                   ORR             R0, R1, R2 （r0 &#x3D; r1 | r2）\nEOR按位异或运算指令。逐位异或（立即数）对寄存器值和立即数执行逐位异运算，并将结果写入目标寄存器。02 00 21 E0                   EOR             R0, R1, R2（r0 &#x3D; r1 ^ r2）\nLSL逻辑左移指令。逻辑左移（立即数）将寄存器值左移立即数位，移位为零，并将结果写入目标寄存器。lsl r0, r1, r2 11 02 A0 E1                   MOV             R0, R1,LSL R2（r0 &#x3D; r1 &lt;&lt; r2）\nLSR逻辑右移指令。逻辑右移（立即数）将寄存器值右移一个立即数位数，移位为零，并将结果写入目标寄存器。lsr r0, r1, r231 02 A0 E1                   MOV             R0, R1,LSR R2（r0 &#x3D; r1 &gt;&gt; r2）\nASR算术右移指令。算术右移(立即数)将寄存器值右移立即位数，将其符号位的副本移位，并将结果写入目标寄存器。asr r0, r1, r251 02 A0 E1                   MOV             R0, R1,ASR R2（r0 &#x3D; r1 &gt;&gt; r2）\nasr r0, r1, r2和lsr r0, r1, r2是一致的吗在一般情况下，asr r0, r1, r2 和 lsr r0, r1, r2 是不一致的。asr r0, r1, r2 执行算术右移，将 r1 的所有位向右算术移动 r2 位，并将结果存储到 r0 中。算术右移在移位过程中用符号位填充左侧空出的位，即最高位（符号位）保持不变。lsr r0, r1, r2 执行逻辑右移，将 r1 的所有位向右移动 r2 位，并将结果存储到 r0 中。逻辑右移在移位过程中用0填充左侧空出的位。因此，在 asr 中，符号位会影响右移时左侧空出位的填充值，而在 lsr 中，左侧空出位总是用0填充。如果 r1 是一个带符号整数，asr 和 lsr 通常会得到不同的结果。\n\n举例：\n当考虑一个假设的8位寄存器的情况，其中最高位（MSB）表示符号（0表示正数，1表示负数）时，我们可以通过一个例子来说明 asr 和 lsr 的区别。\n\n\n\n假设 r1 是二进制表示为 11011010，这是一个用二进制补码表示的负数。现在，让我们使用 asr 和 lsr 进行右移操作。\n; 假设 r1 是 11011010（二进制表示），是一个负数asr r0, r1, #1  ; 算术右移 1 位; 经过 asr，r0 将变为 11110110（二进制表示），仍然是一个负数lsr r0, r1, #1  ; 逻辑右移 1 位; 经过 lsr，r0 将变为 01110101（二进制表示），是一个正数\n\n在这个例子中，asr 在右移过程中保留了符号位，导致结果仍然是负数。而 lsr 在填充左侧空出位时使用了 0，导致结果变为正数。这展示了算术右移和逻辑右移在处理符号位上的差异。\n访存指令访存：LDR：从内存中加载数据到寄存器。STR：将寄存器中的数据存储到内存。\n1.数据流向2.操作的寄存器和内存地址3.后续附加行为 块访存指令的语法是 {寄存器列表}，其中寄存器列表中的寄存器按照从右到左的顺序依次被处理。这意味着在执行块访存指令时，先处理列表中的最右边的寄存器，然后依次向左处理。\nLDR加载寄存器（立即）从基本寄存器值和立即偏移中计算一个地址，从内存中加载单词，然后将其写入寄存器。 它可以使用偏移，索引或预先指定的地址。04 00 91 E5                   LDR             R0, [R1,#4]r1是一个基址寄存器，4是偏移量，表示从基址开始往后移动4个字节的位置。也可以使用负偏移04 00 11 E5                   LDR             R0, [R1,#-4]02 00 91 E7                   LDR             R0, [R1,R2]02 02 91 E7                   LDR             R0, [R1,R2,LSL#4]上面指令都是没有后续附加行为的04 00 B1 E5                   LDR             R0, [R1,#4]!  （加了!后除了把值写进r0，还会更新r1的地址，地址+4）上述的指令都可以算是内偏移，还有外偏移的04 00 91 E4                   LDR             R0, [R1],#4（从r1读出来的内存给r0后，后续行为把r1+4）\nSTR存储寄存器(立即寄存器)根据基址寄存器值和立即偏移量计算地址，并将寄存器中的值存储到内存。它可以使用偏移量、后索引或前索引寻址。0404 00 81 E4                  STR             R0, [R1],#4（将寄存器 R0 中的值存储到内存地址 R1 指向的位置，然后将 R1 的值递增 4（即地址加上 4））可以使用LDR，STR来操作sp栈指针寄存器，达到pop和push的效果当需要从sp取值到寄存器的时候，也就是pop，要用ldr，因为pop取值释放了空间，所以取值后sp栈指针要加4而向sp放入值的时候，也就是push，要用str，因为push要分配空间，所以放值后sp栈指针要减4。对于典型的栈操作，递减栈指针意味着在栈上分配一段新的空间，而递增栈指针则表示释放栈上的空间。在常见的体系结构中，栈是向低地址方向增长的，因此递减栈指针实际上是在向栈的底部分配空间。\n\npop：\n\nLDR             R0, [SP], #4    等同于下面两条    ldr r1, [sp]         &#x2F;&#x2F; 从栈中加载值到寄存器     r1 add sp, sp, #4       &#x2F;&#x2F; 栈指针递增4个字节\n\n\npush:\n\nSTR             R0, [SP, #-4]!\t等同于下面两条sub sp, sp, #4       &#x2F;&#x2F; 栈指针递减4个字节 str r0, [sp]         &#x2F;&#x2F; 将寄存器 r0 中的值存储到栈中\n\n\n\nldr的12位立即数是0扩展的，只支持12位，第23位U是表示正负的，第24位P是表示内外偏移的。str也是同理\n块访存指令块访存也是访存，读内存就是LDM开头，写内存STM开头，M表示多个数据或多个寄存器当我们在使用LDM或STM指令时，是想加载或存储寄存器值之前还是之后增加或减少基址寄存器的值，这影响了加载或存储完成后基址寄存器的最终值。LDM和STM指令可以跟随以下后缀：IA，IB，DA，DB。第一个操作数后续还能加 ! ：表示在加载或存储完成后更新寄存器。简单归纳就是IA：访问这块指针后，再向后加4。IB：还没访问这块指针，先向后加4，再访问。DA：反向读4字节，然后减4DB：先减4，然后再访问  !表示最后指针的地址是否更新常用只有LDMIA!，STMDB!，当第一个操作数为sp，等价于pop和push再ida中指令为 stmdb sp!,{r0-r3} 会自动替换为0F 00 2D E9                   PUSH            {R0-R3}或0F 00 2D E9                   STMFD           SP!, {R0-R3} 这两个是一样，在不同ida版本会显示不同当第一个操作数是sp!时，ida会翻译成STMFD。第二个操作数无论是写 {R2,R1,R4,R3} 也会翻译成 {R1-R4}，寄存器标号小的放在低地址，寄存器标号大的放在高地址。FD是用来操作栈的，当第一个操作数是sp时候，LDMFD等价于LDMIA，STMFD等价于STMDB。ida也会优先翻译为LDMFD，STMFD。当sp加了!后，则会优先翻译为POP和PUSH。\n\n例子：\nLDMIA SP, {R1-R4} &#x3D;&#x3D;&gt; LDMFD SP, {R1-R4}    STMDB SP, {R1-R4} &#x3D;&#x3D;&#x3D;&gt; STMFD SP, {R1-R4}    LDMIA SP!, {R1-R4} &#x3D;&#x3D;&gt; POP {R1-R4}    STMDB SP!, {R1-R4} &#x3D;&#x3D;&gt; PUSH {R1-R4}\n\n\n\n对于初学者先简单理解掌握下面三种STMFD &#x3D;&#x3D; PUSHLDMFD &#x3D;&#x3D; POP***IA: 快速复制内存，根据前缀看是读还是写\n分支和模式切换分支：B，BL，BX，BLX\n\n跳转目标2. 模式切换，thumb和arm的切换3. 写入LR的值\n\n后续是加立即数还是寄存器，分为以下几种情况：B\timmBL\timmBX\tregBLX\timmBLX\treg\nBB指令是无条件跳转，不带模式切换，T标志位不变。如果是从arm跳转thumb，或者thumb跳转到arm，需要保证跳转前后的模式统一。把指令机器码改为 00 00 00 EA，会发现要跳转的地址是当前地址+8，01 00 00 EA 则要跳转的地址是8+立即数4（当前立即数为1）。如果是thumb模式下，则是8+立即数2。当00 00 00 EA会加8，那么FE FF FF EA 则是8+(-2*4)，即一直跳转到自己当前地址，进入死循环。FE FF FF EA 需要记住，当一个进程很快执行结束的时候，又需要进行调试的时候。用ida找到文件_start的地方，elf文件加载到内存中，_start是程序的入口点。可以同010 Editor对这个入口位置的指令修改为 FE FF FF EA。push到设备重新运行就断住了，再把指令改回来，就可以调试。B指令的立即数可以寻址的范围是从当前指令的地址向前或向后移动的距离。由于立即数是相对偏移量，因此它可以覆盖的地址范围是从PC - 32MB到PC + 32MB。thumb模式下立即数只会更短\n\n例如：\n\n假设当前指令的地址是0x80000000（32位地址），并且B指令的立即数字段（imm24）的值为0x001234。将imm24与两个零（’00’）连接起来，得到一个32位的立即数：imm32 &#x3D; 0x00123400。\n如果imm24是一个正数（无符号值），那么imm32的最高有效位将为零，扩展后的结果仍然是正数。例如，如果imm24的值为0x001234，那么imm32 &#x3D; 0x00123400。\n如果imm24是一个负数（有符号值），那么imm32的最高有效位将为1，扩展后的结果仍然是负数。例如，如果imm24的值为0xFF1234，那么imm32 &#x3D; 0xFF123400。\n将PC的当前值（0x80000000）与imm32进行相加，即PC + imm32，就可以得到B指令跳转的目标地址。目标地址为0x80000000 + 0x00123400 &#x3D; 0x80123400，根据前面提到的寻址范围，PC - 32MB到PC + 32MB是从0x7F800000到0x80000000+0x02000000的范围。在这个例子中，PC的当前值为0x80000000，而且目标地址0x80123400是在这个范围之内，因此B指令是可以正确寻址和跳转的。\n\n\n\nBLBL指令后面加立即数，也是无条件跳转，但是会写入LR的值。执行完会把bl指令的下一条指令的地址写入到LR。如果是在thumb下，会把bl下一条指令的地址异或T位，也就是1，地址会变成奇数写入LR。当程序需要返回的时候通过LR的最低位来返回arm模式还是thumb模式，0就是arm，1就是thumb。\nBXBX指令后面加寄存器，BX会把寄存器的值拆成两部分，最低位会写入T标志位，用于指示跳转的目标指令集，剩余的部分写入pc寄存器，作为跳转的目标地址。通俗点就是如果地址是奇数，最低位就是1，偶数则是0。T标志位用于指示跳转目标的指令集，0表示ARM指令集，1表示Thumb指令集。\nBLX有两种情况，立即数和寄存器。BLX+立即数是一定会带有模式切换的，并会把执行完会把blx指令的下一条指令的地址写入到LR，把当前T标志位写入LR值的最低位后再更新T标志的值。BLX+寄存器跟BX+寄存器一样，会把执行完会把blx指令的下一条指令的地址写入到LR，是否模式切换以及T标志的值看寄存器地址的最低位。\n使用mov跳转跟BX reg做对比， mov pc, r0 指令将会直接将寄存器 R0 的值复制到程序计数器 PC，这意味着它是一个非条件的直接分支，不会进行任何模式切换，而且不会修改 T 标志位。\n使用ldr跳转直接从内存加载地址到pc， ldr pc, [r0]，把r0寄存器指向的值给pc，这种也会根据寄存器的值奇偶数来切换模式，并更新T标志位。有三种跳转指令 B系列指令，mov，ldr。其中mov最弱，不带有模式切换，一般也很少用。ldr指令调用一个导入表的方法\n判断导出表函数的模式怎么判断导出表的函数时arm模式还是thumb模式？再ida中查看libc的导出表函数时，address都是偶数，难道全都是arm模式吗？比如printf函数，地址是偶数，点击进去又是thumb指令。那在其它文件调用这个导出表函数时，如何正确知道函数是哪种模式？readelf -s libc.so &gt; a.txt可以显示库的所有导出符号表，\n...   657: 0001e775    36 FUNC    GLOBAL DEFAULT    7 printf...\n下面是在ida中的地址在ida中的地址是1e774，通过readelf的地址是1e775，所以就能判断出printf是thumb模式的，在调用printf的时候，会把拆成两部分，最低位写入T标志位，跳转的时候自动模式切换了。这也就解释了在使用frida在hook thumb函数地址的时候为什么要加1了。\nThumb模式在thumb下短指令也就是2字节的指令一般不使用r8-r12寄存器，如果使用了就会编译为长指令。一般也没有条件码和标志响应位，运算指令优先对第一，第二操作数相同情况下用短指令编码，以提高代码密度。这种优化可以减少指令数量和代码大小。比如：add r0, r0, r1 会自动转为 add r0, r1还有一些情况当短指令编码编译不过的时候编译器会在指令后缀+.w进行4字节指令编码。add.w r0, r0, r1\nIT指令块IT 指令是 Thumb 指令集中的一种条件执行指令，用于在紧接着的多条指令中根据条件选择性地执行。IT 指令块由一个条件码和最多四条紧接着的指令组成，它们构成了一个条件执行块。在条件执行块中，只有在满足条件时才会执行相应的指令。IT 指令的格式如下：IT{&lt;x&gt;{&lt;y&gt;{&lt;z&gt;}}}{&lt;q&gt;} &lt;cond&gt;IT 指令块由可选的后缀（x, y, z）和一个可选的条件码（q）组成。 后缀 x, y, z 分别指示条件执行块中的第一条、第二条和第三条指令。 &lt;q&gt; 是可选的条件码，用于指定条件执行块的执行条件。 如果条件码 &lt;q&gt; 不存在，则默认情况下，IT 指令块中的所有指令都受到相同的条件码  控制。T表示if，E表示else05 BF\tITTET EQ01 20\tMOVEQ R0, #102 21\tMOVEQ R1, #203 22\tMOVS R2, #304 23\tMOVSEQ R3, #4在ida中比如指令 movs r0, #1 如果处于IT指令块里面，会自动给加上条件码。假如这段指令当前的Z标志位是0，那EQ条件就不成立it指令块下的第一条指令跟条件码EQ的条件一样的，不执行it指令块下的第二条指令是看IT后面第一位是T，那也就是跟EQ的条件一样，不执行it指令块下的第三条指令是看IT后面第二位是E，跟EQ的条件相反，执行第四条是T，不执行\n调用约定和栈帧分析调用约定前4个参数：r0-r3，其他参数栈传递非易变寄存器：r4-r11r11: 栈帧指针r12: 导入表寻址测试代码，使用ndk build后用ida打开\n#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int fun(int a, int b, int c, int d, int e, int f)&#123;    int n = d + e;    printf(&quot;%d\\n&quot;, n);    return n;&#125;int main()&#123;    fun(1, 2, 3, 4, 5, 6);    return 0;&#125; \n前4个参数前4个参数通常会被依次传递到寄存器 R0 到 R3 中。这样设计的原因是为了尽可能地利用寄存器，以提高函数调用的效率。如果函数需要的参数超过4个，那么额外的参数就会被放置在栈上。\n.text:00000628                               ; int __cdecl main(int argc, const char **argv, const char **envp).text:00000628                               EXPORT main.text:00000628                               main                                    ; DATA XREF: .text:0000057C↑o.text:00000628                               ; __unwind &#123;.text:00000628 00 48 2D E9                   PUSH            &#123;R11,LR&#125;.text:0000062C 0D B0 A0 E1                   MOV             R11, SP.text:00000630 10 D0 4D E2                   SUB             SP, SP, #0x10.text:00000634 00 00 00 E3                   MOVW            R0, #0.text:00000638 04 00 0B E5                   STR             R0, [R11,#-4].text:0000063C 01 00 00 E3                   MOVW            R0, #1                  ; a 参数1放到寄存器r0.text:00000640 02 10 00 E3                   MOVW            R1, #2                  ; b 参数2放到寄存器r1.text:00000644 03 20 00 E3                   MOVW            R2, #3                  ; c 参数3放到寄存器r2.text:00000648 04 30 00 E3                   MOVW            R3, #4                  ; d 参数4放到寄存器r3.text:0000064C 05 C0 00 E3                   MOVW            R12, #5.text:00000650 00 C0 8D E5                   STR             R12, [SP]               ; e 参数5先放在r12，在从r12读取放到sp上.text:00000654 06 C0 00 E3                   MOVW            R12, #6.text:00000658 04 C0 8D E5                   STR             R12, [SP,#4]            ; f 参数6先放在r12，在从r12读取放在sp+4上.text:0000065C D7 FF FF EB                   BL              fun.text:0000065C.text:00000660 00 10 00 E3                   MOVW            R1, #0.text:00000664 08 00 8D E5                   STR             R0, [SP,#8].text:00000668 01 00 A0 E1                   MOV             R0, R1.text:0000066C 0B D0 A0 E1                   MOV             SP, R11.text:00000670 00 88 BD E8                   POP             &#123;R11,PC&#125;.text:00000670                               ; &#125; // starts at 628.text:00000670.text:00000670                               ; End of function main\n非易变寄存器在 ARM 架构中，寄存器 R4 到 R11 被称为非易失性寄存器，通常用于存储在函数调用期间需要被保留的临时数据，因此，如果一个函数在调用期间修改了这些寄存器的值，它必须在返回之前恢复这些寄存器的原始值，以确保调用者的寄存器值不会被破坏。\n栈帧指针在 ARM 架构中，寄存器 R11 通常被用作栈帧指针，栈帧指针是一个指向当前函数栈帧的指针，栈帧是在函数调用期间分配的一块内存区域，用于存储局部变量、函数参数、返回地址等信息。 通常情况下，当一个函数被调用时，它会在栈上创建一个新的栈帧，并将栈帧指针指向这个新的栈帧。在函数内部，通过栈帧指针可以方便地访问栈帧中的局部变量和参数。而当函数返回时，栈帧指针会被恢复到上一个函数的栈帧，以便正确地返回到调用函数。\n.text:000005C0                               ; int fun(int a, int b, int c, int d, int e, int f).text:000005C0                               EXPORT fun.text:000005C0                               fun                                     ; CODE XREF: main+34↓p.text:000005C0                               ; __unwind &#123;.text:000005C0 10 4C 2D E9                   PUSH            &#123;R4,R10,R11,LR&#125;.text:000005C4 08 B0 8D E2                   ADD             R11, SP, #8.text:000005C8 20 D0 4D E2                   SUB             SP, SP, #0x20.text:000005CC 0C C0 9B E5                   LDR             R12, [R11,#f].text:000005D0 08 E0 9B E5                   LDR             LR, [R11,#e].text:000005D4 48 40 9F E5                   LDR             R4, =0x1B0.text:000005D8 04 40 8F E0                   ADD             R4, PC, R4              ; &quot;%d\\n&quot;.text:000005DC 0C 00 0B E5                   STR             R0, [R11,#-0xC].text:000005E0 10 10 0B E5                   STR             R1, [R11,#-0x10].text:000005E4 14 20 8D E5                   STR             R2, [SP,#0x14].text:000005E8 10 30 8D E5                   STR             R3, [SP,#0x10].text:000005EC 10 00 9D E5                   LDR             R0, [SP,#0x10].text:000005F0 08 10 9B E5                   LDR             R1, [R11,#e].text:000005F4 01 00 80 E0                   ADD             R0, R0, R1.text:000005F8 0C 00 8D E5                   STR             R0, [SP,#0xC].text:000005FC 0C 10 9D E5                   LDR             R1, [SP,#0xC].text:00000600 04 00 A0 E1                   MOV             R0, R4                  ; format.text:00000604 08 C0 8D E5                   STR             R12, [SP,#8].text:00000608 04 E0 8D E5                   STR             LR, [SP,#4].text:0000060C C3 FF FF EB                   BL              printf.text:0000060C.text:00000610 0C 10 9D E5                   LDR             R1, [SP,#0xC].text:00000614 00 00 8D E5                   STR             R0, [SP].text:00000618 01 00 A0 E1                   MOV             R0, R1.text:0000061C 08 D0 4B E2                   SUB             SP, R11, #8.text:00000620 10 8C BD E8                   POP             &#123;R4,R10,R11,PC&#125;.text:00000620.text:00000620                               ; End of function fun\n函数开头PUSH            {R11,LR}MOV             R11, SP这两条指令是函数开头的典型指令序列，通常用于建立函数的栈帧。这里的操作可以理解为：PUSH {R11, LR}：将当前函数的栈帧指针 R11 和返回地址 LR 压入栈中。这是为了保存这两个寄存器的值，以便函数执行完毕后能够正确地恢复到函数调用前的状态。 MOV R11, SP：将当前栈指针 SP 的值复制到 R11 中。这样做是为了在函数中能够方便地访问栈帧中的局部变量和其他信息。通常情况下，函数的局部变量和参数会相对于栈帧指针来进行访问。 通过这两条指令的组合，函数建立了自己的栈帧，并将栈帧指针存储在 R11 中，以便在函数内部能够轻松地访问栈上的数据。函数结尾MOV             SP, R11  将栈帧指针 R11 的值赋给栈指针 SP，恢复栈指针到函数调用前的状态。POP             {R11,PC} 从栈中依次弹出 R11 和 PC 寄存器的值。\n导入表寻址R12 寄存器用于进行导入表寻址。导入表是一个数据结构，存储了函数的地址或函数指针。在动态链接库（DLL）或共享库中，当程序调用一个外部函数时，需要在运行时动态解析函数的地址，这就需要导入表。\n.plt:00000520                               ; int printf(const char *format, ...).plt:00000520                               printf                                  ; CODE XREF: fun+4C↓p.plt:00000520 00 C6 8F E2                   ADR             R12, 0x528.plt:00000524 01 CA 8C E2                   ADD             R12, R12, #0x1000.plt:00000528 D0 FA BC E5                   LDR             PC, [R12,#(printf_ptr - 0x1528)]! ; __imp_printf.plt:00000528.plt:00000528                               ; End of function printf\n\n注意：函数的返回值是放在R0里的下面是根据上面反汇编模拟执行的栈指针，根据执行main和fun函数的栈地址偏移表示如下：\n$-30 |\tret_printf\t\t&lt;-- sp fun$-2C |\t5   (LDR LR, [R11,#8]，STR LR, [SP,#4]，将R11+0x8的值放到这)$-28 |\t6\t(LDR R12, [R11,#0xC], STR R12, [SP,#8]，将R11+0xC的值放到这)$-24 |\t9（n）   (LDR R0, [SP,#0x10], LDR R1, [R11,#8], ADD R0, R0, R1，将$-20和$的值4+5放到这)$-20 |\tR3$-1C |\tR2$-18 |\tR1$-14 |\tR0$-10 |\tR4$-C  |\tR10$-8  |\tR11\t\t\t&lt;-- R11, 前一个函数main函数R11的位置$-4  |\tLR$==&gt; |\t5\t\t\t&lt;-- sp main / fun in\t\t\t$+4  |\t6$+8  |\tret_fun$+C  |\t0$+10 |\tR11\t\t\t&lt;-- R11,前一个函数R11的位置$+14 |\tLR$+18 |\t\t\t\t&lt;-- main函数里栈指针稳定时候的位置，main in 0x4+0x4+0x10$+1C |$+20 |$+24 |$+28 |$+2C |$+30 |\n\n","tags":["ARM"]},{"title":"Objection命令","url":"/posts/3900/","content":"安装frida 12.8.0全家桶pip install frida==12.8.0pip install frida-tools==5.3.0pip install objection==1.8.4\n\nfrida切换端口\n./frida-server-12.8.10-android-arm64 -v -l 0.0.0.0:9999\n根据端口连接\nfrida -H 192.168.137.148:9999 -F\n查看进程端口\nnetstat -tuulp |grep fs\nobjection通过端口连接\nobjection -N -h 192.168.137.148 -p 9999 -g com.android.settings explore\n\n列出所有的类\nandroid hooking list classes\n在手机上启动frida-server，并且点击启动“设置”图标，手机进入设置的界面，首先查看一下“设置”应用的包名\n# frida-ps -U|grep -i setting 7107  com.android.settings13370  com.google.android.settings.intelligence\n再使用objection注入“设置”应用。\n# objection -g com.android.settings explore\n\n\n查看内存中加载的库\n\n运行命令memory list modules，\n\n查看库的导出函数\n\n运行命令memory list exports libssl.so\n\n将结果保存到json文件中\n\n当结果太多，终端无法全部显示的时候，可以将结果导出到文件中，然后使用其他软件查看内容\n# memory list exports libart.so --json /root/libart.json  Writing exports as json to /root/libart.json...Wrote exports to: /root/libart.json\n\n\n批量Hookobjection -g 包名 explore -c &quot;path&quot;\n搜索文件下含有关键字\ngrep -ril &quot;okhttp3&quot; *\n\n第二种  使用无线WiFi连接首先先了解一点底层的知识：    Android系统底层运行着一个服务（adbd），用于响应和管理大家在电脑端的adb命令连接，这个服务在启动时会根据手机的配置监听USB连接或网络其中之一。配置的属性为：service.adb.tcp.port，也就是监听的网络端口•以上属性的值 &gt; 0：adbd将监听网络对应的端口（一般为5555）•以上属性的值 &lt;&#x3D;-1：adbd将监听USB接下来是连接步骤：命令行输入：adb connect (ip):5555提示：unable to connect to (ip):5555解决办法：   1）手机与PC相连，执行以下命令：adb tcpip 5555     成功提示：restarting in TCP mode port 5555  　  然后断开USB     错误提示：error:device not found     查看手机USB调试是否打开；PC端是否安装手机驱动。   2）接着执行adb connect (ip):5555，这时候应该就能连接成功了     成功提示：connected to (ip):5555调试完成之后，输入如下的命令断开连接：adb disconnect (ip):5555\n列出所有activity\nandroid hooking list activities\n跳到某一个activuty界面\nandroid intent launch_activity ***Activity\n列出所有services\nandroid hooking list services\n从内存中搜索实例类\nandroid heap search instances ***\n搜索到类的方法是否存在\nandroid heap execute 类的地址值 方法名\n查看实例类的地址\nplugin wallbreaker objectsearch ****\n根据地址查看该类属性\nplugin wallbreaker objectdump ****\n\n启动app并执行objection -g 包名 explore --startup-command &quot;android hooking watch ... --dump-args --dump-backtrace --dump-return&quot; \n\nobjection -g 包名 explore -s &quot;android hooking watch ... --dump-args --dump-backtrace --dump-return&quot; \n\n如何使用objection去批量hook和trace？比如一次性hook几千个类？\n把~&#x2F;.objection&#x2F;objection.log删掉；\n到objection界面中运行android hooking list classes，列出所有的类；\n对新生成的~&#x2F;.objection&#x2F;objection.log文件进行过滤，比如只关心http相关的。cat objection.log|grep -i http\n将输出结果保存到一个excel列中，前面补全android hooking watch class xxxxx，另存为文本文件。如附件所示\n加载这个文件：objection -g com.android.settings explore -c “2.txt” ，这样一下子就hook上了几千个相关类的所有方法及其所有重载。\n如果trace感兴趣的方法也是同理，android hooking search methods * ，会打印出所有的方法。\n\n安装objection插件安装FRIDA_DEXDump\ngit clone https://github.com/hluwa/FRIDA-DEXDump ~/Downloads/FRIDA-DEXDump;\n把frida_dexdumpp移到&#x2F;root&#x2F;.objection&#x2F;plugins&#x2F;下\nmv /root/Downloads/FRIDA-DEXDump/frida_dexdump /root/.objection/plugins/\n\n使用方法\nobjection -g com.app.name explore -P ~/.objection/plugins\nhttps://github.com/hluwa/FRIDA-DEXDump\n\n\n安装Wallbreaker\ngit clone https://github.com/hluwa/Wallbreaker ~/.objection/plugins/Wallbreaker\nhttps://github.com/hluwa/Wallbreaker\n\n\nwallbreaker导入(win下)\nplugin load .objection/plugins/Wallbreaker\n查看类的结构\nplugin wallbreaker classdump ***\n根据名字找类\nplugin wallbreaker classsearch ***\n查看类的实例的内容\nplugin wallbreaker objectdump --fullname ***\n找出类的实例\nplugin wallbreaker objectsearch ***\n","tags":["frida"]},{"title":"Hook抓包","url":"/posts/27616/","content":"Hook抓包核心思想：数据包在明文状态下的一切时机进行dump\nHTTPrequest使用socket实现原生的请求新建一个安卓项目，在mainactivity里添加\npublic class MainActivity extends AppCompatActivity &#123;    @Override    protected void onCreate(Bundle savedInstanceState) &#123;        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main);        new Thread(new Runnable() &#123;            @Override            public void run() &#123;                httpsock();            &#125;        &#125;).start();    &#125;    private static void httpsock()&#123;        try &#123;            final String host = &quot;www.httpbin.org&quot;;            final int port = 80;            final String path = &quot;/get&quot;;            Socket socket = new Socket(host, port);            StringBuilder sb = new StringBuilder();            sb.append(&quot;GET &quot; + path + &quot; HTTP/1.1\\r\\n&quot;);            sb.append(&quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36\\r\\n&quot;);            sb.append(&quot;Host: &quot;+ host+&quot;\\r\\n&quot;);            sb.append(&quot;\\r\\n&quot;);            OutputStream outputStream = socket.getOutputStream();            outputStream.write(sb.toString().getBytes());            InputStream inputStream = socket.getInputStream();            byte[] buffer = new byte[1024];            int len;            while ((len = inputStream.read(buffer, 0, buffer.length)) != -1)&#123;                Log.d(&quot;response==&gt;&quot;, new String(Arrays.copyOf(buffer, len)));            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;\n\n运行一下\n分析这是socket发送http请求的数据包，把数据包写进outputStream后进行发送，outputStream是socket对象的方法，先看一下socket的实现。跟进一下socket的实现\n\n这些都是实现的接口，要找到实现的地方，跟进setImpl方法\n\n可以看到impl是实例对象，这里有分支，先看一下factory，在该文件搜索factory &#x3D; ，看被什么赋值了，\n看到两次赋值的值都是null，所以走else，跟进 SocksSocketImpl();，这里就到socket实现的地方。\n\n进行搜索getOutputStream()方法实现的地方，发现没有找到，那就是存在父类了，跟进父类PlainSocketImpl。再次搜索没有，再跟进它的父类AbstractPlainSocketImpl\n\n再搜索，发现找到了getOutputStream()实现的地方，两个if都是抛出异常，看第三个if，跟进SocketOutputStream()，\n找到了SocketOutputStream()对象的地方，搜索write()方法，参数是字节\n跟进socketWrite()，调用了socketWrite0()方法，跟进\n可以看到该方法在native层。\nfrida抓包跟到socketWrite0()这里，应该是java层最底层了，hook socketWrite0尝试下\nfunction main()&#123;    Java.perform(function()&#123;        //Http request        Java.use(&quot;java.net.SocketOutputStream&quot;).socketWrite0.implementation = function(fd,bytes,off,len)&#123;            hexdump(bytes,off,len)            this.socketWrite0(fd,bytes,off,len)        &#125;        \t\t// 打印字节数组        function hexdump(bytearry,offset,length)&#123;            var HexDump = Java.use(&quot;com.android.internal.util.HexDump&quot;)            console.log(HexDump.dumpHexString(bytearry,offset,length))        &#125;    &#125;)&#125;setImmediate(main)\n运行frida，运行脚本，成功抓到包再完善一下，添加请求地址，堆栈\nfunction main()&#123;    Java.perform(function()&#123;        //Http request        Java.use(&quot;java.net.SocketOutputStream&quot;).socketWrite0.implementation = function(fd,bytes,off,len)&#123;            // 地址            printAddress(this.socket, true)            // 请求            hexdump(bytes,off,len)            // 堆栈            showStacks()            this.socketWrite0(fd,bytes,off,len)        &#125;                function printAddress(socket, isSend)&#123;            var localAddress = socket.value.getLocalAddress().toString()            var remoteAddress = socket.value.getRemoteSocketAddress().toString()            if(isSend)&#123;                console.log(localAddress +&quot;====&gt;&quot;+ remoteAddress)            &#125;else&#123;                console.log(remoteAddress +&quot;====&gt;&quot;+ localAddress)            &#125;        &#125;        function hexdump(bytearry,offset,length)&#123;            var HexDump = Java.use(&quot;com.android.internal.util.HexDump&quot;)            console.log(HexDump.dumpHexString(bytearry,offset,length))        &#125;        function showStacks() &#123;            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()));        &#125;    &#125;)&#125;setImmediate(main)\n请求地址，堆栈都打印了现在知识完成request部分，还有response\nresponse分析接受数据是InputStream，调用的是socket的getInputStream，getInputStream和getOuputStream是成对出现的，按着刚才的思路可以找到。或者，socketWrite0()是在SocketOutputStream，那么socketRead0()就是在SocketInputStream里。\nfrida抓包用Frida hook试试，再之前的代码上添加\n//Http responseJava.use(&quot;java.net.SocketInputStream&quot;).socketRead0.implementation = function(fd,bytes,off,len,timeout)&#123;    printAddress(this.socket, true)    hexdump(bytes,off,len)    showStacks()    return this.socketRead0(fd,bytes,off,len,timeout)&#125;\n也是成功抓到返回的数据HTTP通用的收发包都抓到了，那HTTPS的呢\nHTTPSrequest也是一样，创建一个HTTPS的请求\ntry &#123;    final String host = &quot;www.httpbin.org&quot;;    final int port = 443;    final String path = &quot;/get&quot;;    SSLSocketFactory sslSocketFactory = (SSLSocketFactory) SSLSocketFactory.getDefault();    SSLSocket socket = (SSLSocket) sslSocketFactory.createSocket(host, port);    StringBuilder sb = new StringBuilder();    sb.append(&quot;GET &quot; + path + &quot; HTTP/1.1\\r\\n&quot;);    sb.append(&quot;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/92.0.4515.159 Safari/537.36\\r\\n&quot;);    sb.append(&quot;Host: &quot;+ host+&quot;\\r\\n&quot;);    sb.append(&quot;\\r\\n&quot;);    Log.d(&quot;request body ===&gt;&quot;, sb.toString());    OutputStream outputStream = socket.getOutputStream();    outputStream.write(sb.toString().getBytes());    InputStream inputStream = socket.getInputStream();    byte[] buffer = new byte[1024];    int len;    while ((len = inputStream.read(buffer, 0, buffer.length)) != -1)&#123;        Log.d(&quot;response ==&gt;&quot;, new String(Arrays.copyOf(buffer, len)));    &#125;&#125; catch (IOException e) &#123;    e.printStackTrace();&#125;\n运行之后\n分析这里使用调试，可以快速定位到对象类的位置，在源码中搜一下ConscryptFileDescriptorSocket网址：http://aospxref.com/android-8.1.0_r81/然后在源码文件搜索内部类SSLOutputStream，是继承OutputStream，然后对原来的write方法进行重写跟踪一下write方法里的ssl.write()再跟踪NativeCrypto.SSL_write()，又到了native层，可以说已经在java层跟到底了\nfrida抓包用frida hook下org.conscrypt.NativeCrypto类下的SSL_write()方法\nfunction main()&#123;    Java.perform(function()&#123;        //Https request        Java.use(&quot;org.conscrypt.NativeCrypto&quot;).SSL_write.implementation = function(ssl,fd,shc,bytes,off,len,timeout)&#123;            hexdump(bytes,off,len)            showStacks()            this.SSL_write(ssl,fd,shc,bytes,off,len,timeout)        &#125;        \t\t// 打印字节数组        function hexdump(bytearry,offset,length)&#123;            var HexDump = Java.use(&quot;com.android.internal.util.HexDump&quot;)            console.log(HexDump.dumpHexString(bytearry,offset,length))        &#125;        function showStacks() &#123;            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()));        &#125;    &#125;)&#125;setImmediate(main)\n运行会看到报错了，说找不到NativeCrypto这个类使用objection看一下，内存中是否存在NativeCrypto，多加了com.android前缀，再用frida试一下com.android.org.conscrypt.NativeCrypto这次成功抓到包\nresponseresponse同理\nfrida抓包//Https responseJava.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_read.implementation = function(ssl,fd,shc,bytes,off,len,timeout)&#123;    hexdump(bytes,off,len)    showStacks()    return this.SSL_read(ssl,fd,shc,bytes,off,len,timeout)&#125;\n\n完整代码function main()&#123;    Java.perform(function()&#123;        //Http request        Java.use(&quot;java.net.SocketOutputStream&quot;).socketWrite0.implementation = function(fd,bytes,off,len)&#123;            printAddress(this.socket, true)            hexdump(bytes,off,len)            showStacks()            this.socketWrite0(fd,bytes,off,len)        &#125;        //Http response        Java.use(&quot;java.net.SocketInputStream&quot;).socketRead0.implementation = function(fd,bytes,off,len,timeout)&#123;            printAddress(this.socket, false)            hexdump(bytes,off,len)            showStacks()            return this.socketRead0(fd,bytes,off,len,timeout)        &#125;        //Https request        Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_write.implementation = function(sslNativePointer,fd,shc,bytes,off,len,timeout)&#123;            printHttpsAddress(fd)            hexdump(bytes,off,len)            showStacks()            return this.SSL_write(sslNativePointer,fd,shc,bytes,off,len,timeout)        &#125;        //Https response        Java.use(&quot;com.android.org.conscrypt.NativeCrypto&quot;).SSL_read.implementation = function(sslNativePointer,fd,shc,bytes,off,len,timeout)&#123;            printHttpsAddress(fd)            hexdump(bytes,off,len)            showStacks()            return this.SSL_read(sslNativePointer,fd,shc,bytes,off,len,timeout)        &#125;        function printHttpsAddress(fd, isSend)&#123;            var local = Socket.localAddress(fd.getInt$())            var peer = Socket.peerAddress(fd.getInt$())            if(isSend)&#123;                console.log(local.ip+&quot;:&quot;+local.port +&quot;====&gt;&quot;+ peer.ip+&quot;:&quot;+peer.port)            &#125;else&#123;                console.log(peer.ip+&quot;:&quot;+peer.port +&quot;====&gt;&quot;+ local.ip+&quot;:&quot;+local.port)            &#125;        &#125;        function printAddress(socket, isSend)&#123;            var localAddress = socket.value.getLocalAddress().toString()            var remoteAddress = socket.value.getRemoteSocketAddress().toString()            if(isSend)&#123;                console.log(localAddress +&quot;====&gt;&quot;+ remoteAddress)            &#125;else&#123;                console.log(remoteAddress +&quot;====&gt;&quot;+ localAddress)            &#125;        &#125;        function hexdump(bytearry,offset,length)&#123;            var HexDump = Java.use(&quot;com.android.internal.util.HexDump&quot;)            console.log(HexDump.dumpHexString(bytearry,offset,length))        &#125;                function showStacks() &#123;            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()));        &#125;    &#125;)&#125;setImmediate(main)","tags":["抓包"]},{"title":"HMAC-MD5,HMAC-SHA1算法流程","url":"/posts/40655/","content":"每种哈希函数的特征\n1.MD5初始化魔数：A &#x3D; 0x67452301;B &#x3D; 0xEFCDAB89;C &#x3D; 0x98BADCFE;D &#x3D; 0x10325476;K表K1 &#x3D; 0xd76aa478K2 &#x3D; 0xe8c7b756K3 &#x3D; 0x242070dbK表来自sin函数输出长度16个字节，或者说32个十六进制数，有时候输出16个十六进制数。\n2.SHA1A &#x3D; 0x67452301B &#x3D; 0xEFCDAB89C &#x3D; 0x98BADCFED &#x3D; 0x10325476E &#x3D; 0xC3D2E1F0和MD5相比，有五个初始化链接变量，而且前四个链接变量完全相同。输出长度20个字节，或者说40个十六进制数。只有四个K值，每20轮用同一个K作变换K1 &#x3D; 0x5a827999K2 &#x3D; 0x6ed9eba1K3 &#x3D; 0x8f1bbcdcK4 &#x3D; 0xca62c1d6\n3.SHA256A &#x3D; 0x6A09E667;B &#x3D; 0xBB67AE85;C &#x3D; 0x3C6EF372;D &#x3D; 0xA54FF53A;E &#x3D; 0x510E527F;F &#x3D; 0x9B05688C;G &#x3D; 0x1F83D9AB;H &#x3D; 0x5BE0CD19;八个初始化链接变量输出长度为32个字节，或者说64个十六进制数有64个K值，每轮1个K值K1 &#x3D; 0x428a2f98K2 &#x3D; 0x71374491K3 &#x3D; 0xb5c0fbcfK4 &#x3D; 0xe9b5dba5K值来自素数\n4.SHA 512A &#x3D; 0x6a09e667f3bcc908;B &#x3D; 0xbb67ae8584caa73b;C &#x3D; 0x3c6ef372fe94f82b;D &#x3D; 0xa54ff53a5f1d36f1;E &#x3D; 0x510e527fade682d1;F &#x3D; 0x9b05688c2b3e6c1f;G &#x3D; 0x1f83d9abfb41bd6b;H &#x3D; 0x5be0cd19137e2179;八个初始化链接变量，IDA反编译也时常显示为16个。输出长度为64字节，或者说128个十六进制数有80个K，每一轮一个K，K值来自素数。K1 &#x3D; 0x428a2f98d728ae22K2 &#x3D; 0x7137449123ef65cdK3 &#x3D; 0xb5c0fbcfec4d3b2fK4 &#x3D; 0xe9b5dba58189dbbc和SHA256的K有关联。\nHMACHMAC-MD5HMAC-SHA1HMAX-XXX 加盐+双重哈希方案\nHMAC MD5CyberchefHMAC-MD5明文：123456(utf-8)密文：111111(utf-8)结果：5542af910b1ff3f554dcdfb7ceccebc8\n公式：\n第一步（让密钥的长度达到分组长度）：如果密钥长度超过512bit，先进行一次MD5后：16个字节+00000…k &#x3D; 0x313131313131密钥进行扩展MD5: 512比特–64字节–128hex 分组长度（十六进制，128长度）k’&#x3D;0x31313131313100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n第二步（k’⊕opad）：先对opad填充到分组长度0x5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c进行异或k’⊕opad&#x3D;0x6d6d6d6d6d6d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c\n第三步（k’⊕ipad）：先对ipad填充到分组长度0x36363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636进行异或k’⊕ipad&#x3D;0x07070707070736363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636\n第四步级联明文（(k’⊕ipad)||m）:(k’⊕ipad)||m&#x3D;0x07070707070736363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636313233343536\n第五步级联后进行md5（H((k’⊕ipad)||m)）:级联后进行一次md5（不需要转hex）H((k’⊕ipad)||m)&#x3D;873883125b81d8d9b483f29cffeeea37\n第六步（第二步级联第五步后进行md5，H((k’⊕opad)||H((k’⊕ipad)||m)）0x6d6d6d6d6d6d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c873883125b81d8d9b483f29cffeeea37结果：5542af910b1ff3f554dcdfb7ceccebc8结果跟Cyberchef的HMAC-MD5一致\nHMAC SHA1CyberchefHMAC-SHA1明文：helloword(utf-8)密文：1111(hex)结果：4ea30551db501b285a03a197c65fea249131b808\n第一步（让密钥的长度达到分组长度）：如果密钥长度超过512bit，先进行一次SHA1后：16个字节+00000…k &#x3D; 0x1111密钥进行扩展SHA1: 512比特–64字节–128hex 分组长度（十六进制，128长度）k’&#x3D;0x11110000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\n第二步（k’⊕opad）：异或0x5c先对opad填充到分组长度0x5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c然后进行异或k’⊕opad&#x3D;0x4d4d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c\n第三步（k’⊕ipad）：异或0x36先对ipad填充到分组长度0x3636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636进行异或k’⊕ipad&#x3D;0x27273636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636\n第四步级联明文（(k’⊕ipad)||m）:(k’⊕ipad)||m&#x3D;0x2727363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363636363668656c6c6f776f7264\n第五步级联后进行sha1（H((k’⊕ipad)||m)）:级联后进行一次sha1（不需要转hex）H((k’⊕ipad)||m)&#x3D;aea39b30d6922fdbb1848fe3a49bd130ed337f77\n第六步（第二步级联第五步后进行sha1，H((k’⊕opad)||H((k’⊕ipad)||m)）级联(k’⊕opad)||H((k’⊕ipad)||m)&#x3D;0x4d4d5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5c5caea39b30d6922fdbb1848fe3a49bd130ed337f774ea30551db501b285a03a197c65fea249131b808\n总结第一步k值填充到块长度(md5和sha1是512bit，128hex)称为k’第二步k’与0x36异或后拼接明文的hex，进行原函数哈希（如hmac md5就进行一次md5，hmac sha1就进行一次sha1）第三步k’与0x5c异或后拼接第二步再进行一次原函数哈希\n","tags":["算法"]},{"title":"ProtoBuf分析以及某方数据逆向","url":"/posts/13480/","content":"什么是protobuf一拿到网站，F12查看是否有相关数据的请求接口请求体是这样的请求头的类型也非常见的\n\napplication&#x2F;json： JSON数据格式\napplication&#x2F;octet-stream ： 二进制流数据\napplication&#x2F;x-www-form-urlencoded ： 中默认的encType，form表单数据被编码为key&#x2F;value格式发送到服务器（表单默认的提交数据的格式）\nmultipart&#x2F;form-data ： 需要在表单中进行文件上传时，就需要使用该格式\n\n通过查询知道这是protobuf参考文章：https://blog.csdn.net/dideng7039/article/details/101869819总结在图下了\n那如何使用protobuf？开发者需要先编写proto文件，在proto文件中编写预期的数据类型、数据字段、默认值等然后，通过编译器生成，编程语言对应的开发包！开发时调开发包中的对应方法进行序列化和反序列化。所以请求的时候需要参数是序列化的字节序列，对接收到的返回值进行反序列化而要实现序列化，就必须要有开发包，可是开发包是js版本的。而开发包是由proto编译而来，只要能拿到proto文件，就可以编译成任意编程的语言版本。那就是需要通过编译好的包反编译出proto，再编译为python版本的\n这里先写一个简单proto，在编译成js版本，看看里面大概的结构长什么样下载编译器：https://github.com/protocolbuffers/protobuf/releases/解压后把bin目录路径添加到环境变量，就可以全局使用注意，下载低于3.21.0 的proto版本，因为原项目已将它独立出来，下载最新版本的protoc，运行js_out会缺少插件proto除了一些基础字段，还有一些特殊字段\n\n\n\n英文\n中文\n备注\n\n\n\nenum\n枚举(数字从零开始) 作用是为字段指定某”预定义值序列”\nenum Type {DEFAULT &#x3D; 0;success &#x3D; 1; fail&#x3D; -1;}\n\n\nmessage\n消息体\nmessage Student{}\n\n\nrepeated\n数组&#x2F;集合\nrepeated Student student &#x3D; 1\n\n\nimport\n导入定义\nimport “protos&#x2F;other_protos.proto”\n\n\n&#x2F;&#x2F;\n注释\n&#x2F;&#x2F;用于注释\n\n\nextend\n扩展\nextend Student {}\n\n\npackage\n包名\n相当于命名空间，用来防止不同消息类型的明明冲突\n\n\n现在写一个简单的proto文件\nsyntax = &quot;proto3&quot;; // 定义proto的版本enum Gender&#123;  boy=0;  girl=1;&#125;enum Score&#123;  DEFAULT = 0;  success = 1; // 及格  fail = -1; // 不及格&#125;message Student &#123;  string name = 1; // 姓名  int32 age = 2; // 年龄  Gender gender = 3; //性别  message Subject &#123;    string name = 1; // 学科名称    Score score = 2; // 分数  &#125;  repeated Subject subject = 4; // 学科&#125;\n编译为JS包\nprotoc --js_out=. .\\test.proto3protoc --js_out=import_style=commonjs,binary:. test.proto\n两条语句都可以，第一条会拆分成多个文件，第二条是合并成一个，推荐使用第二条头部就能看到定义好的几个大的对象可以大概看下代码，截一段比较重要的\n/** * Serializes the given message to binary data (in protobuf wire * format), writing to the given BinaryWriter. * @param &#123;!proto.Student&#125; message * @param &#123;!jspb.BinaryWriter&#125; writer * @suppress &#123;unusedLocalVariables&#125; f is only used for nested messages */proto.Student.serializeBinaryToWriter = function(message, writer) &#123;  var f = undefined;  f = message.getName();  if (f.length &gt; 0) &#123;    writer.writeString(      1,      f    );  &#125;  f = message.getAge();  if (f !== 0) &#123;    writer.writeInt32(      2,      f    );  &#125;  f = message.getGender();  if (f !== 0.0) &#123;    writer.writeEnum(      3,      f    );  &#125;  f = message.getSubjectList();  if (f.length &gt; 0) &#123;    writer.writeRepeatedMessage(      4,      f,      proto.Student.Subject.serializeBinaryToWriter    );  &#125;&#125;;\n这一段序列化的代码中出现了如下的方法名：\n\ngetName, writeStringgetAge, writeInt32getGender, writeEnumgetSubjectList, writeRepeatedMessage\n\n这一整个判断，这意味 Student中定义了四个数据变量， 序号为1， 2，3，4，而数据类型和变量名可以根据其调用的方法推出\n\n序号为1的数据类型为String，变量名为name序号为2的数据类型为Int32，变量名为age序号为3的数据类型为Enum， 变量名为gender序号为4的数据类型为Message，变量名为subject，Repeated下面讲\n\n字符串和整数型一看就明了，不做过多解释，下面了解Message和EnumMessage是什么数据类型？简单的理解，可以把message看作是一个类，在其中定义的变量就是类属性在序号为4的subject判断中有这样一行代码\nproto.Student.Subject.serializeBinaryToWriter\n再来看看Student的\nproto.Student.serializeBinaryToWriter\n到这里可知，Subject定义在Student里面且类型是Message在定义序号为4的数据时，数据类型就是Subject，并且是可重复的！所以才会出现这样一个方法writeRepeatedMessage，并且严格来说，序号为4的数据是自定义的Message数据类型，且是可重复的Message类型的Subject被repeated修饰，即Subject是一个包含多个Subject实例的数组Enum是什么数据类型？枚举类型，在值为限定的情况下，比如性别除了男就是女。可以理解为单选框，这里还有个注意的，枚举类型。必须要有为0的默认选项总而言之呢，看见writeEnum就知道这个数据为Enum类型repeated也可以修饰Enum，其对应的JS写操作的方法为writePackedEnum被repeated修饰的enum类型，则好似的多选框，至少选择一个，可选择多个小结一下：被repeated修饰的message类型的数据，看作是一个包含任意个某message类型数据的数组被repeated修饰的enum类型的数据，看作是一个包含任意个整数类型数据的整型数组\n调试JS反写proto目标网站：aHR0cHM6Ly9zLndhbmZhbmdkYXRhLmNvbS5jbi9wYXBlcj9xPXB5dGhvbg&#x3D;&#x3D;将接口的请求地址复制 &#x2F;SearchService.SearchService&#x2F;search ，打 XHR&#x2F;fetch 断点断住后查看堆栈，有SearchService跟进去打断点看看看下这些方法的命名，序列化（serialize）、反序列化（deserialize），基本断定就在这个js文件里，但是这个js有几万行代码，不可能仔细去看也没必要。看到明显的prototype字样，直接搜proto的特征\n\ntoObject 将获取到的数据转成结构化数据deserializeBinary 二进制数据转换成数组结构（反序列化 | 获取到的数据需要Uint8Array转成二进制）deserializeBinaryFromReader 根据规则，将二进制数据转换成数组结构serializeBinary 将数据转成二进制（序列化）serializeBinaryToWriter 根据规则，将数据转换成二进制数据（序列化）\n\n可以肯定就是proto了一步步跟进后，到序列化发包的位置在这里，直接就可以看出其基本结构\nmessage SearchService &#123;  message SearchRequest &#123;  &#125;&#125;\n继续调试。这里可以看出SearchRequest定义了两个变量，分别是序号为1的message类型的CommonRequest和序号为2的enum类型的InterfaceType。根据SearchService.CommonRequest可知，CommonRequest定义在SearchService中所以，proto文件现在是这样的：\nsyntax = &quot;proto3&quot;; // 定义proto的版本message SearchService &#123;  message SearchRequest &#123;    CommonRequest commonRequest = 1; // 任意变量名    InterfaceType interfaceType = 2; // 任意变量名  &#125;  message CommonRequest &#123;  &#125;  enum InterfaceType&#123;    DEFAULT = 0;  // 定义了什么不知道，但是enum必须有一个值就是0  &#125;&#125;\n关于变量名是什么，这个其实不重要继续往下调试，进入到了CommonRequest根据方法名，直接就可以反写出CommonRequest\n  message SearchRequest &#123;    CommonRequest commonRequest = 1; // 任意变量名    InterfaceType interfaceType = 2; // 任意变量名  &#125;  message CommonRequest &#123;    string searchType = 1;    string searchWord = 2;    SearchSort searchSort = 3;    repeated Second second = 4;    int32 currentPage = 5;    int32 pageSize = 6;    SearchScope searchScope = 7;    repeated SearchFilter searchFilter = 8;    bool languageExpand = 9;    bool topicExpand = 10;  &#125;  message SearchSort &#123;  &#125;  message Second &#123;  &#125;  enum InterfaceType&#123;    TypeDefault = 0;  // 定义了什么不知道，但是enum必须有一个值就是0  &#125;  enum SearchScope&#123;    ScopeDefault = 0;  &#125;  enum SearchFilter &#123;      FilterDefault = 0;  &#125;&#125;\nSearchSort和Second都是在SearchService定义的，Ctrl + F搜索SearchService.SearchSort.serializeBinaryToWriterSearchService.Second.serializeBinaryToWriter补齐字段，请求接口的proto文件就算写完了\nsyntax = &quot;proto3&quot;; // 定义proto的版本message SearchService &#123;  message SearchRequest &#123;    CommonRequest commonRequest = 1; // 任意变量名    InterfaceType interfaceType = 2; // 任意变量名  &#125;  message CommonRequest &#123;    string searchType = 1;    string searchWord = 2;    SearchSort searchSort = 3;    repeated Second second = 4;    int32 currentPage = 5;    int32 pageSize = 6;    SearchScope searchScope = 7;    repeated SearchFilter searchFilter = 8;    bool languageExpand = 9;    bool topicExpand = 10;  &#125;  message SearchSort &#123;    string field = 1;    Order order = 2;    enum Order &#123;      OrderDefault = 0;    &#125;  &#125;  message Second &#123;    string field = 1;    string value = 2;  &#125;  enum InterfaceType&#123;    TypeDefault = 0;  // 定义了什么不知道，但是enum必须有一个值就是0  &#125;  enum SearchScope&#123;    ScopeDefault = 0;  &#125;  enum SearchFilter &#123;    FilterDefault = 0;  &#125;&#125;\n对于所有的enum枚举类，至少填充一个默认值0，且变量名唯一有的情况，枚举类含有哪些字段，可以在代码中直接看到，就照抄写进去。看不到的，给个唯一变量名，默认值为0即可现在还差一个源数据，即我们需要知道待编译的源数据是什么样子的？使用fiddler进行抓包查看请求参数抓到包后查看HexView，黑色部分就是请求体，里面也可以看到我们搜素的关键词python选中，右键保存为字节文件也就是bin后缀，这里要注意，前5个字节表示请求体的长度，从第6个字节开始到结束刚好就是0x1A字节数据是可以通过protoc编译器解码出来的\n&gt;protoc --decode_raw &lt; get_req.bin1 &#123;  1: &quot;paper&quot;  2: &quot;python&quot;  5: 2  6: 20  8: &quot;\\000&quot;&#125;2: 1\n与上面编写好的proto文件进行对比像有些没包含到的字段，是请求的时候页面没做一些条件筛选，就没触发到某些字段实际传输时，简单的看，键就是proto中定义的序号，这就是之前提到的 变量名是什么根本不重要，变量名只是方便开发者开发时便于理解与调用。（传输一个数字远比传输一个字符串更有效率）完全还原proto文件是不需要的，构造出这个请求参数，获取这个接口的响应内容就可以了\n实现请求编译proto为python包，构建参数，序列化参数，发送请求\nprotoc --python_out=. ./search.proto\n目录下生成了search_pb2.py 拖入项目中，需要使用时就调用即可\nimport search_pb2 as pb  # 导入包search_request = pb.SearchService.SearchRequest()  # 实例化对象# 按上面解析数据，按照对应的属性设置值# 字符串，数字型的都是直接赋值search_request.commonRequest.searchType = &#x27;paper&#x27;search_request.commonRequest.searchWord = &#x27;python&#x27;search_request.commonRequest.currentPage = 2search_request.commonRequest.pageSize = 20# repeated修饰的messsage类型和enum类型，则需要稍微多几个步骤search_request.commonRequest.searchFilter.append(0)search_request.interfaceType = 1form_data = search_request.SerializeToString()print(form_data)# 保存数据玮bin文件供后续对比使用with open(&#x27;me.bin&#x27;, mode=&quot;wb&quot;) as f:    f.write(form_data)print(search_request.SerializeToString().decode())\n至此，请求参数的序列化已经是完成了发送请求完整代码\nimport search_pb2 as pb  # 导入包import requestssearch_request = pb.SearchService.SearchRequest()  # 实例化对象# 按上面解析数据，按照对应的属性设置值# 字符串，数字型的都是直接赋值search_request.commonRequest.searchType = &#x27;paper&#x27;search_request.commonRequest.searchWord = &#x27;python&#x27;search_request.commonRequest.currentPage = 2search_request.commonRequest.pageSize = 20# repeated修饰的messsage类型和enum类型，则需要稍微多几个步骤search_request.commonRequest.searchFilter.append(0)search_request.interfaceType = 1form_data = search_request.SerializeToString()print(form_data)# 保存数据玮bin文件供后续对比使用# with open(&#x27;me.bin&#x27;, mode=&quot;wb&quot;) as f:#     f.write(form_data)# print(search_request.SerializeToString().decode())bytes_head = bytes([0, 0, 0, 0, len(form_data)])print(bytes_head+form_data)headers = &#123;    &quot;Accept&quot;: &quot;*/*&quot;,    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9,zh-TW;q=0.8&quot;,    &quot;Content-Type&quot;: &quot;application/grpc-web+proto&quot;,    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/105.0.0.0 Safari/537.36&quot;,&#125;url = &quot;https://*********/SearchService.SearchService/search&quot;response=requests.post(url,headers=headers,data=bytes_head+form_data)print(response.content)\n\n响应处理我们构造了请求的proto文件，并成功用python发包获得了数据，但是得到的数据和f12得到的数据是一样的乱码如下图其实这个也是protobuf格式，发过去的是protobuf格式，收到的也是protobuf格式，只是它是以二进制序列化格式传输的，所以看上去像乱码.接下来会带来两种方法：①直观但有点复杂，②便捷但不太直观\n方法一写对应的响应的proto文件，和发包一样。当然可以和发包写在一起。老规矩，还是打断点从堆栈进行分析，根据发包的堆栈主要看app开头的js，因为chunk开头的是基本库，很少在里面做手脚，一般都是在自写的js里面做加密或其他操作。一步步调试后，异步然后获得了值去.toObject,这个toObject就是proto文件转js的时候会产生的一个api函数接口，可以简单使用protoc去尝试转化成js看看。这里不好跟进，直接全局搜索一下：proto.SearchService.SearchResponse这里接受响应后需要把二进制数据进行反序列化，那么就会用到下面的apideserializeBinary——deserializeBinaryFromReader（重点核心）完整的就是 proto.SearchService.SearchResponse.deserializeBinaryFromReader一下子就定位到了，和请求的一样理解，只是他现在变成了case语句来表示序号位置，read后面的类型来表示类型。序号4有个message，进去查看这个返回的数据量太大了，标号也特别的多，有没有什么更好的方法得到proto文件呢？那就是自写ast，然后用ast来处理这种switch语句。这里直接使用渔歌写好的ats插件，文末附上链接，网站js有些小更新，之前的可能有些小报错，小小的修改了一下这里把整个js复制出来命名为test.js，先安装babel解析库在当前目录下\nnpm install @babel/core --save-dev\n执行ast代码\nconst parser = require(&quot;@babel/parser&quot;);// 为parser提供模板引擎const template = require(&quot;@babel/template&quot;).default;// 遍历ASTconst traverse = require(&quot;@babel/traverse&quot;).default;// 操作节点，比如判断节点类型，生成新的节点等const t = require(&quot;@babel/types&quot;);// 将语法树转换为源代码const generator = require(&quot;@babel/generator&quot;);// 操作文件const fs = require(&quot;fs&quot;);//定义公共函数function wtofile(path, flags, code) &#123;    var fd = fs.openSync(path,flags);    fs.writeSync(fd, code);    fs.closeSync(fd);&#125;function dtofile(path) &#123;    fs.unlinkSync(path);&#125;var file_path = &#x27;test.js&#x27;; //你要处理的文件var jscode = fs.readFileSync(file_path, &#123;    encoding: &quot;utf-8&quot;&#125;);// 转换为AST语法树let ast = parser.parse(jscode);let proto_text = `syntax = &quot;proto3&quot;;// protoc --python_out=. app_proto2.proto`;traverse(ast, &#123;    MemberExpression(path)&#123;        if(path.node.property.type === &#x27;Identifier&#x27; &amp;&amp; path.node.property.name === &#x27;deserializeBinaryFromReader&#x27; &amp;&amp; path.parentPath.type === &#x27;AssignmentExpression&#x27;)&#123;            let id_name = path.toString().split(&#x27;.&#x27;).slice(1, -1).join(&#x27;_&#x27;);            path.parentPath.traverse(&#123;                VariableDeclaration(path_2)&#123;                    if(path_2.node.declarations.length === 1)&#123;                        path_2.replaceWith(t.expressionStatement(                            t.assignmentExpression(                                &quot;=&quot;,                                path_2.node.declarations[0].id,                                path_2.node.declarations[0].init                            )                        ))                    &#125;                &#125;,                SwitchStatement(path_2)&#123;                    for (let i = 0; i &lt; path_2.node.cases.length - 1; i++) &#123;                        let item = path_2.node.cases[i];                        let item2 = path_2.node.cases[i + 1];                        if(item.consequent.length === 0 &amp;&amp; item2.consequent[1].expression.type === &#x27;SequenceExpression&#x27;)&#123;                            item.consequent = [                                item2.consequent[0],                                t.expressionStatement(                                    item2.consequent[1].expression.expressions[0]                                ),                                item2.consequent[2]                            ];                            item2.consequent[1] = t.expressionStatement(                                item2.consequent[1].expression.expressions[1]                            )                        &#125;else if(item.consequent.length === 0)&#123;                            item.consequent = item2.consequent                        &#125;else if(item.consequent[1].expression.type === &#x27;SequenceExpression&#x27;)&#123;                            item.consequent[1] = t.expressionStatement(                                item.consequent[1].expression.expressions[1]                            )                        &#125;                    &#125;                &#125;            &#125;);            let id_text = &#x27;message &#x27; + id_name + &#x27; &#123;&#x27;;            let let_id_list = [];            try&#123;                // console.log(path.parentPath.node.right.body.body[0].body.body[0].cases.length);                for (let i = 0; i &lt; path.parentPath.node.right.body.body[0].body.body[0].cases.length; i++) &#123;                    let item = path.parentPath.node.right.body.body[0].body.body[0].cases[i];                    if(item.test)&#123;                        let id_number = item.test.value;                        let key = item.consequent[1].expression.callee.property.name;                        let id_st, id_type;                        if(key.startsWith(&quot;set&quot;))&#123;                            id_st = &quot;&quot;;                        &#125;else if(key.startsWith(&quot;add&quot;))&#123;                            id_st = &quot;repeated&quot;;                        &#125;else&#123;                            // map类型，因为案例中用不到，所以这里省略                            continue                        &#125;                        key = key.substring(3, key.length);                        id_type = item.consequent[0];                        if(id_type.expression.right.type === &#x27;NewExpression&#x27;)&#123;                            id_type = generator.default(id_type.expression.right.callee).code.split(&#x27;.&#x27;).slice(1).join(&#x27;_&#x27;);                        &#125;else&#123;                            switch (id_type.expression.right.callee.property.name) &#123;                                case &quot;readString&quot;:                                    id_type = &quot;string&quot;;                                    break;                                case &quot;readDouble&quot;:                                    id_type = &quot;double&quot;;                                    break;                                case &quot;readInt32&quot;:                                    id_type = &quot;int32&quot;;                                    break;                                case &quot;readInt64&quot;:                                    id_type = &quot;int64&quot;;                                    break;                                case &quot;readFloat&quot;:                                    id_type = &quot;float&quot;;                                    break;                                case &quot;readBool&quot;:                                    id_type = &quot;bool&quot;;                                    break;                                case &quot;readPackedInt32&quot;:                                    id_st = &quot;repeated&quot;;                                    id_type = &quot;int32&quot;;                                    break;                                case &quot;readBytes&quot;:                                    id_type = &quot;bytes&quot;;                                    break;                                case &quot;readEnum&quot;:                                    id_type = &quot;readEnum&quot;;                                    break;                                case &quot;readPackedEnum&quot;:                                    id_st = &quot;repeated&quot;;                                    id_type = &quot;readEnum&quot;;                                    break;                            &#125;                        &#125;                        if(id_type === &#x27;readEnum&#x27;)&#123;                            id_type = id_name + &#x27;_&#x27; + key + &#x27;Enum&#x27;;                            if(let_id_list.indexOf(id_number) === -1)&#123;                                id_text += &#x27;\\tenum &#x27; + id_type + &#x27; &#123;&#x27;;                                for (let j = 0; j &lt; 3; j++) &#123;                                    id_text += &#x27;\\t\\t&#x27; + id_type + &#x27;TYPE_&#x27; + j + &#x27; = &#x27; + j + &#x27;;&#x27;;                                &#125;                                id_text += &#x27;\\t&#125;&#x27;;                                id_text += &#x27;\\t&#x27; + id_st + &#x27; &#x27; + id_type + &#x27; &#x27; + key + &#x27; = &#x27; + id_number + &#x27;;&#x27;;                                let_id_list.push(id_number)                            &#125;                        &#125;else&#123;                            if(let_id_list.indexOf(id_number) === -1)&#123;                                id_text += &#x27;\\t&#x27; + id_st + &#x27; &#x27; + id_type + &#x27; &#x27; + key + &#x27; = &#x27; + id_number + &#x27;;&#x27;;                                let_id_list.push(id_number)                            &#125;                        &#125;                    &#125;                &#125;            &#125;catch(e)&#123;            &#125;            id_text += &#x27;&#125;&#x27;;            proto_text += id_text        &#125;    &#125;&#125;);wtofile(&#x27;app_proto3.proto&#x27;, &#x27;w&#x27;, proto_text);\n这个ast代码单纯只是针对这个站点，其他站点也是类似分析。运行后生成了app_proto3.proto文件，打开看一面有一些报错，如下图，渔歌文章也讲清楚了原因，因为对象调用deserializeBinaryFromReader方法的时候，ast代码处理对象无法确定，所以就没加载到。我们在调试里面，搜索关键词ExportResponse.deserializeBinaryFromReader跟进去就能找到s对象是什么，补上就行，其他的报错也是这样的操作得到了proto文件后进行编译成python \nprotoc --python_out=. ./app_proto3.proto\n然后发个请求试一试\nimport app_proto3_pb2 as pbimport requestssearch_request = pb.SearchService_SearchRequest()  # 实例化对象# 按上面解析数据，按照对应的属性设置值# 字符串，数字型的都是直接赋值search_request.Commonrequest.SearchType = &#x27;paper&#x27;search_request.Commonrequest.SearchWord = &#x27;python&#x27;search_request.Commonrequest.CurrentPage = 2search_request.Commonrequest.PageSize = 20# repeated修饰的messsage类型和enum类型，则需要稍微多几个步骤search_request.Commonrequest.SearchFilterList.append(0)search_request.InterfaceType = 1form_data = search_request.SerializeToString()print(form_data)# 保存数据玮bin文件供后续对比使用# with open(&#x27;me.bin&#x27;, mode=&quot;wb&quot;) as f:#     f.write(form_data)# print(search_request.SerializeToString().decode())bytes_head = bytes([0, 0, 0, 0, len(form_data)])print(bytes_head + form_data)headers = &#123;    &quot;Accept&quot;: &quot;*/*&quot;,    &quot;Accept-Language&quot;: &quot;zh-CN,zh;q=0.9&quot;,    &quot;Content-Type&quot;: &quot;application/grpc-web+proto&quot;,    &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36&quot;,&#125;url = &quot;https://*********.com.cn/SearchService.SearchService/search&quot;response = requests.post(url, headers=headers, data=bytes_head + form_data)# print(response.text)search_response = pb.SearchService_SearchResponse()search_response.ParseFromString(response.content[5:])print(search_response)\n可以看到很直观，取值也方便。上面之所以从响应的第六位字节开启取，是跟上面发包一样的，前五个字节表示请求头的长度下面是proto的核心，序列化和反序列化serializeBinary——serializeBinaryFromReader（重点核心）deserializeBinary——deserializeBinaryFromReader（重点核心）\n方法二使用python应对protobuf的第三方库：blackboxprotobuf安装命令：pip install blackboxprotobuf调用核心函数 ：blackboxprotobuf.decode_message(Byte类型数据)，进行解protobuf格式数据上面是数据对应结构位置，下面是类型对应结构位置虽然拿到了数据，只是位置序号加内容，我们其实要靠猜才能知道是什么，这种就不需要去写proto文件两种方式都可以，喜欢哪种用哪种\n相关资料参考https://blog.csdn.net/dideng7039/article/details/101869819https://blog.csdn.net/qq_35491275&#x2F;article&#x2F;details&#x2F;111721639https://mp.weixin.qq.com/s/DzCz66_Szc7vfG6bpl956whttps://blog.csdn.net/qq_56881388&#x2F;article&#x2F;details&#x2F;128612717\n","tags":["js","protobuf"]},{"title":"HTTP TCP/IP协议与抓包原理","url":"/posts/50697/","content":"网络基础 TCP&#x2F;IP在说Http之前，先来说一下TCP&#x2F;IP协议。\nTCP&#x2F;IP协议是众多协议的统称，像HTTP，TCP,UDP,DNS等都包括在里面\nTCP&#x2F;IP 协议会把这些进行分层，按层次分为4层：应用层、传输层、网络层、数据链路层。\n也有细分为7层的，应用层、表示层、会话层、传输层、网络层、数据链路层、物理层像HTTP、FTP、DNS就属于应用层，TCP、UDP在传输层，IP在网络层 \n\n\n\nTCP&#x2F;IP通信传输流\n\n\n以HTTP来举例，首先作为发送端的客户端在应用层以HTTP协议发出一个想看某个Web页面的HTTP请求。在应用层会经过DNS解析，通过域名查找IP地址\n\n接着，为了传输方便，在传输层用了TCP协议把从应用层处收到的数据HTTP请求的报文进行分割，并在各个报文上打上标记序号及端口号转发给网络层\n在网络层IP协议，增加作为通信目的地的MAC地址后转发给链路层。\n接收端的服务器在链路层接受数据，按序往上层发送，一直到应用层。在传输到传输层的时候，会把接收到的数据包按原来的顺序重组请求报文。当传输到应用层，才算真正接受到由客户端发送过来的HTTP请求。\n作为接收端的服务器收到发送端的请求后，会把对应的页面以同样的TCP&#x2F;IP通信协议进行回传。\n发送端在层与层之间传输数据时，每经过一层时会被打上该层所属的首部信息，反之，接受端在层与层传输数据时，每经过一层时会把对应的首部消去。\n\n\nTCP协议的可靠性（三次握手）TCP位于传输层，提供可靠的字节流服务。所谓字节流服务指，为了方便传输，将大块数据分割成报文段为单位的数据包进行管理，可靠性指能够准确可靠的传输给对方。一言以蔽之，TCP协议为了更容易传输大数据才把数据分割，而且TCP协议能够确认数据最终是否送达对方。\n确保数据能到达目标为了准确无误的将数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送后的情况置之不理，它一定会向对方确认是否成功送达，握手过程中使用了TCP的标志SYN和ACK。\n\n发送端首先发送一个带SYN标志的数据包给对方。\n接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。\n最后，发送端再回传一个带ACK标志的数据包，代表握手结束。\n若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。\n\n\n\n\n为什么不是二次，四次握手，而是三次？四次？很显然1.2和1.3 这两个步骤可以合并，只需要三次握手，可以提高连接的速度与效率。\n\n\n二次？现假定出现一种异常情况，即A发出的第一个请求连接报文段并没有丢失，而是在某些网络结点长时间滞留了，以至到连接释放以后的某个时间才到达B。本来这是一个已失效的报文段。但B收到此失效的连接请求报文段后，就误认为是A又发出一次新的连接请求。于是就向A发出确认报文段，同意建立连接。假定不采用三次握手，那么只要B发出确认，新的连接就建立了。\n由于现在A并没有发出建立请求的连接，因此不会理睬B的确认，也不会向B发送数据，但B却以为新的运输连接已经建立了，并一直等待A发来的数据。B的许多资源就这样白白浪费了。\n采用三次握手的办法可以防止上述现象发生。例如在刚才的情况下，A不会向B的确认发出确认。B由于收不到确认，就知道A并没有要求建立连接，所以就不会分配资源给这个连接\n\n\n\n\nHTTP 是不保存状态的协议HTTP 是一种不保存状态，即无状态（stateless）协议。HTTP 协议自 身不对请求和响应之间的通信状态进行保存。也就是说在 HTTP 这个 级别，协议对于发送过的请求或响应都不做持久化处理。\n虽然是无状态协议，但为了实现期望的保持状态功能，于是引入了Cookie 技术。有了 Cookie 再用 HTTP 协议通信，就可以管 理状态了。\n\n\n持久连接HTTP&#x2F;1.1 和一部分的HTTP&#x2F;1.0 想出了 持久连接（HTTP Persistent Connections，也称为 HTTP keep-alive 或 HTTP connection reuse）的方法。持久连接的特点是，只要任意一端 没有明确提出断开连接，则保持 TCP 连接状态。\n持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相 应提高了。\n\n持久连接的好处在于减少了 TCP 连接的重复建立和断开所造成的额 外开销，减轻了服务器端的负载。另外，减少开销的那部分时间，使 HTTP 请求和响应能够更早地结束，这样 Web 页面的显示速度也就相 应提高了。\n\n\n四次挥手：TCP连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。当有一方要关闭连接时，会发送指令告知对方，我要关闭连接了。这时对方会回一个ACK，此时一个方向的连接关闭。但是另一个方向仍然可以继续传输数据，等到发送完了所有的数据后，会发送一个FIN段来关闭此方向上的连接。接收方发送ACK确认关闭连接。\n\n\nHTTP的缺点\n通信使用明文（不加密），内容可能会被窃听\n\n不验证通信方的身份，因此有可能遭遇伪装\n无法证明报文的完整性，所以有可能已遭篡改\n对于 HTTP 来说，服务器也好，客户端也好，都是没有办法确认通信方的。因为很有可能并不是和原本预想的通信方在实际通信。 并且还需要考虑到接收到的报文在通信途中已经遭到篡改这一可能性。\n为了统一解决上述这些问题，需要在 HTTP 上再加入加密处理和认证 等机制。我们把添加了加密及认证机制的 HTTP 称为 HTTPS\n通信的加密一种方式就是将通信加密。HTTP 协议中没有加密机制，但可以通过和 SSL（Secure Socket Layer，安全套接层）或 TLS（Transport Layer Security，安全层传输协议）的组合使用， 加密 HTTP 的通信内容。\n用 SSL建立安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL组合使用的HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）。\n\n\nHTTP+ 加密 + 认证 + 完整性保护 &#x3D;HTTPS可以说HTTPS 是身披 SSL 外壳的 HTTP\nHTTPS 并非是应用层的一种新协议。只是 HTTP 通信接口部分用 SSL和TLS协议代 替而已。\n通常，HTTP 直接和 TCP 通信。当使用 SSL时，则演变成先和 SSL通信，再由 SSL和 TCP 通信了。简言之，所谓HTTPS，其实就是身披 SSL协议这层外壳的 HTTP。\n在采用 SSL后，HTTP 就拥有了 HTTPS 的加密、证书和完整性保护 这些功能。\n\n\nSSL&#x2F;TLS加密第一次访问采用非对称加解密（非对称指客户端和服务器都有自己的公钥和私钥）客户端访问服务器，\n服务器收到客户端访问返回服务器的公钥，\n客户端收到服务器的公钥，用服务器的公钥对客户端的公钥进行加密发送给服务器，\n服务器收到加密后的公钥，用服务器的私钥进行解密取得客户端的公钥，\n将session key用客户端的公钥进行加密发送给客户端，\n客户端用自己的私钥进行解密获取session key\n\n\n后续通信使用对称加解密（对称加密指客户端和服务器使用同一套公钥私钥）对session key加密后发送session key进行通信\n非对称加解密只是用于session key安全的在两者之间进行传递，因为非对称加解密的开销很大。session key是有时效性的\n\n\n加入了抓包软件后SSL&#x2F;TLS加密Charles对客户端来说是服务器，对服务器来说是客户端\n1.客户端去访问Charles，Charles去访问服务器\n2.服务器会给Charles发送服务器的公钥，Charles会给客户端发送Charles的公钥\n3.客户端用Charles的公钥对自己的公钥进行加密发送给Charles，Charles用服务器的公钥对自己的公钥进行加密发送给服务器\n4.服务器用自己的私钥解开得到Charles的公钥，Charles用自己的私钥解开得到客户端的公钥\n5.服务器得到Charles的公钥对session key加密发送给Charles，Charles用自己的私钥解开得到session key\n6.Charles把session key用客户端的公钥对session key加密后发送给客户端，客户端用自己的私钥解开得到session key到这里客户端，Charles，服务器的session key就统一了。\nCharles抓不到包打开Charles抓不到包，为什么导入Charles的证书之后，app抓包就正常了呢？\n\n有了Charles置于中间之后，本来c/s架构的通信过程会“分裂”为两个独立的通信过程，app本来验证的是服务器的证书，服务器的证书手机的根证书是认可的，直接内置的；但是分裂成两个独立的通信过程之后，app验证的是Charles的证书，它的证书手机根证书并不认可，它并不是由手机内置的权威根证书签发机构签发的，所以手机不认，然后app也不认；所以我们要把Charles的证书导入到手机根证书目录中去，这样手机就会认可，如果app没有进行额外的校验（比如在代码中对该证书进行校验，也就是SSL pinning系列API)的话，app也会直接认可接受。\n\n\n\n在高版本的安卓上，用户安装的证书不会直接安装到系统根证书目录中，需要root手机后将证书移动到系统根证书目录中去。\n 当Charles的证书安装到系统根目录中去之后，系统就会信任来自Charles的流量包了，我们的抓包过程就会回归正常\n 1.安装个人证书 通过VPN连接到Charles，然后用浏览器访问chls.pro&#x2F;ssl，会自动弹出安装个人证书。\n 个人证书安装在手机的 &#x2F;data&#x2F;misc&#x2F;user&#x2F;0&#x2F;cacerts-added 目录下\n 2.复制个人证书到系统目录（安卓8以上需要） cd /data/misc/user/0/cacerts-added/ mount -o remount,rw /systemmv * /etc/security/cacerts/ cd  /etc/security/cacerts/ls -alit mount -o remount,ro /system\n\n\nSSL Pinning（情况更少） \n 就是客户端并不会默认信任系统根证书目录中的证书，而是在代码里再加一层校验，这就是证书绑定机制——SSL pinning，如果这段代码的校验过不了，那么客户端还是会报证书错误。\n \n\n \n\nHttps客户端代码校验服务器证书 案例：滴答清单\n遇到这种情况的时候，有这两种方式，当然目标是一样的，都是hook住这段校验的代码，使这段判断的机制失效即可。\n\nhook住checkServerTrusted，将其所有重载都置空；\n\nfunction hook_ssl() &#123;    Java.perform(function() &#123;        var ClassName = &quot;com.android.org.conscrypt.Platform&quot;;        var Platform = Java.use(ClassName);        var targetMethod = &quot;checkServerTrusted&quot;;        var len = Platform[targetMethod].overloads.length;        console.log(len);        for(var i = 0; i &lt; len; ++i) &#123;            Platform[targetMethod].overloads[i].implementation = function () &#123;                console.log(&quot;class:&quot;, ClassName, &quot;target:&quot;, targetMethod, &quot; i:&quot;, i, arguments);                //printStack(ClassName + &quot;.&quot; + targetMethod);            &#125;        &#125;    &#125;);&#125;\n\n\n\n使用objection，直接将SSL pinning给disable掉  android sslpinning disable\n\n\n\n\n如果还有一些情况没有覆盖的话，可以来看看https://github.com/WooyunDota/DroidSSLUnpinning\n\n\n目录ObjectionUnpinningPlus增加了ObjectionUnpinning没覆盖到的锁定场景.(objection)\n\n使用方法1 attach : frida -U com.example.mennomorsink.webviewtest2 —no-pause -l hooks.js\n\n使用方法2 spawn : python application.py com.example.mennomorsink.webviewtest2\n\n\n\nObjectionUnpinningPlus hook list:\n\nSSLcontext(ART only)\n\nokhttp\n\nwebview\n\nXUtils(ART only)\n\nhttpclientandroidlib\n\nJSSE\n\nnetwork_security_config (android 7.0+)\n\nApache Http client (support partly)\n\nOpenSSLSocketImpl\n\nTrustKit\n\n\n\n\n应该可以覆盖到目前已知的所有种类的证书绑定了。\n\n\n服务器校验客户端证书（情况少） \n既然app客户端会校验服务器证书，那么服务器可不可能校验app客户端证书呢？答案是肯定的。\n\n单一通信已经分裂成两个互相独立的通信，这时候与服务器进行通信的已经不是app、而是Charles了，所以我们要将app中内置的证书导入到Charles中去。\n这个操作通常需要完成两项内容：\n\n找到证书文件\n找到证书密码\n\n\n\n\n\nfunction hook_KeyStore_load() &#123;    Java.perform(function () &#123;        var StringClass = Java.use(&quot;java.lang.String&quot;);        var KeyStore = Java.use(&quot;java.security.KeyStore&quot;);        KeyStore.load.overload(&#x27;java.security.KeyStore$LoadStoreParameter&#x27;).implementation = function (arg0) &#123;            //printStack(&quot;KeyStore.load1&quot;);            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));            console.log(&quot;KeyStore.load1:&quot;, arg0);            this.load(arg0);        &#125;;        KeyStore.load.overload(&#x27;java.io.InputStream&#x27;, &#x27;[C&#x27;).implementation = function (arg0, arg1) &#123;            //printStack(&quot;KeyStore.load2&quot;);            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));            console.log(&quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null);            this.load(arg0, arg1);        &#125;;        console.log(&quot;hook_KeyStore_load...&quot;);    &#125;);&#125;setImmediate(hook_KeyStore_load)\n \n找到证书文件很简单，一般apk进行解包，直接过滤搜索后缀名为p12的文件即可，一般常用的命令为 tree -NCfhl |grep -i p12，直接打印出p12文件的路径\n\n想要拿到密码也很简单，一般解密会调用现成的API，java.security.KeyStore ，直接使用frida打印出来，也可以hook系统文件库\n\n\n\n\nobjection -g cn.soulapp.android explore//android hooking watch class_method java.io.File.$init - -dump-args --dump-backtrace --dump-returnandroid hooking watch class_method java.io.File.$init - -dump-args\n\n有了证书和密码之后，就可以将其导入到抓包软件中\n\n\n\n\n一般HTTPS：大部分只采用客户端检验服务器\n\n双向绑定：很少会有服务器校验客户端\n\n\nSSL cert Pinning：更少（案例：趣充）\n\n\n推荐使用Postern+Charles组合进行抓包我们平时用代理的时候，都是通过给wifi设置http代理的方式进行抓包，只是在应用层抓包，所以会被很轻易的检测到和绕过的。\n 很多应用会通过\nSystem.getProperty(“http.proxyHost”)\nSystem.getProperty(“http.proxyPort”);\n这两个API来查看当前系统是否挂了http代理，会很轻松的让你的抓包失效。\n这时候只能用Frida或Xposed来hook这个接口、修改其返回值\n\n所以我们需要换一种方式来设置代理。就是设置vpn代理，vpn是属于网络层的，设置了vpn后，你的手机上ifconfig后会多一个tun0的接口，等于加了一个虚拟网卡，所有的流量都会从这走。应用层和传输层的请求都可以拿到，还不会被上面提及的两个api所检测。\n\n\n\n输入ip route show table 0 |grep defalut查看路由表\n路由表的第一条就指向了tun0，可以说开vpn的效果就和直连的效果一摸一样。\n","tags":["抓包"]},{"title":"SHA1原理分析及流程","url":"/posts/34274/","content":"SHA1介绍SHA实际上是一系列算法的统称，分别包括：SHA-1、SHA-224、SHA-256、SHA-384以及SHA-512。后面4中统称为SHA-2，事实上SHA-224是SHA-256的缩减版，SHA-384是SHA-512的缩减版。各中SHA算法的数据比较如下表，其中的长度单位均为位：\n\n\n\n类别\nMD5\nSHA-1\nSHA-224\nSHA-256\nSHA-384\nSHA-512\n\n\n\n消息摘要长度\n128位(bit) 或 32字节\n160位(bit)或40字节\n224位(bit)或56字节\n256位(bit)或64字节\n384位(bit)或96字节\n512位(bit)或128字节\n\n\n消息长度\n&#x2F;\n小于264位\n小于264位\n小于264位\n小于2128位\n小于2128位\n\n\n分组长度\n512bit\n512bit\n512bit\n512bit\n1024bit\n1024bit\n\n\n计算字长度\n32bit\n32bit\n32bit\n32bit\n64bit\n64bit\n\n\n计算步骤数\n64\n80\n64\n64\n80\n80\n\n\n\n\nSHA1哈希算法流程消息填充对于任意长度的明文，SHA1的明文分组过程与MD5相类似，首先需要对明文添加位数，使明文总长度为448（mod512）位。在明文后添加位的方法是第一个添加位是l，其余都是0。然后将真正明文的长度（没有添加位以前的明文长度）以64位表示，附加于前面已添加过位的明文后，此时的明文长度正好是512位的倍数。M的长度 mod 512 &#x3D; R，考虑R（R为输入消息长度按512bit进行分组后，最后一组的长度） \n\nR &lt; 448，在最后一组的末尾填充1个“1”及若干个“0”，使最后一组的位数达到448位；再在这448位的基础上填充64位，这64位是M的原始长度的[二进制]\n\n\n\n\n\n\n\nR &gt;&#x3D; 448，在最后一组的末尾填充1个“1”及若干个“0”，使最后一组位数达到512；再新增一组，添加448个“0”和64位M的原始长度的二进制表示。\n\n\n\n\n\n初始化模值A&#x3D;0x67452301B&#x3D;0xEFCDAB89C&#x3D;0x98BADCFED&#x3D;0x10325476E&#x3D;0xC3D2E1F0\n分组第一个512位分组进来后，以32位为一组，分别存储在W0 ，……，W15 中之后还要将这16份子明文分组扩充到80份子明文分组，我们记为W[k]（k&#x3D; 0, 1,……79），扩充的方法如下。\n分组扩展为80份Wt &#x3D; Mt , 当0≤t≤15Wt&#x3D;(Wt −16 ⊕ Wt −14 ⊕ Wt −8 ⊕ Wt −3)&lt;&lt;&lt;1    (16≤t≤79)“&lt;&lt;&lt;” 表示循环左移符号，上述中是循环左移1位。\n\n\n计算信息摘要Kt (0≤t≤19) &#x3D; 0x5A827999Kt (20≤t≤39) &#x3D; 0x6ED9EBA1Kt (40≤t≤59) &#x3D; 0x0x8F188CDCKt (60≤t≤79) &#x3D; 0x0xCA62C1D64轮80步的计算中使用到的函数和固定常熟如下表所示：\n\n\n\n计算轮次\n计算的步数\n计算函数\n计算常数\n\n\n\n第一轮\n0≤t≤19步\nft(B,C,D)&#x3D;(B&amp;C)&amp;#124;(~B&amp;D)\n_K_t&#x3D;0x5A827999\n\n\n第二轮\n20≤t≤39步\nft(B,C,D)&#x3D;B⊕C⊕D\n_K_t&#x3D;0x6ED9EBA1\n\n\n第三轮\n40≤t≤59步\nft(B,C,D)&#x3D;(B&amp;C)&amp;#124;(B&amp;D)&amp;#124;(C&amp;D)\n_K_t&#x3D;0x8F188CDC\n\n\n第四轮\n60≤t≤79步\nft(B,C,D)&#x3D;B⊕C⊕D\n_K_t&#x3D;0xCA62C1D6\n\n\n（&amp;是与（And），|是或（Or），~是非（Not），^是异或（Xor））\n\n\n\n\n\n\n\n\n\n&amp;\n与\n两个位都为1时，结果才为1\n\n\n|\n或\n两个位都为0时，结果才为0\n\n\n^\n异或\n两个位相同为0，相异为1\n\n\n~\n取反\n0变1，1变0\n\n\n&lt;&lt;&lt;\n循环左移\n将移出的低位放到该数的高位\n\n\n\n\n链接变量与初始链接变量进行求和运算SHA1有4轮运算，每一轮包括20个步骤，一共80步，最终产生160位的信息摘要，这160位的摘要存放在5个32位的链接变量中。在SHA1的4论运算中，虽然进行的就具体操作函数不同，但逻辑过程却是一致的。首先，定义5个变量，假设为H0、H1、H2、H3、H4，对其分别进行如下操作：（A）、将A左移5为与 函数的结果求和，再与对应的子明文分组、E以及计算常数求和后的结果赋予H0。（B）、将A的值赋予H1。（C）、将B左移30位，并赋予H2。（D）、将C的值赋予H3。（E）、将D的值赋予H4。（F）、最后将H0、H1、H2、H3、H4的值分别赋予A、B、C、DA &#x3D; H0 &#x3D; A&lt;&lt;&lt;5+ft(B,C,D)+E+Wt+KtB &#x3D; H1 &#x3D; AC &#x3D; H2 &#x3D; B&lt;&lt;&lt;30D &#x3D; H3 &#x3D; CE &#x3D; H4 &#x3D; D这一过程表示如下：\n\n\n加上初始化模值a &#x3D; H0+Ab &#x3D; H1+Bc &#x3D; H2+Cd &#x3D; H3+De &#x3D; H4+Eresult &#x3D; abcde经过4论80步计算后得到的结果，再与各链接变量的初始值求和，就得到了我们最终的信息摘要。而对于有多个明文分组的，则将前面所得到的结果作为初始值进行下一明文分组的计算，最后一组的512位分组经过80轮的操作后，最终产生的H0、H1、H2、H3、H4要加上一开始的A、B、C、D、E，及加完后最终的abcde即为消息M的hash值。\n整个sha1加密简要过程如下：（1） 将512位的明文分组划分为16个子明文分组，每个子明文分组为32位。（2） 申请5个32位的链接变量，记为A、B、C、D、E。（3） 16份子明文分组扩展为80份。（4） 80份子明文分组进行4轮运算。（5） 链接变量与初始链接变量进行求和运算。（6） 链接变量作为下一个明文分组的输入重复进行以上操作。（7） 最后，5个链接变量要加上一开始的模值，最终级联起来的数据就是SHA1摘要。\n\n\n例子：对409732112进行sha1409732112&#x3D;&#x3D;&gt;ASCII   34 30 39 37 33 32 31 31 32转为二进制就是 4*18 &#x3D; 72bit34 &#x3D;&#x3D;&gt; 0011 010030 &#x3D;&#x3D;&gt; 0011 000039 &#x3D;&#x3D;&gt; 0011 100137 &#x3D;&#x3D;&gt; 0011 011133 &#x3D;&#x3D;&gt; 0011 001132 &#x3D;&#x3D;&gt; 0011 001031 &#x3D;&#x3D;&gt; 0011 000131 &#x3D;&#x3D;&gt; 0011 000132 &#x3D;&#x3D;&gt; 0011 001072bit填充1000….到448bit， 填充1个1和375个00011 0100 0011 0000 0011 1001 0011 0111 0011 0011 0011 0010 0011 0001 0011 0001 0011 0010 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000对应16进制34 30 39 37 33 32 31 31 32 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00512bit - 448bit &#x3D; 64bit留的那64比特长度，用于填充长度信息，长度单位为比特64bit附加长度信息 （就是明文对应16进制的长度）00  …. 00 72（中间58个0, 明文72是十进制，需要转为十六进制）明文72bit+填充（10…）376bit+长度信息（00 00 …48）64bit &#x3D; 512bit34 30 39 37 33 32 31 31 32 80 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 48512bit &#x2F; 4 &#x3D; 128位16进制128分16组 &#x3D; 8位 （每组8位）W0 &#x3D; 0x 34 30 39 37W1 &#x3D; 0x 33 32 31 31 W2 &#x3D; 0x 32 80 00 00 W3 &#x3D; 0x 00 00 00 00…W14 &#x3D; 0x 00 00 00 00W15 &#x3D; 0x 00 00 00 48 扩展分组到80份\nWt&#x3D;( Wt − 16 ⊕ Wt −14 ⊕ Wt −8 ⊕ Wt −3)&lt;&lt;1    (16≤_t_≤79)这里手算前3个，最终80份程序生成W16 &#x3D; (W0⊕W2⊕W8⊕W13)&lt;&lt;1W17 &#x3D; (W1⊕W3⊕W9⊕W14)&lt;&lt;1W18 &#x3D; (W2⊕W4⊕W10⊕W15)&lt;&lt;1\nW0 &#x3D; 0011 0100 0011 0000 0011 1001 0011 0111W1 &#x3D; 0011 0011 0011 0010 0011 0001 0011 0001W2 &#x3D; 0011 0010 1000 0000 0000 0000 0000 0000W3&#x3D;0，W4&#x3D;0，W8&#x3D;0，W9&#x3D;0，W10&#x3D;0，W13&#x3D;0，W14 &#x3D; 0W15&#x3D; 0000 0000 0000 0000 0000 0000 0100 1000W16 &#x3D; (W0⊕W2)&lt;&lt;1&#x3D; 0000 1101 0110 0000 0111 0010 0110 1110 &#x3D; 0x 0D60726EW17 &#x3D; W1&lt;&lt;1&#x3D; 0110 0110 0110 0100 0110 0010 0110 0010 &#x3D; 0x 66646262W18 &#x3D; (W2⊕W15)&lt;&lt;1&#x3D; 0110 0101 0000 0000 0000 0000 1001 0000 &#x3D; 0x 65000090\n\n跟程序结果一致，下面直接输出结果W0 &#x3D; 0x34303937W1 &#x3D; 0x33323131W2 &#x3D; 0x32800000W3 &#x3D; 0x0W4 &#x3D; 0x0W5 &#x3D; 0x0W6 &#x3D; 0x0W7 &#x3D; 0x0W8 &#x3D; 0x0W9 &#x3D; 0x0W10 &#x3D; 0x0W11 &#x3D; 0x0W12 &#x3D; 0x0W13 &#x3D; 0x0W14 &#x3D; 0x0W15 &#x3D; 0x48W16 &#x3D; 0xd60726eW17 &#x3D; 0x66646262W18 &#x3D; 0x65000090W19 &#x3D; 0x1ac0e4dcW20 &#x3D; 0xccc8c4c4W21 &#x3D; 0xca000120W22 &#x3D; 0x3581c9b8W23 &#x3D; 0x99918919W24 &#x3D; 0x8ec0e69dW25 &#x3D; 0xa7cb57b4W26 &#x3D; 0xf9231313W27 &#x3D; 0x28000483W28 &#x3D; 0xd60726e0W29 &#x3D; 0x664624f6W30 &#x3D; 0x21c37eaaW31 &#x3D; 0x53e59ba6W32 &#x3D; 0x1cd612bW33 &#x3D; 0xf5595f41W34 &#x3D; 0x61c99c2W35 &#x3D; 0xf21b00a9W36 &#x3D; 0xb42ee9bbW37 &#x3D; 0x67966a1aW38 &#x3D; 0xd132a24cW39 &#x3D; 0xb3235961W40 &#x3D; 0x2371fd7eW41 &#x3D; 0x57415c75W42 &#x3D; 0x3437eaa1W43 &#x3D; 0x3e59bb45W44 &#x3D; 0x2957db08W45 &#x3D; 0xcc047fd6W46 &#x3D; 0x9eca0d11W47 &#x3D; 0x79908d1cW48 &#x3D; 0xd148f483W49 &#x3D; 0x9d921d19W50 &#x3D; 0xff2a2f89W51 &#x3D; 0xf5384aeaW52 &#x3D; 0xa3b31bcdW53 &#x3D; 0xcf36c649W54 &#x3D; 0x33623193W55 &#x3D; 0x7c83278aW56 &#x3D; 0x12704a2aW57 &#x3D; 0x8fd19775W58 &#x3D; 0x3d927355W59 &#x3D; 0x2a2b88a6W60 &#x3D; 0x37feb543W61 &#x3D; 0x8e608facW62 &#x3D; 0xad96814eW63 &#x3D; 0x5efe0599W64 &#x3D; 0x64e43d19W65 &#x3D; 0x95da8390W66 &#x3D; 0x7fea8510W67 &#x3D; 0xe9827238W68 &#x3D; 0x65ea391aW69 &#x3D; 0x847fd6feW70 &#x3D; 0xca0d119eW71 &#x3D; 0x908d18f9W72 &#x3D; 0x9ef3a531W73 &#x3D; 0xf45b1bbbW74 &#x3D; 0xca16b7ffW75 &#x3D; 0xa675a007W76 &#x3D; 0x17b22d58W77 &#x3D; 0x3defd669W78 &#x3D; 0x4a141b9dW79 &#x3D; 0x98376750\n80轮运算A &#x3D; 0x67452301 &#x3D; 0110 0111 0100 0101 0010 0011 0000 0001B &#x3D; 0xEFCDAB89 &#x3D; 1110 1111 1100 1101 1010 1011 1000 1001C &#x3D; 0x98BADCFE &#x3D; 1001 1000 1011 1010 1101 1100 1111 1110D &#x3D; 0x10325476 &#x3D; 0001 0000 0011 0010 0101 0100 0111 0110E &#x3D; 0xC3D2E1F0 &#x3D; 1100 0011 1101 0010 1110 0001 1111 0000\n\n\n\n计算轮次\n计算的步数\n计算函数\n计算常数\n\n\n\n第一轮\n0≤t≤19步\nft(B,C,D)&#x3D;(B&amp;C)&amp;#124;(~B&amp;D)\n_K_t&#x3D;0x5A827999\n\n\n第二轮\n20≤t≤39步\nft(B,C,D)&#x3D;B⊕C⊕D\n_K_t&#x3D;0x6ED9EBA1\n\n\n第三轮\n40≤t≤59步\nft(B,C,D)&#x3D;(B&amp;C)&amp;#124;(B&amp;D)&amp;#124;(C&amp;D)\n_K_t&#x3D;0x8F188CDC\n\n\n第四轮\n60≤t≤79步\nft(B,C,D)&#x3D;B⊕C⊕D\n_K_t&#x3D;0xCA62C1D6\n\n\n第一轮第一步A&lt;&lt;&lt;5 &#x3D;&#x3D;&gt; 1110 1000 1010 0100 0110 0000 0010 1100B&amp;C &#x3D; 1000 1000 1000 1000 1000 1000 1000 1000B&amp;D&#x3D; 0001 0000 0011 0010 0101 0100 0111 0110ft(B,C,D) &#x3D; (B&amp;C)|(B&amp;D) &#x3D; 1001 1000 1011 1010 1101 1100 1111 1110H0 &#x3D; 0x2D3E4D1EA（保留末8位）&#x3D; 0x D3E4D1EAH1 &#x3D; 0x67452301H2 &#x3D; 0x7BF36AE2H3 &#x3D; 0x98BADCFEH4 &#x3D; 0x10325476把H0-H4重新赋值给A,B,C,D,EA &#x3D; H0B &#x3D; H1C &#x3D; H2D &#x3D; H3E &#x3D; H4…第80轮A &#x3D; 0x135B4514 &#x3D; 0001 0011 0101 1011 0100 0101 0001 0100B &#x3D; 0xCE03E912 &#x3D; 1100 1110 0000 0011 1110 1001 0001 0010C &#x3D; 0xD50D5F9A &#x3D; 1101 0101 0000 1101 0101 1111 1001 1010D &#x3D; 0xD940C253 &#x3D; 1101 1001 0100 0000 1100 0010 0101 0011E &#x3D; 0x36F72811 &#x3D; 0011 0110 1111 0111 0010 1000 0001 0001\nA&lt;&lt;&lt;5 &#x3D; 0110 1011 0110 1000 1010 0010 1000 0010ft(B,C,D)&#x3D;B⊕C⊕D &#x3D; 1100 0010 0100 1110 0111 0100 1101 1011W79 &#x3D; 0x98376750K79 &#x3D; 0xCA62C1D6H0 &#x3D; 0xC7486894H1 &#x3D;  0x135B4514H2 &#x3D; 1011 0011 1000 0000 1111 1010 0100 0100 &#x3D; 0xB380FA44H3 &#x3D; 0xD50D5F9AH4 &#x3D; 0xD940C253 \n最后的H0-H4要加上一开始的模值a &#x3D; H0+A &#x3D; 0x2E8D8B95b &#x3D; H1+B &#x3D;0x0328F09Dc &#x3D; H2+C &#x3D; 0x4C3BD742d &#x3D; H3+D &#x3D; 0xE53FB410e &#x3D; H4+E &#x3D; 0x9D13A443abcde &#x3D; 2E8D8B950328F09D4C3BD742E53FB4109D13A443              2e8d8b950328f09d4c3bd742e53fb4109d13a443结果一致\npython实现sha1# 0xffffffff is used to make sure numbers dont go over 32def chunks(messageLength, chunkSize):    chunkValues = []    for i in range(0, len(messageLength), chunkSize):        chunkValues.append(messageLength[i:i + chunkSize])    return chunkValuesdef leftRotate(chunk, rotateLength):    return ((chunk &lt;&lt; rotateLength) | (chunk &gt;&gt; (32 - rotateLength))) &amp; 0xffffffffdef sha1Function(message):    # initial hash values    h0 = 0x67452301    h1 = 0xEFCDAB89    h2 = 0x98BADCFE    h3 = 0x10325476    h4 = 0xC3D2E1F0    messageLength = &quot;&quot;    # preprocessing    for char in range(len(message)):        messageLength += &#x27;&#123;0:08b&#125;&#x27;.format(ord(message[char]))    temp = messageLength    messageLength += &#x27;1&#x27;    while (len(messageLength) % 512 != 448):        messageLength += &#x27;0&#x27;    messageLength += &#x27;&#123;0:064b&#125;&#x27;.format(len(temp))    chunk = chunks(messageLength, 512)    for eachChunk in chunk:        words = chunks(eachChunk, 32)        w = [0] * 80        for n in range(0, 16):            w[n] = int(words[n], 2)        for i in range(16, 80):            # sha1            w[i] = leftRotate((w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]), 1)            # sha0            # w[i] = (w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16])            # Initialize hash value for this chunk:        a = h0        b = h1        c = h2        d = h3        e = h4        # main loop:        for i in range(0, 80):            if 0 &lt;= i &lt;= 19:                f = (b &amp; c) | ((~b) &amp; d)                k = 0x5A827999            elif 20 &lt;= i &lt;= 39:                f = b ^ c ^ d                k = 0x6ED9EBA1            elif 40 &lt;= i &lt;= 59:                f = (b &amp; c) | (b &amp; d) | (c &amp; d)                k = 0x8F1BBCDC            elif 60 &lt;= i &lt;= 79:                f = b ^ c ^ d                k = 0xCA62C1D6            a, b, c, d, e = ((leftRotate(a, 5) + f + e + k + w[i]) &amp; 0xffffffff, a, leftRotate(b, 30), c, d)        h0 = h0 + a &amp; 0xffffffff        h1 = h1 + b &amp; 0xffffffff        h2 = h2 + c &amp; 0xffffffff        h3 = h3 + d &amp; 0xffffffff        h4 = h4 + e &amp; 0xffffffff    return &#x27;%08x%08x%08x%08x%08x&#x27; % (h0, h1, h2, h3, h4)if __name__ == &#x27;__main__&#x27;:    plainText = &quot;409732112&quot;    sha1Hash = sha1Function(plainText)    print(sha1Hash)\n","tags":["算法"]},{"title":"ProtoBuf逆向之某公交app","url":"/posts/14763/","content":"上一篇是web端的ProtoBuf逆向，这篇就找了个app的ProtoBuf看看练练手目标app：aHR0cHM6Ly93d3cud2FuZG91amlhLmNvbS9hcHBzLzc0NTAxNjM&#x3D;\n抓包分析随便搜索一个线路点进去，看到请求头和响应都是加密的用jadx分析下请求头的加密参数request记住这里其他两个函数，有”&#x2F;protoc.Request.Sequence”，还引用了proto的包到这可以知道request的值是经过native函数加密后再由base64得到的。用ida打开native so文件，定位encode2函数!可以看到是用了aes_cbc_128加密，那就是需要拿到密钥和iv直接frida hook这两个函数\nfunction main()&#123;    Java.perform(function()&#123;        var ByteString = Java.use(&quot;com.android.okhttp.okio.ByteString&quot;);        var UtilsClass = Java.use(&quot;com.shjt.map.tool.Native&quot;);        UtilsClass.encode2.implementation = function (a)&#123;          console.log(&quot;入参: &quot;, ByteString.of(a).hex());          var value = this.encode2(a);          console.log(&#x27;结果: &#x27;, ByteString.of(value).hex());          return value;            &#125;        inline_hook()    &#125;)&#125;function inline_hook() &#123;    var libnative_lib_addr = Module.findBaseAddress(&quot;libnative.so&quot;);    if (libnative_lib_addr) &#123;        var aes_decrypt_cbc  = Module.findExportByName(&quot;libnative.so&quot;, &quot;_Z15aes_encrypt_cbcPKhjPhPKjiS0_&quot;)        var aes_key_setup = Module.getExportByName(&#x27;libnative.so&#x27;, &#x27;_Z13aes_key_setupPKhPji&#x27;);        var Native_encode2 = Module.getExportByName(&#x27;libnative.so&#x27;, &#x27;Java_com_shjt_map_tool_Native_encode2&#x27;);        Interceptor.attach(aes_key_setup, &#123;            onEnter:function(args)&#123;                console.log(&quot;================aes_key_setup=================&quot;)                console.log(&#x27;arg1:&#x27;,args[0].readByteArray(16))                console.log(&#x27;arg2:&#x27;,args[1].readByteArray(16))                console.log(&#x27;arg3:&#x27;,args[2].toInt32())            &#125;,            onLeave:function(retval)&#123;            &#125;        &#125;)        Interceptor.attach(aes_decrypt_cbc, &#123;            onEnter: function (args) &#123;                console.log(&quot;================aes_decrypt_cbc=================&quot;)                console.log(&#x27;arg1:&#x27;,args[0].readByteArray(16))                console.log(&#x27;arg2:&#x27;,args[1].toInt32())                console.log(&#x27;arg3:&#x27;,args[2].readByteArray(16))                console.log(&#x27;arg4:&#x27;,args[3].readByteArray(16))                console.log(&#x27;arg5:&#x27;,args[4].toInt32())                console.log(&#x27;arg6:&#x27;,args[5].readByteArray(16))            &#125;,            onLeave: function (retval) &#123;                 console.log(&quot;retval is :&quot;, retval)             &#125;        &#125;)    &#125;&#125;setImmediate(main);\n结果\n入参:  0a270a182f70726f746f632e526571756573742e53657175656e6365120b080112053930e8b7af1801================aes_key_setup=================arg1:            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF00000000  2f d3 02 8e 14 a4 5d 1f 8b 6e b0 b2 ad b7 ca af  /.....]..n......arg2:            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF00000000  39 39 37 34 20 49 ed f1 ff ff ff ff 00 00 00 00  9974 I..........arg3: 128================aes_decrypt_cbc=================arg1:            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF00000000  0a 27 0a 18 2f 70 72 6f 74 6f 63 2e 52 65 71 75  .&#x27;../protoc.Requarg2: 48arg3:            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF00000000  00 6f 6d 2f 61 6e 64 72 6f 69 64 2f 6f 6b 68 74  .om/android/okhtarg4:            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF00000000  8e 02 d3 2f 1f 5d a4 14 b2 b0 6e 8b af ca b7 ad  .../.]....n.....arg5: 128arg6:            0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF00000000  75 4c 8f d5 84 fa cf 62 10 37 6b 2b 72 b0 63 e4  uL.....b.7k+r.c.retval is : 0x1结果:  8d456e87c6801a2e18920732f80a1127e7a9548fd9f2f8b45edab8fd629e60bd804287b6fa4bb05fbc8b284ab0eb9783\n明文，密文有了iv和密钥就在这几个之间，两两组合试一试\n2f d3 02 8e 14 a4 5d 1f 8b 6e b0 b2 ad b7 ca af39 39 37 34 20 49 ed f1 ff ff ff ff 00 00 00 000a 27 0a 18 2f 70 72 6f 74 6f 63 2e 52 65 71 7500 6f 6d 2f 61 6e 64 72 6f 69 64 2f 6f 6b 68 748e 02 d3 2f 1f 5d a4 14 b2 b0 6e 8b af ca b7 ad75 4c 8f d5 84 fa cf 62 10 37 6b 2b 72 b0 63 e4\n所以这个aes是标准的算法，没经过魔改的，再把加密后的结果base64一下就是请求的参数了，过程算法知道了，那参数来源呢，是怎么得到的\n使用proto上面说了用了proto的包，看里面的函数过程，明文是经过了proto协议的才到aes加密那就0a270a182f70726f746f632e526571756573742e53657175656e6365120b080112053930e8b7af1801转成二进制写进文件，再用proto解码器解码看看\nimport binascii# hex字符串转二进制d = binascii.a2b_hex(&#x27;0a270a182f70726f746f632e526571756573742e53657175656e6365120b080112053930e8b7af1801&#x27;)with open(&quot;req.bin&quot;, &#x27;wb&#x27;) as f:    f.write(d)\nprotoc --decode_raw &lt; req.bin\n解码后得到\n1 &#123;  1: &quot;/protoc.Request.Sequence&quot;  2 &#123;    1: 1    2: &quot;90\\350\\267\\257&quot;    3: 1  &#125;&#125;\n果不其然，那接下来如何模拟发请求呢经过上一篇后，现在很快就能编写proto文件了\nsyntax = &quot;proto3&quot;;message Msg22 &#123;  int32 field1 = 1;  string field2 = 2;  int32 field3 = 3;&#125;message Msg11 &#123;  string field1 = 1;  Msg22 msg22 = 2;&#125;message SearchService&#123;  Msg11 msg11 = 1;&#125;\n编译成python版本\nprotoc --python_out=. ./req.proto\n目录下生成了req_pb2.py 拖入项目中，需要使用时就调用即可\nimport binasciiimport req_pb2 as pb# hex字符串转二进制# d = binascii.a2b_hex(&#x27;0a270a182f70726f746f632e526571756573742e53657175656e6365120b080112053930e8b7af1801&#x27;)# with open(&quot;req.bin&quot;, &#x27;wb&#x27;) as f:#     f.write(d)search_request = pb.SearchService.SearchRequest()  # 实例化对象search_request.msg11.field1 = &#x27;/protoc.Request.Sequence&#x27;search_request.msg11.msg22.field1 = 1search_request.msg11.msg22.field2 = &#x27;90路&#x27;search_request.msg11.msg22.field3 = 1# 序列化请求数据serialize_data = search_request.SerializeToString()# print(serialize_data)# 保存数据玮bin文件供后续对比使用with open(&#x27;my_req.bin&#x27;, mode=&quot;wb&quot;) as f:    f.write(serialize_data)\n运行后生成my_req.bin文件，跟原来的对比一下发送请求\nimport binasciifrom urllib.parse import quoteimport req_pb2 as pbimport requestsfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport base64def aes_encry(ori):    key = &#x27;2fd3028e14a45d1f8b6eb0b2adb7caaf&#x27;    iv = &#x27;754c8fd584facf6210376b2b72b063e4&#x27;    aes = AES.new(binascii.a2b_hex(key), AES.MODE_CBC, binascii.a2b_hex(iv))    return aes.encrypt(pad(ori, 16))def aes_decry(ori):    key = &#x27;2fd3028e14a45d1f8b6eb0b2adb7caaf&#x27;    iv = &#x27;754c8fd584facf6210376b2b72b063e4&#x27;    aes = AES.new(binascii.a2b_hex(key), AES.MODE_CBC, binascii.a2b_hex(iv))    return unpad(aes.decrypt(ori), 16)# hex字符串转二进制# d = binascii.a2b_hex(&#x27;0a270a182f70726f746f632e526571756573742e53657175656e6365120b080112053930e8b7af1801&#x27;)# with open(&quot;req.bin&quot;, &#x27;wb&#x27;) as f:#     f.write(d)search_request = pb.SearchService.SearchRequest()  # 实例化对象search_request.msg1.field1 = &#x27;/protoc.Request.Sequence&#x27;search_request.msg1.msg2.field1 = 1search_request.msg1.msg2.field2 = &#x27;90路&#x27;search_request.msg1.msg2.field3 = 1# 序列化请求数据serialize_data = search_request.SerializeToString()# print(serialize_data)# 保存数据玮bin文件供后续对比使用# with open(&#x27;my_req.bin&#x27;, mode=&quot;wb&quot;) as f:#     f.write(serialize_data)# 对序列化后的数据aes加密aes_data = aes_encry(serialize_data)# b64 aes加密数据b64_aes_data = base64.b64encode(aes_data)# 请求体post_data = &#x27;request=&#x27; + quote(b64_aes_data.decode(), safe=&#x27;&#x27;)+&#x27;%0A&#x27;header = &#123;    &#x27;Accept&#x27;: &#x27;application/json,application/xml,application/xhtml+xml,text/html;q=0.9,image/webp,*/*;q=0.8&#x27;,    &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;,    &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh&#x27;,    &#x27;Connection&#x27;: &#x27;keep-alive&#x27;,    &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=utf-8&#x27;,    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Linux; U; Android 6.0; zh-cn; Nexus 6P Build/MDA89D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30&#x27;,    &#x27;Host&#x27;: &#x27;lbs.jt.sh.cn:8082&#x27;&#125;url = &quot;http://lbs.jt.sh.cn:8082/app/rls/monitor&quot;response = requests.post(url, headers=header, data=post_data)print(response.text)\n运行后响应内容跟抓包的一样是加密的，用aes尝试解密解完后很像protobuf格式，写进bin文件，再用proto解码看看\ndecry_data = aes_decry(response.content)with open(&#x27;resp.bin&#x27;, mode=&quot;wb&quot;) as f:    f.write(decry_data)\nD:\\pythonProject\\xxxx&gt;protoc --decode_raw &lt; resp.bin1 &#123;  1: &quot;/protoc.Response.Dispatch&quot;  2 &#123;    1 &#123;      1: &quot;90\\350\\267\\257&quot;      2 &#123;        1 &#123;          1: &quot;05:00&quot;          2: &quot;23:41&quot;        &#125;        2: &quot;\\351\\235\\226\\345\\256\\207\\345\\215\\227\\350\\267\\257\\346\\216\\247\\346\\261\\237\\350\\267\\257&quot;        2: &quot;\\346\\216\\247\\346\\261\\237\\346\\226\\260\\346\\235\\221&quot;        2: &quot;\\351\\273\\204\\345\\205\\264\\350\\267\\257\\345\\233\\275\\346\\235\\203\\350\\267\\257&quot;        2: &quot;\\351\\273\\204\\345\\205\\264\\350\\267\\257\\345\\233\\275\\351\\241\\272\\350\\267\\257&quot;        2: &quot;\\344\\272\\224\\350\\247\\222\\345\\234\\272(\\347\\277\\224\\346\\256\\267\\350\\267\\257)&quot;        2: &quot;\\345\\233\\275\\345\\222\\214\\350\\267\\257\\346\\224\\277\\347\\253\\213\\350\\267\\257&quot;        2: &quot;\\346\\201\\222\\344\\273\\201\\350\\267\\257\\346\\270\\205\\346\\272\\220\\347\\216\\257\\350\\267\\257&quot;        2: &quot;\\344\\270\\226\\347\\225\\214\\350\\267\\257\\345\\233\\275\\345\\222\\214\\350\\267\\257&quot;        2: &quot;\\344\\270\\226\\347\\225\\214\\350\\267\\257\\346\\260\\221\\344\\272\\254\\350\\267\\257&quot;        2: &quot;\\351\\227\\270\\346\\256\\267\\350\\267\\257\\346\\256\\267\\350\\241\\214\\350\\267\\257&quot;        2: &quot;\\351\\227\\270\\346\\256\\267\\350\\267\\257\\345\\206\\233\\345\\267\\245\\350\\267\\257&quot;        2: &quot;\\345\\206\\233\\345\\267\\245\\350\\267\\257\\351\\227\\270\\345\\214\\227\\347\\224\\265\\345\\216\\202&quot;        2: &quot;\\351\\225\\277\\350\\210\\252\\351\\224\\232\\345\\234\\260&quot;        2: &quot;\\345\\206\\233\\345\\267\\245\\350\\267\\257\\351\\231\\210\\345\\256\\266\\345\\256\\205&quot;        2: &quot;\\345\\215\\227\\345\\274\\240\\345\\215\\216\\346\\265\\234(\\351\\200\\270\\344\\273\\231\\350\\267\\257)&quot;        2: &quot;\\345\\214\\227\\345\\274\\240\\345\\215\\216\\346\\265\\234(\\351\\200\\270\\344\\273\\231\\350\\267\\257)&quot;        2: &quot;\\346\\267\\236\\346\\273\\250\\350\\267\\257\\345\\220\\214\\346\\265\\216\\350\\267\\257&quot;        2: &quot;\\346\\260\\270\\346\\270\\205\\350\\267\\257\\346\\267\\236\\345\\256\\235\\350\\267\\257&quot;        2: &quot;\\346\\260\\270\\346\\270\\205\\350\\267\\257\\346\\260\\264\\344\\272\\247\\350\\267\\257&quot;        2: &quot;\\345\\217\\214\\345\\237\\216\\350\\267\\257\\346\\260\\270\\346\\270\\205\\350\\267\\257&quot;        2: &quot;\\346\\267\\236\\345\\256\\235\\350\\267\\257\\345\\217\\214\\345\\237\\216\\350\\267\\257&quot;        2: &quot;\\346\\267\\236\\345\\256\\235\\350\\267\\257\\346\\267\\236\\351\\235\\222\\350\\267\\257&quot;      &#125;      2 &#123;        1 &#123;          1: &quot;05:00&quot;          2: &quot;23:10&quot;        &#125;        2: &quot;\\346\\267\\236\\345\\256\\235\\350\\267\\257\\346\\267\\236\\351\\235\\222\\350\\267\\257&quot;        2: &quot;\\345\\217\\214\\345\\237\\216\\350\\267\\257\\346\\267\\236\\345\\256\\235\\350\\267\\257&quot;        2: &quot;\\346\\260\\270\\346\\270\\205\\350\\267\\257\\345\\217\\214\\345\\237\\216\\350\\267\\257&quot;        2: &quot;\\346\\260\\270\\346\\270\\205\\350\\267\\257\\346\\260\\264\\344\\272\\247\\350\\267\\257&quot;        2: &quot;\\346\\260\\270\\346\\270\\205\\350\\267\\257\\346\\267\\236\\345\\256\\235\\350\\267\\257&quot;        2: &quot;\\346\\267\\236\\346\\273\\250\\350\\267\\257\\345\\220\\214\\346\\263\\260\\350\\267\\257&quot;        2: &quot;\\351\\225\\277\\345\\276\\201\\346\\226\\260\\346\\235\\221&quot;        2: &quot;\\346\\267\\236\\346\\273\\250\\350\\267\\257\\346\\267\\236\\346\\273\\250\\346\\224\\257\\350\\267\\257&quot;        2: &quot;\\345\\214\\227\\345\\274\\240\\345\\215\\216\\346\\265\\234(\\351\\200\\270\\344\\273\\231\\350\\267\\257)&quot;        2: &quot;\\345\\215\\227\\345\\274\\240\\345\\215\\216\\346\\265\\234(\\351\\200\\270\\344\\273\\231\\350\\267\\257)&quot;        2: &quot;\\345\\206\\233\\345\\267\\245\\350\\267\\257\\351\\231\\210\\345\\256\\266\\345\\256\\205&quot;        2: &quot;\\351\\225\\277\\350\\210\\252\\351\\224\\232\\345\\234\\260&quot;        2: &quot;\\345\\206\\233\\345\\267\\245\\350\\267\\257\\351\\227\\270\\345\\214\\227\\347\\224\\265\\345\\216\\202&quot;        2: &quot;\\351\\227\\270\\346\\256\\267\\350\\267\\257\\345\\206\\233\\345\\267\\245\\350\\267\\257&quot;        2: &quot;\\351\\227\\270\\346\\256\\267\\350\\267\\257\\346\\256\\267\\350\\241\\214\\350\\267\\257&quot;        2: &quot;\\344\\270\\226\\347\\225\\214\\350\\267\\257\\346\\260\\221\\344\\272\\254\\350\\267\\257&quot;        2: &quot;\\344\\270\\226\\347\\225\\214\\350\\267\\257\\345\\233\\275\\345\\222\\214\\350\\267\\257&quot;        2: &quot;\\346\\201\\222\\344\\273\\201\\350\\267\\257\\346\\270\\205\\346\\272\\220\\347\\216\\257\\350\\267\\257&quot;        2: &quot;\\351\\225\\277\\346\\265\\267\\350\\267\\257\\351\\273\\221\\345\\261\\261\\350\\267\\257&quot;        2: &quot;\\345\\233\\275\\345\\222\\214\\350\\267\\257\\346\\224\\277\\351\\200\\232\\350\\267\\257&quot;        2: &quot;\\344\\272\\224\\350\\247\\222\\345\\234\\272(\\347\\277\\224\\346\\256\\267\\350\\267\\257)&quot;        2: &quot;\\344\\272\\224\\350\\247\\222\\345\\234\\272(\\351\\273\\204\\345\\205\\264\\350\\267\\257)&quot;        2: &quot;\\351\\273\\204\\345\\205\\264\\350\\267\\257\\345\\233\\275\\351\\241\\272\\350\\267\\257&quot;        2: &quot;\\351\\273\\204\\345\\205\\264\\350\\267\\257\\345\\233\\275\\346\\235\\203\\350\\267\\257&quot;        2: &quot;\\346\\216\\247\\346\\261\\237\\346\\226\\260\\346\\235\\221&quot;        2: &quot;\\351\\235\\226\\345\\256\\207\\345\\215\\227\\350\\267\\257\\346\\216\\247\\346\\261\\237\\350\\267\\257&quot;      &#125;    &#125;    2 &#123;      1: &quot;\\346\\262\\252A-30515D&quot;      2: &quot;15:26&quot;    &#125;    2 &#123;      1: &quot;\\346\\262\\252A-07660D&quot;      2: &quot;15:33&quot;    &#125;    2 &#123;      1: &quot;\\346\\262\\252A-33990D&quot;      2: &quot;15:41&quot;    &#125;  &#125;&#125;\n编写proto文件并编译\nsyntax = &quot;proto3&quot;; // 定义proto的版本message Msg1 &#123;  string field1 = 1;  Msg2 msg2 = 2;&#125;message Msg2 &#123;  repeated Msg3 msg3 = 1;  repeated Msg4 msg4 = 2;&#125;message Msg3 &#123;  string field1 = 1;  repeated Msg5 msg5 = 2;&#125;message Msg4 &#123;  string field1 = 1;  string field2 = 2;&#125;message Msg5 &#123;  Msg6 msg6 = 1;  repeated string field1 = 2;&#125;message Msg6 &#123;  string field1 = 1;  string field2 = 2;&#125;message SearchResponse &#123;  Msg1 msg1 = 1;&#125;\n完整代码\nimport binasciiimport jsonfrom urllib.parse import quotefrom google.protobuf.json_format import MessageToJsonimport req_pb2 as pbimport resp_pb2 as pb2import requestsfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport base64def aes_encry(ori):    key = &#x27;2fd3028e14a45d1f8b6eb0b2adb7caaf&#x27;    iv = &#x27;754c8fd584facf6210376b2b72b063e4&#x27;    aes = AES.new(binascii.a2b_hex(key), AES.MODE_CBC, binascii.a2b_hex(iv))    return aes.encrypt(pad(ori, 16))def aes_decry(ori):    key = &#x27;2fd3028e14a45d1f8b6eb0b2adb7caaf&#x27;    iv = &#x27;754c8fd584facf6210376b2b72b063e4&#x27;    aes = AES.new(binascii.a2b_hex(key), AES.MODE_CBC, binascii.a2b_hex(iv))    return unpad(aes.decrypt(ori), 16)# hex字符串转二进制# d = binascii.a2b_hex(&#x27;0a270a182f70726f746f632e526571756573742e53657175656e6365120b080112053930e8b7af1801&#x27;)# with open(&quot;req.bin&quot;, &#x27;wb&#x27;) as f:#     f.write(d)search_request = pb.SearchService()  # 实例化对象search_request.msg11.field1 = &#x27;/protoc.Request.Sequence&#x27;search_request.msg11.msg22.field1 = 1search_request.msg11.msg22.field2 = &#x27;90路&#x27;search_request.msg11.msg22.field3 = 1# 序列化请求数据serialize_data = search_request.SerializeToString()# print(serialize_data)# 保存数据玮bin文件供后续对比使用# with open(&#x27;my_req.bin&#x27;, mode=&quot;wb&quot;) as f:#     f.write(serialize_data)# 对序列化后的数据aes加密aes_data = aes_encry(serialize_data)# b64 aes加密数据b64_aes_data = base64.b64encode(aes_data)# 请求体post_data = &#x27;request=&#x27; + quote(b64_aes_data.decode(), safe=&#x27;&#x27;)+&#x27;%0A&#x27;header = &#123;    &#x27;Accept&#x27;: &#x27;application/json,application/xml,application/xhtml+xml,text/html;q=0.9,image/webp,*/*;q=0.8&#x27;,    &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;,    &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh&#x27;,    &#x27;Connection&#x27;: &#x27;keep-alive&#x27;,    &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=utf-8&#x27;,    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Linux; U; Android 6.0; zh-cn; Nexus 6P Build/MDA89D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30&#x27;,    &#x27;Host&#x27;: &#x27;lbs.jt.sh.cn:8082&#x27;&#125;url = &quot;http://lbs.jt.sh.cn:8082/app/rls/monitor&quot;response = requests.post(url, headers=header, data=post_data)# print(response.text)decry_data = aes_decry(response.content)# with open(&#x27;resp.bin&#x27;, mode=&quot;wb&quot;) as f:#     f.write(decry_data)# 使用proto编写文件root = pb2.SearchResponse()root.ParseFromString(decry_data)data = json.loads(MessageToJson(root))print(data)\n\n使用blackboxprotobuf还有一种更快的方式，使用blackboxprotobuf读取请求的二进制文件，通过blackboxprotobuf转为json，直接把关键词修改掉再转回去像响应内容的key只是一个符号，可以通过value大概知道它的含义就行了\nimport blackboxprotobufimport binasciiimport requestsfrom Crypto.Cipher import AESfrom Crypto.Util.Padding import pad, unpadimport base64from urllib.parse import quotedef aes_encry(ori):    key = &#x27;2fd3028e14a45d1f8b6eb0b2adb7caaf&#x27;    iv = &#x27;754c8fd584facf6210376b2b72b063e4&#x27;    aes = AES.new(binascii.a2b_hex(key), AES.MODE_CBC, binascii.a2b_hex(iv))    return aes.encrypt(pad(ori, 16))def aes_decry(ori):    key = &#x27;2fd3028e14a45d1f8b6eb0b2adb7caaf&#x27;    iv = &#x27;754c8fd584facf6210376b2b72b063e4&#x27;    aes = AES.new(binascii.a2b_hex(key), AES.MODE_CBC, binascii.a2b_hex(iv))    return unpad(aes.decrypt(ori), 16)with open(r&quot;req.bin&quot;, &quot;rb&quot;) as fp:    data = fp.read()    message, typedef = blackboxprotobuf.protobuf_to_json(data, message_type=None)    bus_data = blackboxprotobuf.decode_message(data, message_type=None)[0]    print(message)    print(bus_data)    print(typedef)    bus_data[&#x27;1&#x27;][&#x27;2&#x27;][&#x27;2&#x27;] = bytes(&#x27;90路&#x27;, &#x27;utf-8&#x27;)serializedata = blackboxprotobuf.encode_message(bus_data, message_type=typedef)print(serializedata)# 对序列化后的数据aes加密aesdata = aes_encry(serializedata)# b64 aes加密数据b64_aes_data = base64.b64encode(aesdata)# 抓取postdata = &#x27;request=&#x27; + quote(b64_aes_data.decode(), safe=&#x27;&#x27;) + &#x27;%0A&#x27;header = &#123;    &#x27;Accept&#x27;: &#x27;application/json,application/xml,application/xhtml+xml,text/html;q=0.9,image/webp,*/*;q=0.8&#x27;,    &#x27;Accept-Encoding&#x27;: &#x27;gzip, deflate&#x27;,    &#x27;Accept-Language&#x27;: &#x27;zh-CN,zh&#x27;,    &#x27;Connection&#x27;: &#x27;keep-alive&#x27;,    &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded; charset=utf-8&#x27;,    &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Linux; U; Android 6.0; zh-cn; Nexus 6P Build/MDA89D) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30&#x27;,    &#x27;Host&#x27;: &#x27;lbs.jt.sh.cn:8082&#x27;&#125;response = requests.post(url=&#x27;http://lbs.jt.sh.cn:8082/app/rls/monitor&#x27;, data=postdata, headers=header)decry_data = aes_decry(response.content)json_data, type_data = blackboxprotobuf.protobuf_to_json(decry_data, message_type=None)print(json_data)\n\n\n","tags":["protobuf","安卓逆向"]},{"title":"Ubuntu18.04 编译安卓6.0刷入Nexus 5","url":"/posts/4118/","content":"有台闲置的nexus 5，想着刷机，之前都是刷入编译好的系统包，就琢磨着自己编译安卓源码刷入。一开始用ubuntu22.04，各种踩坑，放弃了改为用ubuntu18.04资料链接：https://source.android.com/docs/setup/about/build-numbers?hl=zh-cn#platform-code-names-versions-api-levels-and-ndk-releaseshttps://source.android.com/docs/setup/build/running?hl=zh-cn#selecting-device-build\n环境配置安装和配置git\n$ sudo apt install git$ git config --global user.name &quot;Your Name&quot;$ git config --global user.email &quot;you@example.com&quot;\n更换软件源为清华\nsudo gedit /etc/apt/sources.list\n在文件最前面加入下面代码：\ndeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiversedeb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-proposed main restricted universe multiverse\n\n修改完成后，保存文件，执行\nsudo apt-get updatesudo apt-get upgrade\n\n安装依赖：\nsudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilibsudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-devsudo apt-get install git-core gnupg flex bison gperf build-essential sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilibsudo apt-get install libc6-dev-i386sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-devsudo apt-get install lib32z-dev ccachesudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4sudo apt-get install lib32stdc++6\n所需JDK：https://source.android.com/docs/setup/start/older-versions?hl=zh-cnJDK\n\nAndroid 7.0 - Android 8.0：\nUbuntu：OpenJDK 8\nMac OS X：JDK 8u45 或更高版本\n\n\nAndroid 5.x (Lollipop) - Android 6.0 (Marshmallow)：\nUbuntu：OpenJDK 7\nMac OS X：jdk-7u71-macosx-x64.dmg\n\n\n\nnexus 5官方只支持到 android-6.0.1_r77，这里用openJDK7，我给找好了链接：https://pan.baidu.com/s/1YMCsApMD_jeI5S7wmpJgTg 提取码：aupw将openJDK7解压到&#x2F;usr&#x2F;lib&#x2F;jvm这个目录下面，比如我的目录&#x2F;usr&#x2F;lib&#x2F;jvm&#x2F;openjdk-1.7.0_121打开&#x2F;etc&#x2F;profile文件:\nsudo gedit /etc/profile\n\n在末尾追加下面代码：\nexport JAVA_HOME=/usr/lib/jvm/openjdk-1.7.0_121export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH\n\n修改了&#x2F;etc&#x2F;profile文件需要 重启 才能生效，但使用下面命令可以在不重启的情况下在 当前 bash环境生效：验证\nsource /etc/profile\n\n 配置pythonUbuntu 18.04.6已内置python3，安装位置在&#x2F;usr&#x2F;bin&#x2F;python3.6AOSP 12及以上用python3，只需要建立一个python的链接\nsudo ln -s /usr/bin/python3 /usr/bin/python\nAOSP 12以下，需要安装python2\nsudo apt install python-minimalpython2 --version\n\npython2的安装路径为&#x2F;usr&#x2F;bin&#x2F;python2.7。因为系统中安装了多个python版本，需要使用update-alternatives来切换版本，update-alternatives是Linux上的一个版本管理工具\nsudo update-alternatives --install /usr/bin/python python /usr/bin/python2.7 1sudo update-alternatives --install /usr/bin/python python /usr/bin/python3.6 0\n\nupdate-alternatives后面按顺序共5个参数，其中：第一个参数–install表示向update-alternatives注册服务名。第二个参数&#x2F;usr&#x2F;bin&#x2F;python是注册的最终地址，以后管理就是管理这个软链第三个参数python为服务名第四个参数为被管理命令的绝对路径第五个参数为优先级，数字越大优先级越高配置完毕后，可以使用python –version查看当前使用的python版本\nzsk@ubuntu:~$ update-alternatives --display pythonpython - 自动模式  最佳链接版本为 /usr/bin/python2.7 链接目前指向 /usr/bin/python2.7  链接 python 指向 /usr/bin/python/usr/bin/python2.7 - 优先级 1/usr/bin/python3.6 - 优先级 0\n后面如果需要切换python版本，执行如下命令\nzsk@ubuntu:~$ sudo update-alternatives --config python有 2 个候选项可用于替换 python (提供 /usr/bin/python)。  选择       路径              优先级  状态------------------------------------------------------------* 0            /usr/bin/python2.7   1         自动模式  1            /usr/bin/python2.7   1         手动模式  2            /usr/bin/python3.6   0         手动模式要维持当前值[*]请按&lt;回车键&gt;，或者键入选择的编号：\n如果需要安装对应版本的pippython3安装pip（先切换到python3下）\nsudo apt install python3-pip\npython2安装pip\nsudo apt-get install curl  #安装curl下载工具sudo curl https://bootstrap.pypa.io/pip/2.7/get-pip.py -o get-pip.py  #下载安装脚本sudo python get-pip.py  #运行安装脚本\n安装repo上面是谷歌官方的地址，如果下载不了，可以使用下面清华镜像地址\ncurl https://mirrors.tuna.tsinghua.edu.cn/git/git-repo &gt; ~/bin/repo\n初始化repo和manifest仓库\nrepo init -u https://aosp.tuna.tsinghua.edu.cn/platform/manifest -b android-6.0.0_r1 --depth=1\n后面记得加–depth&#x3D;1，这样就会只拉最新的git版本。而不是把所有版本都拉下来。不然会有几百G大如果提示无法连接到 gerrit.googlesource.com，repo的运行过程中会尝试访问官方的git源更新自己，如果想使用tuna的镜像源进行更新，可以将如下内容复制到你的~&#x2F;.bashrc里 \nexport REPO_URL=&#x27;https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/&#x27;\n同步\nrepo sync\n下载驱动需要下载对应的驱动https://developers.google.com/android/drivers#hammerheadm4b30z适用于 Android 6.0.0 (MRA58K) 的 Nexus 5 (GSM&#x2F;LTE) 二进制文件\n\n\n\n硬件组件\n公司\n下载\nSHA-256 校验和\n\n\n\nNFC、蓝牙、Wi-Fi\nBroadcom\nLink\n4009c98b916f679a96cc9d9459b811498e198c478b656652537fd7d705d28acc\n\n\n摄像头、传感器、音频\nLG\nLink\n42bca1a416903020f7e90bf1cc8651fa6b045b6137291dc21bfe5cf3626424ea\n\n\n图形、GSM、摄像头、GPS、传感器、媒体、DSP、USB\nQualcomm\nLink\n489df79f864abdc4947f39f45923b7999589db49a40dcd3c180d8cd924b73ae3\n\n\nwget https://dl.google.com/dl/android/aosp/broadcom-hammerhead-mra58k-bed5b700.tgzwget https://dl.google.com/dl/android/aosp/lge-hammerhead-mra58k-25d00e3d.tgzwget https://dl.google.com/dl/android/aosp/qcom-hammerhead-mra58k-ff98ab07.tgz\n下载后解压得到三个shell脚本文件，放到源码的根目录中依次执行这三个脚本文件，这里要注意，三个脚本文件的作用是生成驱动文件，但是在执行操作前，它会让你阅读相关协议，你必须一直按enter键一行一行往下读，更不能一键摁到底，因为程序在最后会让你输入“I ACCEPT”，如果你一键摁到底，也就是说最后一步也摁enter键的话它就会执行默认操作，即不接受此协议，那生成驱动文件的操作就不会执行。\n开始编译修改 源码目录&#x2F;art&#x2F;build&#x2F;Android.common_build.mk 文件，定位到75行，将下面的代码：\nifneq ($(WITHOUT_HOST_CLANG),true)改为ifeq ($(WITHOUT_HOST_CLANG),false) //对应问题3\n如果之前编译过，删除所有以前编译操作的已有输出\nmake clobbermake clean\n\n在 .bashrc文件末尾添加：export USE_CCACHE &#x3D; 1， 只要编译过aosp，执行过这一句代码，以后再编译aosp，就不用再执行了echo export USE_CCACHE=1 &gt;&gt; ~/.bashrc \n为了提高编译效率，设置编译器高速缓存prebuilts/misc/linux-x86/ccache/ccache -M 100G\n初始化编译环境 sourcesource build/envsetup.sh\n运行lunch命令选择编译目标\n\n\n\n\n变体\n说明\n\n\n\neng\n这是默认变种安装带有 eng 或 debug 标记的模块。除了带有标记的模块之外，还会根据产品定义文件安装相应模块。ro.secure&#x3D;0ro.debuggable&#x3D;1ro.kernel.android.checkjni&#x3D;1adb 默认处于启用状态。\n\n\nuser\n打算作为最终发布版本的变体。安装带有 user 标记的模块。除了带有标记的模块之外，还会根据产品定义文件安装相应模块。ro.secure&#x3D;1ro.debuggable&#x3D;0adb 默认处于停用状态。\n\n\nuserdebug\n与 user 相同，但以下几点除外：还会安装带有 debug 标记的模块。ro.debuggable&#x3D;1adb 默认处于启用状态。\n\n\nhttps://source.android.com/docs/setup/build/running#selecting-device-build\n\n\n\n-\n-\n-\n\n\n\nNexus 6P\nangler\naosp_angler-userdebug\n\n\nNexus 5X\nbullhead\naosp_bullhead-userdebug\n\n\nNexus 6\nshamu\naosp_shamu-userdebug\n\n\nNexus Player\nfugu\naosp_fugu-userdebug\n\n\nNexus 9\nvolantis (flounder)\naosp_flounder-userdebug\n\n\nNexus 5 (GSM&#x2F;LTE)\nhammerhead\naosp_hammerhead-userdebug\n\n\nlunch// 1. aosp_arm-eng不会生成我们需要的5个文件，17. aosp_hammerhead-userdebug可以\nexport LC_ALL=C //对应问题2\n查看CPU核心数：\ncat /proc/cpuinfo | grep processor\n花了两个半小时编译完成\nmake_ext4fs -s -T -1 -S out/target/product/hammerhead/root/file_contexts -L system -l 1073741824 -a system out/target/product/hammerhead/obj/PACKAGING/systemimage_intermediates/system.img out/target/product/hammerhead/system out/target/product/hammerhead/systemCreating filesystem with parameters:    Size: 1073741824    Block size: 4096    Blocks per group: 32768    Inodes per group: 8192    Inode size: 256    Journal blocks: 4096    Label: system    Blocks: 262144    Block groups: 8    Reserved block group size: 63Created filesystem with 1718/65536 inodes and 105291/262144 blocksInstall system fs image: out/target/product/hammerhead/system.imgout/target/product/hammerhead/system.img+out/target/product/hammerhead/obj/PACKAGING/recovery_patch_intermediates/recovery_from_boot.p maxsize=1096212480 blocksize=135168 total=416118221 reserve=11083776#### make completed successfully (02:27:25 (hh:mm:ss)) ####\n\n编译后输出的文件都放在了源码根目录下的 &#x2F;out&#x2F;target&#x2F;product&#x2F;hammerhead&#x2F;可以在该目录下面找到boot.img、system.img、recovery.img、cache.img、userdata.img五个镜像文件，这表示编译成功，这也是刷机需要的文件。\n问题1：Export includes file: frameworks/base/tools/aidl/Android.mk -- out/host/linux-x86/obj/EXECUTABLES/aidl_intermediates/export_includesbuild/core/binary.mk:609: recipe for target &#x27;out/host/linux-x86/obj/EXECUTABLES/aidl_intermediates/aidl_language_y.cpp&#x27; failedmake: *** [out/host/linux-x86/obj/EXECUTABLES/aidl_intermediates/aidl_language_y.cpp] Error 127make: *** 正在等待未完成的任务....Lex: aidl &lt;= frameworks/base/tools/aidl/aidl_language_l.lNotice file: frameworks/base/tools/aidl/NOTICE -- out/host/linux-x86/obj/NOTICE_FILES/src//bin/aidl.txtflex-2.5.39: loadlocale.c:130:_nl_intern_locale_data: ?? &#x27;cnt &lt; (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))&#x27; ???build/core/binary.mk:646: recipe for target &#x27;out/host/linux-x86/obj/EXECUTABLES/aidl_intermediates/aidl_language_l.cpp&#x27; failedmake: *** [out/host/linux-x86/obj/EXECUTABLES/aidl_intermediates/aidl_language_l.cpp] 已放弃 (core dumped)注: 某些输入文件使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。注: 某些输入文件使用了未经检查或不安全的操作。注: 有关详细信息, 请使用 -Xlint:unchecked 重新编译。make failed to build some targets (02:10 (mm:ss))\n执行: make -j8 update-api\n问题2：Lex: aidl &lt;= frameworks/base/tools/aidl/aidl_language_l.lflex-2.5.39: loadlocale.c:130:_nl_intern_locale_data: ?? &#x27;cnt &lt; (sizeof (_nl_value_type_LC_TIME) / sizeof (_nl_value_type_LC_TIME[0]))&#x27; ???build/core/binary.mk:646: recipe for target &#x27;out/host/linux-x86/obj/EXECUTABLES/aidl_intermediates/aidl_language_l.cpp&#x27; failedmake: *** [out/host/linux-x86/obj/EXECUTABLES/aidl_intermediates/aidl_language_l.cpp] 已放弃 (core dumped)\n编译前：export LC_ALL&#x3D;C\n问题3：clang: error: linker command failed with exit code 1 (use -v to see invocation)build/core/host_shared_library_internal.mk:51: recipe for target &#x27;out/host/linux-x86/obj/lib/libart.so&#x27; failedmake: *** [out/host/linux-x86/obj/lib/libart.so] Error 1\n修改 源码目录&#x2F;art&#x2F;build&#x2F;Android.common_build.mk 文件，定位到75行，将下面的代码：ifneq ($(WITHOUT_HOST_CLANG),true)改为ifeq ($(WITHOUT_HOST_CLANG),false)\n将镜像刷入Nexus5在源码根目录下输入以下命令：\nadb reboot bootloader\n随后手机就会进入recovery模式。执行 fastboot oem unlock 解锁bootloader，如果已经解锁，启动界面的google图标下有一把打开的锁。开始刷机：\nsudo fastboot -w flashall\n如果遇到 error: ANDROID_PRODUCT_OUT not set执行 $ export ANDROID_PRODUCT_OUT&#x3D;&#x2F;home&#x2F;zsk&#x2F;bin&#x2F;out&#x2F;target&#x2F;product&#x2F;hammerhead或者进到 &#x2F;home&#x2F;zsk&#x2F;bin&#x2F;out&#x2F;target&#x2F;product&#x2F;hammerhead 目录下，执行刷入5个镜像文件\nsudo fastboot flash recovery recovery.imgsudo fastboot flash boot boot.imgsudo fastboot flash system system.imgsudo fastboot flash cache cache.imgsudo fastboot flash userdata userdata.imgsudo fastboot reboot\n","tags":["刷机"]},{"title":"flutter案例抓包-猿人学app","url":"/posts/39224/","content":"这是猿人学App第七题flutter案例直接抓包看一下，直接抓不到。关闭抓包就正常\n既然说了是flutter，可以参考这两篇文章\n\n一种基于frida和drony的针对flutter抓包的方法\nBypass SSL pinning on flutter app\n\n文章里面也说了Flutter是Google使用Dart语言开发的移动应用开发框架，由于Dart使用Mozilla的NSS库生成并编译自己的Keystore，导致我们就不能通过将代理CA添加到系统CA存储来绕过SSL验证。为了解决这个问题，就必需要研究libflutter.so。写脚本，在运行时将返回函数改为true即可绕过证书链检查实现抓包。文章内容各位就自己看，我们直接上手解压apk，用ida打开libflutter.so在ida中的strings搜索字符串ssl_client跟进去可以找到并定位函数为sub_393DA4，也可以按x看它的引用，也是函数sub_393DA4，跟进去找到ssl_client的引用位置，往上找到函数sub_393DA4头部字节定位，针对64位flutter.so的hook代码示例如下，地址不再需要+1。把上面的头部字节替换到pattern里\nfunction hook_ssl_verify_result(address) &#123;    Interceptor.attach(address, &#123;        onEnter: function (args) &#123;            console.log(&quot;Disabling SSL validation&quot;)        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;Retval: &quot; + retval);            retval.replace(0x1);        &#125;    &#125;);&#125;function hookFlutter() &#123;    var m = Process.findModuleByName(&quot;libflutter.so&quot;);    var pattern = &quot;FF C3 01 D1 FD 7B 01 A9 FC 6F 02 A9 FA 67 03 A9 F8 5F 04 A9 F6 57 05 A9 F4 4F 06 A9 08 0A 80 52&quot;;    var res = Memory.scan(m.base, m.size, pattern, &#123;        onMatch: function (address, size) &#123;            console.log(&#x27;[+] ssl_verify_result found at: &#x27; + address.toString());            hook_ssl_verify_result(address);        &#125;,        onError: function (reason) &#123;            console.log(&#x27;[!] There was an error scanning memory&#x27;);        &#125;,        onComplete: function () &#123;            console.log(&quot;All done&quot;)        &#125;    &#125;);&#125;\n开启脚本后，抓包就正常了\n","tags":["抓包"]},{"title":"frida备忘录","url":"/posts/37757/","content":"frida hook某个类下所有方法Java.perform(function () &#123;    travel(&#x27;com.xxx.xxx&#x27;)&#125;)function printstack() &#123;    console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()))&#125;function travel(className) &#123;    var NetContent = Java.use(className)    //1.得到这个类下面的所有方法    var Methods = NetContent.class.getDeclaredMethods()    //2.遍历所有的方法    Methods.forEach(function (Method) &#123;        //得到这个方法的所有重载 ovelroads        var methodName = Method.getName()        var overloads = NetContent[methodName].overloads        //遍历重载        overloads.forEach(function (overload) &#123;            var prot = &#x27;(&#x27;            overload.argumentTypes.forEach(function (argumentType) &#123;                prot += argumentType.className + &#x27;,&#x27;            &#125;)            prot += &#x27;)&#x27;            overload.implementation = function () &#123;                console.log(&#x27;----------------------------------&#x27;)                console.log(className + &#x27;.&#x27; + methodName + prot)                printstack()                for (var i = 0; i &lt; arguments.length; i++) &#123;                    console.log(&#x27;argument:&#x27; + JSON.stringify(arguments[i]))                &#125;                var ret = this[methodName].apply(this, arguments)                console.log(methodName + &#x27;return:&#x27; + JSON.stringify(ret))                return ret            &#125;        &#125;)    &#125;)&#125;\n\nhookEventtrace所有的mOnClickListener，hook它们的onClick函数，实现点到哪里，定位到哪个类的功能。\nvar jclazz = null;var jobj = null;function getObjClassName(obj) &#123;    if (!jclazz) &#123;        var jclazz = Java.use(&quot;java.lang.Class&quot;);    &#125;    if (!jobj) &#123;        var jobj = Java.use(&quot;java.lang.Object&quot;);    &#125;    return jclazz.getName.call(jobj.getClass.call(obj));&#125;function watch(obj, mtdName) &#123;    var listener_name = getObjClassName(obj);    var target = Java.use(listener_name);    if (!target || !mtdName in target) &#123;        return;    &#125;    // send(&quot;[WatchEvent] hooking &quot; + mtdName + &quot;: &quot; + listener_name);    target[mtdName].overloads.forEach(function (overload) &#123;        overload.implementation = function () &#123;            //send(&quot;[WatchEvent] &quot; + mtdName + &quot;: &quot; + getObjClassName(this));            console.log(&quot;[WatchEvent] &quot; + mtdName + &quot;: &quot; + getObjClassName(this))            return this[mtdName].apply(this, arguments);        &#125;;    &#125;)&#125;function OnClickListener() &#123;    Java.perform(function () &#123;        //以spawn启动进程的模式来attach的话        Java.use(&quot;android.view.View&quot;).setOnClickListener.implementation = function (listener) &#123;            if (listener != null) &#123;                watch(listener, &#x27;onClick&#x27;);            &#125;            return this.setOnClickListener(listener);        &#125;;        //如果frida以attach的模式进行attch的话        Java.choose(&quot;android.view.View$ListenerInfo&quot;, &#123;            onMatch: function (instance) &#123;                instance = instance.mOnClickListener.value;                if (instance) &#123;                    console.log(&quot;mOnClickListener name is :&quot; + getObjClassName(instance));                    watch(instance, &#x27;onClick&#x27;);                &#125;            &#125;,            onComplete: function () &#123;            &#125;        &#125;)    &#125;)&#125;setImmediate(OnClickListener);\n\n系统库常用算法hookfunction printstack() &#123;    console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()))&#125;Java.perform(function () &#123;    console.log(&#x27;enter&#x27;)    var Base64 = Java.use(&#x27;android.util.Base64&#x27;)    var ByteString = Java.use(&quot;com.android.okhttp.okio.ByteString&quot;);    var secretKeySpec = Java.use(&#x27;javax.crypto.spec.SecretKeySpec&#x27;);    secretKeySpec.$init.overload(&#x27;[B&#x27;, &#x27;java.lang.String&#x27;).implementation = function (a, b) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.$init(a, b);        console.log(&quot;算法名：&quot; + b + &quot;|str密钥:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a));        console.log(&quot;算法名：&quot; + b + &quot;|Hex密钥:&quot; + ByteString.of(a).hex());        return result;    &#125;    var DESKeySpec = Java.use(&#x27;javax.crypto.spec.DESKeySpec&#x27;);    DESKeySpec.$init.overload(&#x27;[B&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.$init(a);        var bytes_key_des = this.getKey();        console.log(&quot;des密钥  |str &quot; + Java.use(&#x27;java.lang.String&#x27;).$new(bytes_key_des));        console.log(&quot;des密钥  |hex &quot; + ByteString.of(bytes_key_des).hex());        return result;    &#125;    DESKeySpec.$init.overload(&#x27;[B&#x27;, &#x27;int&#x27;).implementation = function (a, b) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.$init(a, b);        var bytes_key_des = this.getKey();        console.log(&quot;des密钥  |str &quot; + Java.use(&#x27;java.lang.String&#x27;).$new(bytes_key_des));        console.log(&quot;des密钥  |hex &quot; + ByteString.of(bytes_key_des).hex());        return result;    &#125;    var mac = Java.use(&#x27;javax.crypto.Mac&#x27;);    mac.getInstance.overload(&#x27;java.lang.String&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.getInstance(a);        console.log(&quot;算法名：&quot; + a);        return result;    &#125;    mac.update.overload(&#x27;[B&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        this.update(a);        console.log(&quot;update:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a))    &#125;    mac.update.overload(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;).implementation = function (a, b, c) &#123;        console.log(&quot;======================================&quot;);        printstack();        this.update(a, b, c)        console.log(&quot;update:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a) + &quot;|&quot; + b + &quot;|&quot; + c);    &#125;    mac.doFinal.overload().implementation = function () &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.doFinal();        console.log(&quot;mac doFinal结果: |str  :&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(result));        console.log(&quot;mac doFinal结果: |hex  :&quot; + ByteString.of(result).hex());        console.log(&quot;mac doFinal结果: |base64  :&quot; + Base64.encodeToString(result, 0));        return result;    &#125;    mac.doFinal.overload(&#x27;[B&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.doFinal(a);        console.log(&quot;doFinal参数: |str  :&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a));        console.log(&quot;doFinal结果: |str  :&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(result));        console.log(&quot;doFinal结果: |hex  :&quot; + ByteString.of(result).hex());        console.log(&quot;doFinal结果: |base64  :&quot; + Base64.encodeToString(result, 0));        return result;    &#125;    var md = Java.use(&#x27;java.security.MessageDigest&#x27;);    md.getInstance.overload(&#x27;java.lang.String&#x27;, &#x27;java.lang.String&#x27;).implementation = function (a, b) &#123;        console.log(&quot;======================================&quot;);        printstack();        console.log(&quot;算法名：&quot; + a);        return this.getInstance(a, b);    &#125;    md.getInstance.overload(&#x27;java.lang.String&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        console.log(&quot;算法名：&quot; + a);        return this.getInstance(a);    &#125;    md.update.overload(&#x27;[B&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        console.log(&quot;update:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a))        return this.update(a);    &#125;    md.update.overload(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;).implementation = function (a, b, c) &#123;        console.log(&quot;======================================&quot;);        printstack();        console.log(&quot;update:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a) + &quot;|&quot; + b + &quot;|&quot; + c);        return this.update(a, b, c);    &#125;    md.digest.overload().implementation = function () &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.digest();        console.log(&quot;digest11结果:&quot; + ByteString.of(result).hex());        console.log(&quot;digest结果:&quot; + Base64.encodeToString(result, 0));        return result;    &#125;    md.digest.overload(&#x27;[B&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        console.log(&quot;digest参数:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a));        var result = this.digest(a);        console.log(&quot;digest结果:&quot; + ByteString.of(result).hex());        console.log(&quot;digest结果:&quot; + Base64.encodeToString(result, 0));        return result;    &#125;    var ivParameterSpec = Java.use(&#x27;javax.crypto.spec.IvParameterSpec&#x27;);    ivParameterSpec.$init.overload(&#x27;[B&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.$init(a);        console.log(&quot;iv向量: |str:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a));        console.log(&quot;iv向量: |hex:&quot; + ByteString.of(a).hex());        return result;    &#125;    var cipher = Java.use(&#x27;javax.crypto.Cipher&#x27;);    cipher.getInstance.overload(&#x27;java.lang.String&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.getInstance(a);        console.log(&quot;模式填充:&quot; + a);        return result;    &#125;    cipher.init.overload(&#x27;int&#x27;, &#x27;java.security.Key&#x27;).implementation = function (a, b) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.init(a, b);        if (N_ENCRYPT_MODE == a) &#123;            console.log(&quot;init  | 加密模式&quot;);        &#125; else if (N_DECRYPT_MODE == a) &#123;            console.log(&quot;init  | 解密模式&quot;);        &#125;        var bytes_key = b.getEncoded();        console.log(&quot;init key:&quot; + &quot;|str密钥:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(bytes_key));        console.log(&quot;init key: |base64  :&quot; + Base64.encodeToString(bytes_key, 0));        console.log(&quot;init key:&quot; + &quot;|Hex密钥:&quot; + ByteString.of(bytes_key).hex());        return result;    &#125;    cipher.init.overload(&#x27;int&#x27;, &#x27;java.security.cert.Certificate&#x27;).implementation = function (a, b) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.init(a, b);        if (N_ENCRYPT_MODE == a) &#123;            console.log(&quot;init  | 加密模式&quot;);        &#125; else if (N_DECRYPT_MODE == a) &#123;            console.log(&quot;init  | 解密模式&quot;);        &#125;        return result;    &#125;    cipher.init.overload(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.spec.AlgorithmParameterSpec&#x27;).implementation = function (a, b, c) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.init(a, b, c);        if (N_ENCRYPT_MODE == a) &#123;            console.log(&quot;init  | 加密模式&quot;);        &#125; else if (N_DECRYPT_MODE == a) &#123;            console.log(&quot;init  | 解密模式&quot;);        &#125;        var bytes_key = b.getEncoded();        console.log(&quot;init key:&quot; + &quot;|str密钥:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(bytes_key));        console.log(&quot;init key: |base64  :&quot; + Base64.encodeToString(bytes_key, 0));        console.log(&quot;init key:&quot; + &quot;|Hex密钥:&quot; + ByteString.of(bytes_key).hex());        return result;    &#125;    cipher.init.overload(&#x27;int&#x27;, &#x27;java.security.cert.Certificate&#x27;, &#x27;java.security.SecureRandom&#x27;).implementation = function (a, b, c) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.init(a, b, c);        if (N_ENCRYPT_MODE == a) &#123;            console.log(&quot;init  | 加密模式&quot;);        &#125; else if (N_DECRYPT_MODE == a) &#123;            console.log(&quot;init  | 解密模式&quot;);        &#125;        return result;    &#125;    cipher.init.overload(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.SecureRandom&#x27;).implementation = function (a, b, c) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.init(a, b, c);        if (N_ENCRYPT_MODE == a) &#123;            console.log(&quot;init  | 加密模式&quot;);        &#125; else if (N_DECRYPT_MODE == a) &#123;            console.log(&quot;init  | 解密模式&quot;);        &#125;        var bytes_key = b.getEncoded();        console.log(&quot;init key:&quot; + &quot;|str密钥:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(bytes_key));        console.log(&quot;init key: |base64  :&quot; + Base64.encodeToString(bytes_key, 0));        console.log(&quot;init key:&quot; + &quot;|Hex密钥:&quot; + ByteString.of(bytes_key).hex());        return result;    &#125;    cipher.init.overload(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.AlgorithmParameters&#x27;).implementation = function (a, b, c) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.init(a, b, c);        if (N_ENCRYPT_MODE == a) &#123;            console.log(&quot;init  | 加密模式&quot;);        &#125; else if (N_DECRYPT_MODE == a) &#123;            console.log(&quot;init  | 解密模式&quot;);        &#125;        var bytes_key = b.getEncoded();        console.log(&quot;init key:&quot; + &quot;|str密钥:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(bytes_key));        console.log(&quot;init key: |base64  :&quot; + Base64.encodeToString(bytes_key, 0));        console.log(&quot;init key:&quot; + &quot;|Hex密钥:&quot; + ByteString.of(bytes_key).hex());        return result;    &#125;    cipher.init.overload(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.AlgorithmParameters&#x27;, &#x27;java.security.SecureRandom&#x27;).implementation = function (a, b, c, d) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.init(a, b, c, d);        if (N_ENCRYPT_MODE == a) &#123;            console.log(&quot;init  | 加密模式&quot;);        &#125; else if (N_DECRYPT_MODE == a) &#123;            console.log(&quot;init  | 解密模式&quot;);        &#125;        var bytes_key = b.getEncoded();        console.log(&quot;init key:&quot; + &quot;|str密钥:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(bytes_key));        console.log(&quot;init key: |base64  :&quot; + Base64.encodeToString(bytes_key, 0));        console.log(&quot;init key:&quot; + &quot;|Hex密钥:&quot; + ByteString.of(bytes_key).hex());        return result;    &#125;    cipher.init.overload(&#x27;int&#x27;, &#x27;java.security.Key&#x27;, &#x27;java.security.spec.AlgorithmParameterSpec&#x27;, &#x27;java.security.SecureRandom&#x27;).implementation = function (a, b, c, d) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.update(a, b, c, d);        if (N_ENCRYPT_MODE == a) &#123;            console.log(&quot;init  | 加密模式&quot;);        &#125; else if (N_DECRYPT_MODE == a) &#123;            console.log(&quot;init  | 解密模式&quot;);        &#125;        var bytes_key = b.getEncoded();        console.log(&quot;init key:&quot; + &quot;|str密钥:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(bytes_key));        console.log(&quot;init key: |base64  :&quot; + Base64.encodeToString(bytes_key, 0));        console.log(&quot;init key:&quot; + &quot;|Hex密钥:&quot; + ByteString.of(bytes_key).hex());        return result;    &#125;    cipher.update.overload(&#x27;[B&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.update(a);        console.log(&quot;======================================&quot;);        console.log(&quot;update:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a));        return result;    &#125;    cipher.update.overload(&#x27;[B&#x27;, &#x27;int&#x27;, &#x27;int&#x27;).implementation = function (a, b, c) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.update(a, b, c);        console.log(&quot;update:&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a) + &quot;|&quot; + b + &quot;|&quot; + c);        return result;    &#125;    cipher.doFinal.overload().implementation = function () &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.doFinal();        console.log(&quot;doFinal结果: |str  :&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(result));        console.log(&quot;doFinal结果: |hex  :&quot; + ByteString.of(result).hex());        console.log(&quot;doFinal结果: |base64  :&quot; + Base64.encodeToString(result, 0));        return result;    &#125;    cipher.doFinal.overload(&#x27;[B&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.doFinal(a);        console.log(&quot;doFinal参数: |str  :&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(a));        console.log(&quot;doFinal参数: |base64  :&quot; + Base64.encodeToString(a, 0));        console.log(&quot;doFinal结果: |str  :&quot; + Java.use(&#x27;java.lang.String&#x27;).$new(result));        console.log(&quot;doFinal结果: |hex  :&quot; + ByteString.of(result).hex());        console.log(&quot;doFinal结果: |base64  :&quot; + Base64.encodeToString(result, 0));        return result;    &#125;    var x509EncodedKeySpec = Java.use(&#x27;java.security.spec.X509EncodedKeySpec&#x27;);    x509EncodedKeySpec.$init.overload(&#x27;[B&#x27;).implementation = function (a) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.$init(a);        console.log(&quot;RSA密钥:&quot; + Base64.encodeToString(a, 0));        return result;    &#125;    var rSAPublicKeySpec = Java.use(&#x27;java.security.spec.RSAPublicKeySpec&#x27;);    rSAPublicKeySpec.$init.overload(&#x27;java.math.BigInteger&#x27;, &#x27;java.math.BigInteger&#x27;).implementation = function (a, b) &#123;        console.log(&quot;======================================&quot;);        printstack();        var result = this.$init(a, b);        console.log(&quot;RSA密钥N:&quot; + a.toString(16));        console.log(&quot;RSA密钥E:&quot; + b.toString(16));        return result;    &#125;&#125;)","tags":["frida"]},{"title":"python调用js的几种方式","url":"/posts/53763/","content":"1.PyExecJS安装依赖pip3 install PyExecJS新建add.js文件\nfunction add(a,b)&#123;    return a+b;&#125;\n\npy文件去调用\nimport execjswith open(&#x27;add.js&#x27;, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f:    js_code = f.read()context = execjs.compile(js_code)result = context.call(&quot;add&quot;, 2, 3) // 参数一为函数名，参数二和三为函数的参数print(result)\n运行结果：\n5\n\n\n2.js2py#安装依赖库pip3 install js2py还是上面的add.js文件python调用\nimport js2pywith open(&#x27;add.js&#x27;, &#x27;r&#x27;, encoding=&#x27;UTF-8&#x27;) as f:    js_code = f.read()context = js2py.EvalJs()context.execute(js_code)result = context.add(&quot;1&quot;, &quot;2&quot;)print(result)\n\n\n3.Node.js实际上是使用 Python 的os.popen执行 node 命令，执行 JS 脚本首先，确保本地已经安装了 Node.js 环境对js代码添加打印\nfunction add(a,b)&#123;    return Number(a)+Number(b);&#125;console.log(add(process.argv[2], process.argv[3]));  // 运行脚本传进来的参数\n\n用python调用控制台方式去使用\nimport osnodejs = os.popen(&#x27;node add.js &#x27;+&#x27;2&#x27;+&#x27; &#x27;+&#x27;3&#x27;)m = nodejs.read()nodejs.close()print(m)\n\n或者使用另一种方式\nfunction add(a,b)&#123;    return Number(a)+Number(b);&#125;// console.log(add(process.argv[2], process.argv[3]));//新增一个导出函数（node方式）module.exports.init = function (arg1, arg2) &#123;    //调用函数，并返回    console.log(add(arg1, arg2));&#125;;\n\nimport oscmd = &#x27;node -e &quot;require(\\\\&quot;%s\\\\&quot;).init(%s,%s)&quot;&#x27; % (&#x27;./add.js&#x27;, 2, 3)pipeline = os.popen(cmd)result = pipeline.read()print(result)\n\n\n4.node服务用node做一个服务，提供api还是add.js文件\nfunction add(a,b)&#123;    return Number(a)+Number(b);&#125;module.exports =  &#123;    add: function (arg1, arg2) &#123;        return add(arg1, arg2);    &#125;&#125;;\n\n新建add_api.js下载 express 和 body-parser 两个包\nvar express = require(&#x27;express&#x27;)var app = express()var func = require(&#x27;./add.js&#x27;)  // 导入js模块，并命名为funcvar bodyParser = require(&#x27;body-parser&#x27;);  // 导入请求体解析器// 调整参数大小限制，否则会提示参数过大。app.use(bodyParser.urlencoded(&#123;limit: &#x27;50mb&#x27;, extended: true&#125;));// 设置路由app.post(&#x27;/add&#x27;, function(req, res) &#123;    // 获取请求的真实IP\tvar ip = req.headers[&#x27;x-real-ip&#x27;] ? req.headers[&#x27;x-real-ip&#x27;] : req.ip.replace(/::ffff:/, &#x27;&#x27;);\t// 获取请求时间\tvar time = new Date().toString().replace(/\\+0800.*/, &#x27;&#x27;);\t// 打印请求时间、IP、方法、路由\tconsole.log(&#x27;INFO:&#x27;, time, ip, req.method, req.originalUrl, &#x27;200 OK!&#x27;);\t// 获取POST请求的formdata\tlet result = req.body;\t// let code = result.code;    // let seed = result.seed;    // let ts = result.ts;    console.log(&quot;result: &quot;, result);\tconsole.log(&quot;num1: &quot;, result.num1);\tconsole.log(&quot;num2: &quot;, result.num2);\t// 调用cook模块中的get_cookie方法，该方法需要提前module.exports导出\tvar response = func.add(result.num1, result.num2);\t// 设置响应头，如果不设置，通过asyncio_requests请求的res.json()会报错，因为它是根据响应头解析json数据\t// 而requests可以直接使用res.json()解析，因为它是根据响应信息解析\tres.set(&#x27;Content-Type&#x27;, &#x27;application/json&#x27;)\t// 将JSON后的数据返回客户端\tres.send(JSON.stringify(&#123;&quot;result&quot;: response&#125;));&#125;);app.listen(8919, () =&gt; &#123;\tconsole.log(&quot;开启服务，端口8919&quot;, new Date().toString().replace(/\\+0800.*/, &#x27;&#x27;))&#125;)\n\n运行，用python写个post请求\nimport requestsresponse = requests.post(&quot;http://127.0.0.1:8919/add&quot;, data=&#123;&quot;num1&quot;: 2, &quot;num2&quot;: 3&#125;)print(response.text)\n运行结果:\n&#123;&quot;result&quot;: 5&#125;\n\n","tags":["js"]},{"title":"unidbg补获取系统属性","url":"/posts/42662/","content":"\n什么叫获取系统属性？Build类第一种 NDK中最常见的方式是通过JNI调用 ， 通过JNI调用JAVA方法获取本机的属性和信息，是最常见的做法，除了Build类，常见的还有 System.getProperty和Systemproperties.get等API。    Unidbg补环境过程中，最好补而且不会遗漏的就是这一类，因为Unidbg会给出清楚的报错，你没法对它置之不理。  \njclass androidBuildClass = env-&gt;FindClass(&quot;android/os/Build&quot;);jfieldID SERIAL = env-&gt;GetStaticFieldID(androidBuildClass, &quot;SERIAL&quot;,&quot;Ljava/lang/String;&quot;);jstring serialNum = (jstring) env-&gt;GetStaticObjectField(androidBuildClass,SERIAL);\n\nsystem_property_get第二种常见方式是通过system_property_get 函数获取系统属性也是常见做法  \nchar *key = &quot;ro.build.id&quot;;char value[PROP_VALUE_MAX] = &#123;0&#125;;__system_property_get(key, value);\n 这类环境缺失容易被大家忽视，因为没有日志提示，即使src&#x2F;test&#x2F;resources&#x2F;log4j.properties中日志全 开，也不会打印相关信息。  \n通过文件访问 第三个常见方式是通过文件访问，比如读取&#x2F;proc&#x2F;pid&#x2F;maps，此种情况，Unidbg会提供日志输出，但 经常被大家忽视，事实上，不少朋友初学Unidbg时除了JAVA环境的报错，其他日志信息都不去管。  \npopen() 第四个常见方式是通过popen()管道从shell中获取系统属性，其效果可以理解成在NDK中使用adb shell，popen参数一就是shell命令，返回值是一个fd文件描述符，可以read其内容，其中内容就是adb shell执行该命令应该返回的内容。  \nchar value[PROP_VALUE_MAX] = &#123;0&#125;;std::string cmd = &quot;getprop ro.build.id&quot;;FILE* file = popen(cmd.c_str(), &quot;r&quot;);fread(value, PROP_VALUE_MAX, 1, file);pclose(file);\n\n\ngetenv函数第五个常见方式是通过 getenv函数 获取进程环境变量，首先，Android系统层面存在一些默认的环境变 量，除此之外，样本可以设置自己进程内的环境变量。因此，样本可以在Native层获取系统环境变量或 者自身JAVA层设置的环境变量。  我们可以通过ADB 查看环境变量有哪些，也可以查看环境变量的值。   \nC:\\Users\\pr0214&gt;adb shellbullhead:/ $ exportANDROID_ASSETSANDROID_BOOTLOGOANDROID_DATAANDROID_ROOTANDROID_SOCKET_adbdANDROID_STORAGEASEC_MOUNTPOINTBOOTCLASSPATHDOWNLOAD_CACHEEXTERNAL_STORAGEHOMEHOSTNAMELOGNAMEPATHSHELLSYSTEMSERVERCLASSPATHTERMTMPDIRUSERbullhead:/ $ echo $HOME/bullhead:/ $ echo $ANDROID_DATA/databullhead:/ $ echo $SYSTEMSERVERCLASSPATH/system/framework/services.jar:/system/framework/ethernetservice.jar:/system/framework/wifiservice.jar:/system/framework/com.android.location.provider.jarbullhead:/ $ echo $PATH/sbin:/system/sbin:/system/bin:/system/xbin:/vendor/bin:/vendor/xbinbullhead:/ $\n\n 第六个常见方式是使用系统调用获取相关属性，不管是通过syscall函数还是内联汇编，都属此类。 常见的比如uname系统调用  \n\n uname - 获取当前内核的名称和信息返回的信息是一个结构体  \n\nstruct utsname &#123;char sysname[]; /* 操作系统名称 (例如 &quot;Linux&quot;) */char nodename[]; /* &quot;一些实现了的网络”内的名称*/char release[]; /* 操作系统版本 (例如 &quot;2.6.28&quot;)*/char version[]; /* 操作系统发布日期 */char machine[]; /* 硬件标识符 */#ifdef _GNU_SOURCEchar domainname[]; /* NIS或YP域名 */#endif&#125;;\n 日志全开的情况下，系统调用的相关调用会被全部打印， Unidbg的uname系统调用实现是个很好也很简单的检测点，十分规范的表明了自己是Unidbg。  \nprotected int uname(Emulator&lt;?&gt; emulator) &#123;    RegisterContext context = emulator.getContext();    Pointer buf = context.getPointerArg(0);    if (log.isDebugEnabled()) &#123;        log.debug(&quot;uname buf=&quot; + buf);    &#125;    final int SYS_NMLN = 65;    Pointer sysName = buf.share(0);    sysName.setString(0, &quot;Linux&quot;); /* Operating system name (e.g., &quot;Linux&quot;) */    Pointer nodeName = sysName.share(SYS_NMLN);    nodeName.setString(0, &quot;localhost&quot;); /* Name within &quot;some implementation-defined network&quot; */    Pointer release = nodeName.share(SYS_NMLN);    release.setString(0, &quot;1.0.0-unidbg&quot;); /* Operating system release (e.g., &quot;2.6.28&quot;) */    Pointer version = release.share(SYS_NMLN);    version.setString(0, &quot;#1 SMP PREEMPT Thu Apr 19 14:36:58 CST 2018&quot;); /* Operating system version */    Pointer machine = version.share(SYS_NMLN);    machine.setString(0, &quot;armv8l&quot;); /* Hardware identifier */    Pointer domainName = machine.share(SYS_NMLN);    domainName.setString(0, &quot;localdomain&quot;); /* NIS or YP domain name */    return 0;&#125;\n 以上这些是较为常见的获取系统属性的方式，  \n如何解决？__system_property_get的处理一般运行报IO错误，继承IOResolver实现文件重定向接口，打上自己的日志\n\n lilac path:&#x2F;dev&#x2F;propertieslilac path:&#x2F;proc&#x2F;stat  \n\n一般这前两个文件访问，不需要管，这是libc初始化的内部逻辑   文件访问处理好了，接下来用第二种的方式，是__system_property_get 这个函数的处理 ，此Unidbg 在src&#x2F;main&#x2F;java&#x2F;com&#x2F;github&#x2F;unidbg&#x2F;linux&#x2F;android 目录下有相 关类对它进行了Hook和封装，我们可以直接拿来用  \nSystemPropertyHook systemPropertyHook = new SystemPropertyHook(emulator);systemPropertyHook.setPropertyProvider(new SystemPropertyProvider() &#123;    @Override    public String getProperty(String key) &#123;        System.out.println(&quot;lilac Systemkey:&quot;+key);        switch (key)&#123;        &#125;        return &quot;&quot;;    &#125;;&#125;);memory.addHookListener(systemPropertyHook);\n\nlilac Systemkey:ro.serialnolilac Systemkey:ro.product.manufacturerlilac Systemkey:ro.product.brandlilac Systemkey:ro.product.model\n\n 通过adb shell 获取这些信息，一 一填入正确的值，建议使用Unidbg时，对应的测试机Android版本为 6.0，这样或许可以避免潜在的麻烦。  \nC:\\Users\\zsk&gt;adb shellangler:/ $ suangler:/ # getprop ro.serialno84B5T15A04002645angler:/ # getprop ro.product.manufacturerHuaweiangler:/ # getprop ro.product.brandgoogleangler:/ # getprop ro.product.modelNexus 6Pangler:/ #\n// 注册绑定IO重定向emulator.getSyscallHandler().addIOResolver(this);SystemPropertyHook systemPropertyHook = new SystemPropertyHook(emulator);systemPropertyHook.setPropertyProvider(new SystemPropertyProvider() &#123;    @Override    public String getProperty(String key) &#123;        System.out.println(&quot;lilac Systemkey:&quot;+key);        switch (key)&#123;            case &quot;ro.serialno&quot;: &#123;                return &quot;84B5T15A04002645&quot;;            &#125;            case &quot;ro.product.manufacturer&quot;:                return &quot;Huawei&quot;;            case &quot;ro.product.brand&quot;: &#123;                return &quot;google&quot;;            &#125;            case &quot;ro.product.model&quot;: &#123;                return &quot;Nexus 6P&quot;;            &#125;        &#125;        return &quot;&quot;;    &#125;;&#125;);memory.addHookListener(systemPropertyHook);// 创建Android虚拟机vm = emulator.createDalvikVM(new File(&quot;xxx.apk&quot;));\n\npopen的处理接下来是第四种和第五种， 管popen和getenv，它俩都是libc里的函数，所以放一起说。我的想法是Hook这两个函数， 如果产生调用就打印日志 ， 基于 Unidbg原生Hook封装的各种Hook。 \n\nHOOK时机要在什么时候？这个样本的popen调用发生在目标函数中，如果发生在init中呢？ \n我们通过HOOK得到了其参数，那怎么给它返回正确的值呢？\n\n避免so存在init_proc 函数，或者init_array非空，需要在Loadlibrary加载so文件前面开始Hook，为了实现这个目标，我们提前将libc加载进Unidbg内存中。\nDalvikModule dmLibc = vm.loadLibrary(new File(&quot;unidbg-android/src/main/resources/android/sdk23/lib/libc.so&quot;), true);Module moduleLibc = dmLibc.getModule();// HOOK popenint popenAddress = (int) moduleLibc.findSymbolByName(&quot;popen&quot;).getAddress();// 函数原型：FILE *popen(const char *command, const char *type);emulator.attach().addBreakPoint(popenAddress, new BreakPointCallback() &#123;    @Override    public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;        RegisterContext registerContext = emulator.getContext();        String command = registerContext.getPointerArg(0).getString(0);        System.out.println(&quot;lilac popen command:&quot;+command);        return true;    &#125;&#125;);\n addBreakPoint 我们一般用于下断点，添加回调，在命中断点时打印输出popen的参数1(即传给shell的 命令)，并设置返回值为true，即做完打印程序继续跑，不用真断下来。  \n第一个问题解决， 第二个问题，怎么给它合适的返回值呢？  \n\n 其实下面奇怪的报错就是popen导致的，popen返回的是文件描述符 。 NR &#x3D; 190，190是什么系统调用？Unidbg尚未实现  \n 查一下表 https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#arm-32_bit_EABI而Unidbg提供了一种在底层修复和实现popen函数的法子。  接着是 uname -a\nangler:/ # uname -aLinux localhost 3.10.73-g33ace82f84b #1 SMP PREEMPT Fri Oct 13 04:41:33 UTC 2017 aarch64\n\n首先实现自己的ARM32SyscallHandler，完整代码如下，你可以把它当成固定讨论，它是针对 popen报错的官方解决方案。 \npackage com.bailong.qtt;import com.github.unidbg.Emulator;import com.github.unidbg.arm.context.EditableArm32RegisterContext;import com.github.unidbg.linux.ARM32SyscallHandler;import com.github.unidbg.linux.file.ByteArrayFileIO;import com.github.unidbg.linux.file.DumpFileIO;import com.github.unidbg.memory.SvcMemory;import com.github.unidbg.pointer.UnidbgPointer;import com.sun.jna.Pointer;import java.util.concurrent.ThreadLocalRandom;public class qttSyscallHandler extends ARM32SyscallHandler &#123;    public qttSyscallHandler(SvcMemory svcMemory) &#123;        super(svcMemory);    &#125;    @Override    protected boolean handleUnknownSyscall(Emulator&lt;?&gt; emulator, int NR) &#123;        switch (NR)&#123;            case 190:                vfork(emulator);                return true;            case 114:                wait4(emulator);                return true;        &#125;        return super.handleUnknownSyscall(emulator, NR);    &#125;    private void wait4(Emulator&lt;?&gt; emulator) &#123;        EditableArm32RegisterContext context = (EditableArm32RegisterContext) emulator.getContext();        int pid = context.getR0Int();        UnidbgPointer wstatus = context.getR1Pointer();        int options = context.getR2Int();        Pointer rusage = context.getR3Pointer();        System.out.println(&quot;wait4 pid=&quot; + pid + &quot;, wstatus=&quot; + wstatus + &quot;, options=0x&quot; + Integer.toHexString(options) + &quot;, rusage=&quot; + rusage);    &#125;    private void vfork(Emulator&lt;?&gt; emulator) &#123;        EditableArm32RegisterContext context = (EditableArm32RegisterContext) emulator.getContext();        int childPid = emulator.getPid() + ThreadLocalRandom.current().nextInt(256);        System.out.println(&quot;vfork pid=&quot; + childPid);        context.setR0(childPid);    &#125;    protected int pipe2(Emulator&lt;?&gt; emulator) &#123;        EditableArm32RegisterContext context = (EditableArm32RegisterContext) emulator.getContext();        Pointer pipefd = context.getPointerArg(0);        int flags = context.getIntArg(1);        int write = getMinFd();        this.fdMap.put(write, new DumpFileIO(write));        int read = getMinFd();        // stdout中写入popen command 应该返回的结果        String stdout = &quot;Linux localhost 3.10.73-g33ace82f84b #1 SMP PREEMPT Fri Oct 13 04:41:33 UTC 2017 aarch64&quot;;        this.fdMap.put(read, new ByteArrayFileIO(0, &quot;pipe2_read_side&quot;, stdout.getBytes()));        pipefd.setInt(0, read);        pipefd.setInt(4, write);        System.out.println(&quot;pipe2 pipefd=&quot; + pipefd + &quot;, flags=0x&quot; + flags + &quot;, read=&quot; + read + &quot;, write=&quot; + write + &quot;, stdout=&quot; + stdout);        context.setR0(0);        return 0;    &#125;&#125;\n解释一下为什么不直接补在ARM32SyscallHandler中？因为Unidbg并没有真正实现wait4和fork这两个 系统调用，只不过对于popen而言，用上述方式可以“凑合用”，既然不是完美的实现，自然不能放到 ARM32SyscallHandler中去，免得出大问题。  \n 在pipe2中注释下的stdout中传入正确返回值即可，比如uname -a就是，需要注意，结果都i要加换行 符，这是shell结果的返回习惯。\n 接下来让我们的emulator使用我们自己的syscallHandler，emulator &#x3D; new AndroidARMEmulator(new File(“target&#x2F;rootfs”)); 由如下洋洋洒洒十来行取代。    \n// 创建模拟器实例，要模拟32位或者64位，在这里区分//        emulator = AndroidEmulatorBuilder.for32Bit().build();AndroidEmulatorBuilder builder = new AndroidEmulatorBuilder(false) &#123;    public AndroidEmulator build() &#123;        return new AndroidARMEmulator(processName, rootDir,backendFactories) &#123;            @Override            protected UnixSyscallHandler&lt;AndroidFileIO&gt;            createSyscallHandler(SvcMemory svcMemory) &#123;                return new qttSyscallHandler(svcMemory);            &#125;        &#125;;    &#125;&#125;;emulator = builder.setRootDir(new File(&quot;target/rootfs&quot;)).build();\n 直接跑出了结果，但我们的任务其实还没有完成&#x3D; &#x3D;，tag中搜索lilac popen，发现一共调用了三次  \n\nlilac popen command:uname -alilac popen command:cd &#x2F;system&#x2F;bin &amp;&amp; ls -llilac popen command:stat &#x2F;root  \n\n 我们上面的代码，似乎只处理了uname -a应该返回的值，后面两次呢？怎么在pipe2中根据 popen输入的command返回合适的输出呢？  我们可以使用emulator的全局变量来完成这一点     对应的qttSyscallHandler代码，其中 cd &#x2F;system&#x2F;bin &amp;&amp; ls -l 和 stat &#x2F;root 的结果来自adb shell，大家 根据自己的测试机情况填入合适的结果。  \nprotected int pipe2(Emulator&lt;?&gt; emulator) &#123;    EditableArm32RegisterContext context = (EditableArm32RegisterContext) emulator.getContext();    Pointer pipefd = context.getPointerArg(0);    int flags = context.getIntArg(1);    int write = getMinFd();    this.fdMap.put(write, new DumpFileIO(write));    int read = getMinFd();    String stdout = &quot;&quot;;    // stdout中写入popen command 应该返回的结果    String command = emulator.get(&quot;command&quot;);    switch (command) &#123;        case &quot;uname -a&quot;: &#123;            stdout = &quot;Linux localhost 3.10.73-g33ace82f84b #1 SMP PREEMPT Fri Oct 13 04:41:33 UTC 2017 aarch64&quot;;        &#125;        break;        case &quot;cd /system/bin &amp;&amp; ls -l&quot;: &#123;            stdout = &quot;total 25152&quot; +                    &quot;-rwxr-xr-x 1 root shell 128688 2009-01-01 08:00 abb&quot; +                    &quot;lrwxr-xr-x 1 root shell 6 2009-01-01 08:00 acpi -&gt; toybox&quot; +                    &quot;-rwxr-xr-x 1 root shell 30240 2009-01-01 08:00 adbd&quot; +                    &quot;-rwxr-xr-x 1 root shell 207 2009-01-01 08:00 am&quot; +                    &quot;-rwxr-xr-x 1 root shell 456104 2009-01-01 08:00 apexd&quot; +                    &quot;lrwxr-xr-x 1 root shell 13 2009-01-01 08:00 app_process -&gt; app_process64&quot; +                    &quot;-rwxr-xr-x 1 root shell 25212 2009-01-01 08:00 app_process32&quot;;        &#125;        break;        case &quot;stat /root&quot;: &#123;            stdout = &quot;stat: &#x27;/root&#x27;: No such file or directory&quot;;        &#125;        break;        default:            System.out.println(&quot;command do not match!&quot;);    &#125;    this.fdMap.put(read, new ByteArrayFileIO(0, &quot;pipe2_read_side&quot;, stdout.getBytes()));    pipefd.setInt(0, read);    pipefd.setInt(4, write);    System.out.println(&quot;pipe2 pipefd=&quot; + pipefd + &quot;, flags=0x&quot; + flags + &quot;, read=&quot; + read + &quot;, write=&quot; + write + &quot;, stdout=&quot; + stdout);    context.setR0(0);    return 0;&#125;\n\ngetenv的处理 getenv的出现频率也挺高， 首先我们看一下当前测试机有哪些环境变量    \n\nangler:&#x2F;system&#x2F;bin $ exportANDROID_ASSETSANDROID_BOOTLOGOANDROID_DATAANDROID_ROOTANDROID_SOCKET_adbdANDROID_STORAGEASEC_MOUNTPOINTBOOTCLASSPATHDOWNLOAD_CACHEEXTERNAL_STORAGEHOMEHOSTNAMELOGNAMEPATHSHELLSYSTEMSERVERCLASSPATHTERMTMPDIRUSER\n\n 看一下PATH的内容  \n\nangler:&#x2F;system&#x2F;bin $ echo $PATH&#x2F;sbin:&#x2F;system&#x2F;sbin:&#x2F;system&#x2F;bin:&#x2F;system&#x2F;xbin:&#x2F;vendor&#x2F;bin:&#x2F;vendor&#x2F;xbin\n\n getValue取不到结果，原因就是getenv没有返回值，那么该怎么办呢？   这里给env返回正确的值有几种办法呢？  \n方法一 Unidbg提供了对环境变量的初始化，它在 src&#x2F;main&#x2F;java&#x2F;com&#x2F;github&#x2F;unidbg&#x2F;linux&#x2F;AndroidElfLoader.java中。   我们填上这一个就行，为了辨别不同方法是否生效，我们这里返回1  \nthis.environ = initializeTLS(new String[] &#123;        &quot;ANDROID_DATA=/data&quot;,        &quot;ANDROID_ROOT=/system&quot;,        //&quot;PATH=/sbin:/vendor/bin:/system/sbin:/system/bin:/system/xbin&quot;,        &quot;NO_ADDR_COMPAT_LAYOUT_FIXUP=1&quot;,        &quot;PATH=1&quot;,&#125;);\n方法二 libc 提供了setenv方法，可以设置环境变量。 在调用函数前先调用该方法 \n// setenv设置环境变量public void setEnv()&#123;    Symbol setenv = module.findSymbolByName(&quot;setenv&quot;, true);    setenv.call(emulator, &quot;PATH&quot;, &quot;2&quot;, 0);&#125;;\n\n\n方法三 通过HookZz hook函数，替换结果  \npublic void hookgetEnvByHookZz()&#123;    HookZz hookZz = HookZz.getInstance(emulator);    hookZz.wrap(module.findSymbolByName(&quot;getenv&quot;), new WrapCallback&lt;EditableArm32RegisterContext&gt;() &#123;        String name;        @Override        public void preCall(Emulator&lt;?&gt; emulator, EditableArm32RegisterContext ctx, HookEntryInfo info) &#123;            name = ctx.getPointerArg(0).getString(0);        &#125;        @Override        public void postCall(Emulator&lt;?&gt; emulator, EditableArm32RegisterContext ctx, HookEntryInfo info) &#123;            switch (name)&#123;                case &quot;PATH&quot;: &#123;                    MemoryBlock replaceBlock = emulator.getMemory().malloc(0x100, true);                    UnidbgPointer replacePtr = replaceBlock.getPointer();                    String pathValue = &quot;3&quot;;                    replacePtr.write(0, pathValue.getBytes(StandardCharsets.UTF_8), 0, pathValue.length());                    ctx.setR0(replacePtr.toIntPeer());                &#125;            &#125;            super.postCall(emulator, ctx, info);        &#125;    &#125;);&#125;\n\n方法四 也可以通过断点的方式hook  \npublic void hookgetEnvByBreakPointer() &#123;    emulator.attach().addBreakPoint(module.base + 0x7FE, new BreakPointCallback() &#123;        @Override        public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;            EditableArm32RegisterContext registerContext =                    emulator.getContext();            registerContext.getPointerArg(0).setString(0, &quot;4&quot;);            emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_PC,                    (address) + 5);            return true;        &#125;    &#125;);&#125;\n 直接让R0指针指向正确的值，并操纵PC寄存器跳过这条指令  \n方法五 仿照SystemPropertyHook写一下，代码如下  在 vm.loadLibrary 加载so文件之前\nEnvHook envHook = new EnvHook(emulator);memory.addHookListener(envHook);\n EnvHook.java  \nimport com.github.unidbg.Emulator;import com.github.unidbg.arm.ArmHook;import com.github.unidbg.arm.HookStatus;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.hook.HookListener;import com.github.unidbg.memory.SvcMemory;import com.github.unidbg.pointer.UnidbgPointer;public class EnvHook implements HookListener &#123;    private final Emulator&lt;?&gt; emulator;    public EnvHook(Emulator&lt;?&gt; emulator) &#123;        this.emulator = emulator;    &#125;    @Override    public long hook(SvcMemory svcMemory, String libraryName, String symbolName,                     final long old) &#123;        if (&quot;libc.so&quot;.equals(libraryName) &amp;&amp; &quot;getenv&quot;.equals(symbolName)) &#123;            if (emulator.is32Bit()) &#123;                return svcMemory.registerSvc(new ArmHook() &#123;                    @Override                    protected HookStatus hook(Emulator&lt;?&gt; emulator) &#123;                        return getenv(old);                    &#125;                &#125;).peer;            &#125;        &#125;        return 0;    &#125;    private HookStatus getenv(long old) &#123;        RegisterContext context = emulator.getContext();        UnidbgPointer pointer = context.getPointerArg(0);        String key = pointer.getString(0);        switch (key)&#123;            case &quot;PATH&quot;:&#123;                pointer.setString(0, &quot;5&quot;);                return HookStatus.LR(emulator, pointer.peer);            &#125;        &#125;        return HookStatus.RET(emulator, old);    &#125;&#125;\n","tags":["Unidbg"]},{"title":"unidbg踩坑记录，getobjectclass对象为null","url":"/posts/48808/","content":"package com.dongchedi;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import com.github.unidbg.virtualmodule.android.AndroidModule;import org.apache.log4j.Level;import org.apache.log4j.Logger;import java.io.File;import java.util.ArrayList;import java.util.List;public class dongchedi extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final VM vm;    private final Module module;    dongchedi() &#123;        Logger.getLogger(&quot;com.github.unidbg.linux.ARM32SyscallHandler&quot;).setLevel(Level.DEBUG);        Logger.getLogger(&quot;com.github.unidbg.unix.UnixSyscallHandler&quot;).setLevel(Level.DEBUG);        Logger.getLogger(&quot;com.github.unidbg.AbstractEmulator&quot;).setLevel(Level.DEBUG);        Logger.getLogger(&quot;com.github.unidbg.linux.android.dvm.DalvikVM&quot;).setLevel(Level.DEBUG);        Logger.getLogger(&quot;com.github.unidbg.linux.android.dvm.BaseVM&quot;).setLevel(Level.DEBUG);        Logger.getLogger(&quot;com.github.unidbg.linux.android.dvm&quot;).setLevel(Level.DEBUG);        emulator = AndroidEmulatorBuilder.for32Bit().build();        final Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;unidbg-android\\\\src\\\\test\\\\java\\\\com\\\\dongchedi\\\\dongchedi_6_5_1.apk&quot;));        vm.setJni(this);        vm.setVerbose(true);        new AndroidModule(emulator, vm).register(memory);        DalvikModule dm = vm.loadLibrary(&quot;cjtfcc&quot;, true);        module = dm.getModule();        dm.callJNI_OnLoad(emulator);    &#125;    public String tfccDecrypt(int param1, int param2, String param3, String param4) &#123;        // com.bdcaijing.tfccsdk.Tfcc        // private native String tfccDecrypt(int i, int i2, String str, String str2);        List&lt;Object&gt; list = new ArrayList&lt;&gt;();        list.add(vm.getJNIEnv()); //第一个参数默认env        list.add(0); //第二个参数一般填0，一般用不到        list.add(param1);        list.add(param2);        StringObject stringObject1 = new StringObject(vm, param3);        list.add(vm.addLocalObject(stringObject1));        StringObject stringObject2 = new StringObject(vm, param4);        list.add(vm.addLocalObject(stringObject2));        Number number = module.callFunction(emulator, 0xa2ac, list.toArray());        System.out.println(vm.getObject(number.intValue()).getValue().toString());        return null;    &#125;    public static void main(String[] args) &#123;        dongchedi test = new dongchedi();        test.tfccDecrypt(9, 1, &quot;14zRM+40n2UGVx0DlI7hqDFjsxGR6eJsnnxUME5ZDT8=&quot;,                &quot;AQAAAIY8QCEBiAWgEHTCmugnR4hHWlbOmpfOHoYQ+gXQHXvSrCBlQtFmGM8T7eHljYYTD8vWOsQa8SuOaBwMTYOS03qjuUktB2dRu3+mWr4z5N3uMrb1Es/MTUrWx8JGHVoX1z7f6luarDvT9Wf0KKbfHRkqaJANlwVEqULsZU6HkJ0zkaFh3AnU5eQRsPoxttOPOhsVLv/kNjpm1&quot; +                &quot;qBHkENXSedO4MN+PGybTCOKH3Ri6dvoX9EXCUr41o2W0ujI46nYn7vUrRkHgHNOOrGkIL7Acn0wrU6nj3cZuFpxb+W+u6r+MFI8ScE9XQya3322RRqOQUr1xWXpCucv/zknN7pjyzptYk8iWRfeaCT+iSjkmwa+3EStu3U/TQakF1xh46hjPOczx7elte6qV9ztDyF61Eu&quot; +                &quot;Nrz4K+9O4TgqDeg9FGv7k+sNXg4M8L+Vx2BzJ/9MfaOFF5YXlI2oeMk0FReBTV8cBdXv2j23ju5HUpNo45dYF+tLihymL3maOiuWYviIAk8OKjNG+juruF4YuYoAqJoJSvuZ9Avujl3mqL66AdZmzG7vTa29S1MWIwu3XYj96lcbGSav9m5g4yRb6zXcQDIpqAmYHVgRjX&quot; +                &quot;7adt09SOuvrcuORpUh2jSt5smO+lpR7fuHk4tlCr6OlRr360IgJr82PmeAAKz1dV9tHGYlV+618tjgi36J4iLuWaw6Ix9iJ1R6cFJY6JIX8pU8NoGoUFDjK3Dm8Pm9j72J9cTQpEMR/HCT3BOw5YTTTQHl3eQgdZevUD8HFnECMvajFZxKe6obyPieE41WBk/EQ5WI2Bwtu&quot; +                &quot;rmyzxEq/VPIm1UfoqE78T4QOa2ey82Mw6TCIzMSMhCwiA2huzSnlus9RicQaPCX1isa0BitIISMHeHRFqab9ORMnHKVxEX3AhZN3OwcPKntx43yxZrTp5GLYwndyqchZCpTXhu/j/7WfUZRnIc2aOhKegFCLNdeml0Kha9FPSXE8AxTMr6ldw2p5vhPmzn5p2iRvgXoqdr5J&quot; +                &quot;6W6QgBCEb8fGCupV+gLibY5mcLabHBmcSEkdax1h341Qxyk6s8/LvUlpx6MZHPM+/NgWf8bUvvbPKLrD7xhKPtCaaaO1PSGiNTPrlRJaajiBpJcMwMkjRbKT76+kDCL00teodYNyFBEkYmGJM5Sg7fHY1f6e3FXRYny6bXnr0R/mTnxWDPDAc9gn2eiyHofLRaBjvtbdpMStn&quot; +                &quot;MolS5ybQt8GfaVifsjfQe3jwLmFNCtsXn6unDo189udnL9iOwtwIhLUtUvIU9IejQ33rKAMWQjrlvA99KTLzdk6ewItUa4mI9sFcpcR/uIbQiiHYs1qvfrQiAmvzY+Z4AArPV1X20cZiVX7rXy2OCLfoniIu5ZrDojH2InVHpwUljokhfylTw2gahQUOMrcObw+b2PvYn1xNC&quot; +                &quot;kQxH8cJPcE7DlhNNO1SUZeQb5H5IQYdROwNOj0gcN4YmN1P2S2PC6VQzGJu2x0+T9e7PeW2jjIl4qM0N23z+A9W3IX0+x4oUU/1MNdgaxMlucq9SRoPnuyW/LC+PkDTN1tk6oMbKoqQSYiKn0dVOZKma6PWO3UogNGhFJN+uzG8TN0Vh5YDTrpJ/AhzGdpNu0aDFGXrXqaCx5n&quot; +                &quot;Lcxfiq9XMzz47/nNbJ5GD/sBg2anQ25uYJQqueFTZsej5Buy+PpsZ9UCUlZ3QDdC8Z2dGfQCnnzvosx3vb3nZVUtkxruvGaDtTueshIcL6OFF+liJQ1N3hjfsom7F74c4NYZo3SbrUSlOOLWi9YALqszQq+s6XvUNBbKWzeCU236tn7MmtlBkdA+ZAe95f1JPy63XwxkK6wtfF&quot; +                &quot;n7uxDQKfv/HVeKjvzQ+IAHv3wQmGSSUuHtusWtwFzTMXKqur3KNdLDQZIo6UV74/uvG3/CQnX3JoK3AHydHKV+kkMd9W6Uzjy37PixjrW5IFST6+thqb/yrK1chGM9MPJ7AbNeq9Zfhi5igComglK+5n0C+6OXebfNiKoMkM2f/ezRyGcMxEkKmyG2g9cZwfeDjZjDVvPiMd8Jf&quot; +                &quot;6XOoXT47iq7JcWZ8PM8FELOWjegOP9hXUMPdkn2waqXbJ7eFwfb1vI/kSsX6QdTF5cXYcScuqFjft/hLd/a+JaSwEyFqIbWnZkHMMNuAqCmBmzk8ZEXzYkflQBKnTdiEgsXVrf4RokNgd//cFo6ZfrcdMdtbpiOEM3k9iD9HABFcsV4boY89g1Uqmx66emYxoD1UUI7XlDyGFgvY&quot; +                &quot;uRFN5vcANjq9wM4mIfNRx8xN5JNj5EIcZG6fE3mq0jEQlEQf8V89ngy2x/Klp7c8OHWV9YDy3v4QeSTmSCrg8EvCx71UD0mhOPjBoF0EsUt6JseIrcKH+ORtrfSyPjUPnhkCnkTLZpyidfqUCJz6YksBQ7Ak+tA9vKN7Y2xGkgy/8jpwMfRjnmERo3YMrgaawqhp5RZLB0V2ZPLUC&quot; +                &quot;s5MqqsJDnIp2KnCV8hJVDTUdz6/XlAPCWACEfZAZpX38dS7RTVw/KzJf903a7pdrsPJ+fW4MVIaMzF98w0GCRjFSPw8V44sbHQbrcFLgZ+7bF6G2Dm0eez6L5xIs0ptZcX8tN7UE24KxYJK8/THH47mRDs/gyMFE4r5r5XzB1vgtPPWURrjzCtODTxtcsxDaQ89e7WHuBA7IVBzRC2&quot; +                &quot;5+lKeAndp3VlHpeGLzzLfHkgMqva7KsGE3rMPYk+ioGPl3TuPWrqawjwSKlsUP/vf61f80Br42DugXL4RPAoE5b5P/8628TZVqYMzkC1hfKNOzxkAOsYCW+vLizurCPm8yeIqDYlZq/DcFVxHxPkAR9uOFZwlKNXZbMzaDEU+ebXX4g+WG6dpKK0GSFV4MZX5SvpZrvIZvTspyVYjpXHV&quot; +                &quot;Atr+wCzO0N5tg1kGJABoj+aZ4GWGFYv7kzTMBuk0hDeFXfDgp+Af7tMAkfmG67iqopLbNccfhlE6fXBwZail88u/6S9zhqAgZLclp3cPFDnZdGLF0pNqzsx6pk2j5tS+srUVHT+M5gGYOhC6iofm0ek0CQYsSwd6e8uUV627Cb00qLT1d0BGax0oQA2UE+dgCiR2jZaO0bnPsh6a6VC3P0&quot; +                &quot;vGdiWeNZyjTEHXD3YaUb9y49+bniXV7SpHcLiZj+voezbBQqCETrDTc1pLjicAgBtCJ4kPYUzDJBtB/NUQR+PHMwH4QrhgqaDKFPnCjFAOv63ob7aepyfMI/fWenLJmEuTQU/hWv7zxhvC3KX7hfcIPTtUYDRJofRS4F0UNTGY7wHf0nD+uqJPaxEamlsFMNtPLa2ZAskmEXy1tegY8sH8&quot; +                &quot;V8pFL7Gn0EbOAonzSLwQKZhlESxQ7MPTu3fgP7mnuEknJmhk3dwiCNNePtG6NftfjQSeJGHl+qtJNdWL22jONkATEgCZDQfYCAGkDPnI/svE9N80b83xT5K/+MQaLZGX/cyTWKLIlz21uaHGSRo0MaNBwYrRjNOZhoHbN2Cy0sgVLvlaMGTnkH4PJ/I09GQxsNAKLXz+vAKKNwbA36Kw4n&quot; +                &quot;21WRWDoSBJ5gPjFKWHR1S4BYUCxI90O51M9InW1G06saOk991lD9RH6A0ywH3Nw4Mkg7BGLvdIdqCoqAmrcvgYJ1h/RvJOt/h2ipzcDpz/qaZU2UZabYEn3V714z0d5LMvN690tCaaaO1PSGiNTPrlRJaajhMKjIj0sQ1U1K4To1wyvhN4rsSeR+QtEIKK1xOW8yj5nhlEvksrd3GULB+hL&quot; +                &quot;1ymx/tZgdQxe4ysd3cL9U/7tMmlPc9YWVtO22UO7iVrTfhTHmT0Rs9ttFNBjkyh/bPRTloBts7VeIUpze3ppRP4ncOJCaxxLOwtd0fA6iTvV4eAFeAcia29951yCHn91FjaNljJcPnRNy+u0VK+SlDptv5AcagR0luMfzGuIHOHdn9wIvb8/UDxAvxhwnieHQ7s1GdDUSq1T2xR5iHstyUu&quot; +                &quot;Ma/Gax0oQA2UE+dgCiR2jZaO5/TnlbXb9IKvNeQ1fAvHxiIwfpxozEMIvOzOrPbLwJjs8xXbkCH8GvEYiqQfMw2B3w6YIawzwVlcx+4CypfZvtYTatE+XCzs2j8rjFUZWUBv2olwN3ZfL3a0AfpAo0+LTSRIivoQSNEEuk7sIg2xU1lonGUe8JRYJovoyczZNNC/OUI5wD5kWCEM0v3A/kO&quot; +                &quot;Du50mX+Sl1LtmX8FQdy1q5nbS1BWFqfF6cibw4CL5yMH&quot;);    &#125;&#125;\n\n运行样本后报错：GetObjectClass 的 object 为 null\n\n当前报错位置已经断下来了，输入bt查看调用栈\n\n用ida打开样本so，跳到 0x092b8 地址\n\n先分析一下，查看GetObjectClass的文档\njclass GetObjectClass(JNIEnv *env, jobject obj);\n\n有两个参数，env和object，根据ARM函数调用约定采用，参数1参数4 分别保存到 R0R3 寄存器中\n所以往上看R1出现的地址位置，0x92A8，进行断点查看调用的位置\n\nida跳到0x0a554，转为汇编代码后，可以看到object是v24，也就是入参a2，\n\n\n查看该函数的地址为0xa2ac，这跟我们一开始调用的地址一样的，在看当时传递的第二个object，确实传的0\n\n可以通过jadx查看正确的对象\npublic String tfccDecrypt(int param1, int param2, String param3, String param4) &#123;    // com.bdcaijing.tfccsdk.Tfcc    // private native String tfccDecrypt(int i, int i2, String str, String str2);    List&lt;Object&gt; list = new ArrayList&lt;&gt;();    list.add(vm.getJNIEnv()); //第一个参数默认env//        list.add(0); //第二个参数一般填0，一般用不到    DvmClass Tfcc = vm.resolveClass(&quot;com/bdcaijing/tfccsdk/Tfcc&quot;);    DvmObject&lt;?&gt; TfccObject = Tfcc.newObject(null);    list.add(vm.addLocalObject(TfccObject));    list.add(param1);    list.add(param2);    StringObject stringObject1 = new StringObject(vm, param3);    list.add(vm.addLocalObject(stringObject1));    StringObject stringObject2 = new StringObject(vm, param4);    list.add(vm.addLocalObject(stringObject2));    Number number = module.callFunction(emulator, 0xa2ac, list.toArray());    System.out.println(vm.getObject(number.intValue()).getValue().toString());    return null;&#125;\n\n\n再次运行就可以了\n","tags":["Unidbg"]},{"title":"jni接口比较(Jnitrace/Frida/ExAndroidNativeEmu/Unidbg)","url":"/posts/22516/","content":"\n它们是如何处理&#x2F;实现jni几百个接口函数的？\n\n它们能hook&#x2F;主动调用JNI接口函数么？\n\n它们是如何找到jni(动)静态注册的Native函数的？\n\n它们能hook动(静)态注册的Native函数么？\n\n它们能主动调用动(静)态注册的Native函数么？\n\n首先定义：\n\nJava层的Native函数\nenv、vm → jni接口函数\njni静态函数、jni动态函数\n纯native函数\n\n\n\nFrida\njnitrace\nExAndroidNativeEmu\nUnidbg\n\n\n\n可以跑完整的apk么？\n⚪\n⚪\n×\n×\n\n\n可以hook Java么？查看参调返\n⚪\nx\nx\n×\n\n\n可以hook JNI接口函数么？查看参调返\n⚪\n⚪\n⚪\n⚪\n\n\n可以主动调用JNI接口函数么？获取返回值\n⚪\nx\n⚪\n⚪\n\n\n如何找到静态绑定的Native函数？\ndlopen&#x2F;dlsym\ndlsym\nModule\nModule\n\n\n如何找到动态绑定的Native函数？\nhook RegisterNatives\nhook RegisterNatives\nhook RegisterNatives\nhook RegisterNatives\n\n\n如何hook(动)静态注册的Native函数？\n⚪\n⚪\nx\n⚪\n\n\n如何主动调用(动)静态注册的Native函数？\n⚪\nx\n⚪\n⚪\n\n\n\n\n\nFrida中JNI接口的实现细节\n\n\nhttps://github.com/frida/frida-java-bridge/blob/master/lib/env.js#L362linux动态库函数dlopen与dlsym使用https://blog.csdn.net/lanhuazui10/article/details/117849995\nfrida hook javafunction hookJava()&#123;    Java.perform(function()&#123;        Java.use(&quot;com.roysue.easyso1.MainActivity&quot;).method01.implementation = function(str)&#123;            console.log(&quot;str:&quot;, str)            var result = this.method01(str);            console.log(&quot;result:&quot;, result);            return result;        &#125;    &#125;)&#125;\n\nfrida invoke javafunction invokeJava()&#123;    Java.perform(function()&#123;        var result = Java.use(&quot;com.roysue.easyso1.MainActivity&quot;).decrypt(&quot;82e8edd5b05654bf0fedcdfc1c9b4b0f&quot;);        console.log(&quot;result:&quot;, result)    &#125;)&#125;\n\nfrida hook jnifunction find_RegisterNatives(params) &#123;    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    var addrRegisterNatives = null;    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];        //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;                symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            hook_RegisterNatives(addrRegisterNatives)        &#125;    &#125;&#125;function hook_RegisterNatives(addrRegisterNatives) &#123;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);                var env = args[0];                var java_class = args[1];                var class_name = Java.vm.tryGetEnv().getClassName(java_class);                //console.log(class_name);                var methods_ptr = ptr(args[2]);                var method_count = parseInt(args[3]);                for (var i = 0; i &lt; method_count; i++) &#123;                    var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    var name = Memory.readCString(name_ptr);                    var sig = Memory.readCString(sig_ptr);                    var find_module = Process.findModuleByAddress(fnPtr_ptr);                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr,  &quot; fnOffset:&quot;, ptr(fnPtr_ptr).sub(find_module.base), &quot; callee:&quot;, DebugSymbol.fromAddress(this.returnAddress));                &#125;            &#125;        &#125;);    &#125;&#125;setImmediate(find_RegisterNatives);\n\nfrida hook  纯native静态，动态函数（dlopen）动态函数初始化只执行一次，需要hook dlopen（来判断so是否加载）\nfunction hook_Native_JNi()&#123;    Java.perform(function()&#123;        var method01 = Module.findExportByName(&quot;libroysue.so&quot;, &quot;Java_com_roysue_easyso1_MainActivity_method01&quot;);        var method02 = Module.findExportByName(&quot;libroysue.so&quot;, &quot;_Z8method02P7_JNIEnvP7_jclassP8_jstring&quot;);        console.log(&quot;method01 address:&quot;, method01)        console.log(&quot;method02 address:&quot;, method02)        if(method01)&#123;            Interceptor.attach(method01, &#123;                onEnter: function(args)&#123;                    // env-&gt;GetStringUTFChars(str_, JNI_FALSE)                    console.log(&quot;method01 args[2] ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(args[2], null).readCString())                &#125;,                onLeave: function(retval)&#123;                    console.log(&quot;method01 retval ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(retval, null).readCString())                &#125;            &#125;)        &#125;        if(method02)&#123;            Interceptor.attach(method02, &#123;                onEnter: function(args)&#123;                    console.log(&quot;method02 args[2] ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(args[2], null).readCString())                &#125;,                onLeave: function(retval)&#123;                    console.log(&quot;method02 retval ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(retval, null).readCString())                &#125;            &#125;)        &#125;    &#125;)&#125;function hook_dlopen(module_name, fun) &#123;    //安卓高版本需要同时hook android_dlopen_ext    var android_dlopen_ext = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);    if (android_dlopen_ext) &#123;        Interceptor.attach(android_dlopen_ext, &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr) &#123;                    this.path = (pathptr).readCString();                    if (this.path.indexOf(module_name) &gt;= 0) &#123;                        this.canhook = true;                        console.log(&quot;android_dlopen_ext:&quot;, this.path);                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.canhook) &#123;                    fun();                &#125;            &#125;        &#125;);    &#125;    var dlopen = Module.findExportByName(null, &quot;dlopen&quot;);    if (dlopen) &#123;        Interceptor.attach(dlopen, &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr) &#123;                    this.path = (pathptr).readCString();                    console.log(&quot;dlopen:&quot;, this.path)                    if (this.path.indexOf(module_name) &gt;= 0) &#123;                        this.canhook = true;                        console.log(&quot;dlopen:&quot;, this.path);                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.canhook) &#123;                    fun();                &#125;            &#125;        &#125;);    &#125;    console.log(&quot;android_dlopen_ext:&quot;, android_dlopen_ext, &quot;dlopen:&quot;, dlopen);&#125;function main()&#123;    // hookJava()    hook_dlopen(&quot;libroysue.so&quot;, hook_Native_JNi)&#125;\n\nfrida hook 纯native静态，动态函数（libart，RegisterNatives）通过hook libart下的RegisterNatives来hook动态函数，动态函数加载后，静态函数已经加载了.init .init_array, so feature - dlopen dlsymjni JNI_Onload &#x3D; RegisterNatives\nfunction find_RegisterNatives() &#123;    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    var addrRegisterNatives = null;    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];                //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;                symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            hook_RegisterNatives(addrRegisterNatives)        &#125;    &#125;&#125;function hook_RegisterNatives(addrRegisterNatives) &#123;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);                var env = args[0];                var java_class = args[1];                var class_name = Java.vm.tryGetEnv().getClassName(java_class);                //console.log(class_name);                var methods_ptr = ptr(args[2]);                var method_count = parseInt(args[3]);                for (var i = 0; i &lt; method_count; i++) &#123;                    var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    var name = Memory.readCString(name_ptr);                    var sig = Memory.readCString(sig_ptr);                    var find_module = Process.findModuleByAddress(fnPtr_ptr);                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr,  &quot; fnOffset:&quot;, ptr(fnPtr_ptr).sub(find_module.base), &quot; callee:&quot;, DebugSymbol.fromAddress(this.returnAddress));                    if (name.indexOf(&quot;decrypt&quot;) &gt;= 0)&#123;                        var method02addr = fnPtr_ptr;                        var method01addr = Module.findExportByName(&quot;libroysue.so&quot;, &quot;Java_com_roysue_easyso1_MainActivity_method01&quot;);                        console.log(&quot;method01 address:&quot;, method02addr)                        console.log(&quot;method02 address:&quot;, method01addr)                        if(method01addr)&#123;                            Interceptor.attach(method01addr, &#123;                                onEnter: function(args)&#123;                                    // env-&gt;GetStringUTFChars(str_, JNI_FALSE)                                    console.log(&quot;method01 args[2] ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(args[2], null).readCString())                                &#125;,                                onLeave: function(retval)&#123;                                    console.log(&quot;method01 retval ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(retval, null).readCString())                                &#125;                            &#125;)                        &#125;                        if(method02addr)&#123;                            Interceptor.attach(method02addr, &#123;                                onEnter: function(args)&#123;                                    console.log(&quot;method02 args[2] ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(args[2], null).readCString())                                &#125;,                                onLeave: function(retval)&#123;                                    console.log(&quot;method02 retval ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(retval, null).readCString())                                &#125;                            &#125;)                        &#125;                    &#125;                &#125;            &#125;        &#125;);    &#125;&#125;\n\nfrida invoke  纯native(动态，静态)（基于dlopen）var method01_addr = null;var method02_addr = null;var addrNewStringUTF = null;function hook_dlopen(module_name, fun) &#123;    //安卓高版本需要同时hook android_dlopen_ext    var android_dlopen_ext = Module.findExportByName(null, &quot;android_dlopen_ext&quot;);    if (android_dlopen_ext) &#123;        Interceptor.attach(android_dlopen_ext, &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr) &#123;                    this.path = (pathptr).readCString();                    if (this.path.indexOf(module_name) &gt;= 0) &#123;                        this.canhook = true;                        console.log(&quot;android_dlopen_ext:&quot;, this.path);                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.canhook) &#123;                    fun();                &#125;            &#125;        &#125;);    &#125;    var dlopen = Module.findExportByName(null, &quot;dlopen&quot;);    if (dlopen) &#123;        Interceptor.attach(dlopen, &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr) &#123;                    this.path = (pathptr).readCString();                    // console.log(&quot;dlopen:&quot;, this.path)                    if (this.path.indexOf(module_name) &gt;= 0) &#123;                        this.canhook = true;                        // console.log(&quot;dlopen:&quot;, this.path);                    &#125;                &#125;            &#125;,            onLeave: function (retval) &#123;                if (this.canhook) &#123;                    fun();                &#125;            &#125;        &#125;);    &#125;    console.log(&quot;android_dlopen_ext:&quot;, android_dlopen_ext, &quot;dlopen:&quot;, dlopen);&#125;function hook_Native_JNi()&#123;    Java.perform(function()&#123;        method01_addr = Module.findExportByName(&quot;libroysue.so&quot;, &quot;Java_com_roysue_easyso1_MainActivity_method01&quot;);        method02_addr = Module.findExportByName(&quot;libroysue.so&quot;, &quot;_Z8method02P7_JNIEnvP7_jclassP8_jstring&quot;);        addrNewStringUTF = Module.findExportByName(&quot;libroysue.so&quot;, &quot;_ZN7_JNIEnv12NewStringUTFEPKc&quot;);        console.log(&quot;method01 address:&quot;, method01_addr)        console.log(&quot;method02 address:&quot;, method02_addr)        console.log(&quot;addrNewStringUTF address:&quot;, addrNewStringUTF)    &#125;)&#125;function invoke_method01(contents)&#123;    var method01_addr = Module.findExportByName(&quot;libroysue.so&quot;, &quot;Java_com_roysue_easyso1_MainActivity_method01&quot;)    if(method01_addr &amp;&amp; addrNewStringUTF)&#123;        console.log(&quot;method01_addr is =&gt;&quot;,method01_addr)        var method01 = new NativeFunction(method01_addr, &#x27;pointer&#x27;,[&#x27;pointer&#x27;,&#x27;pointer&#x27;,&#x27;pointer&#x27;])        var NewStringUTF = new NativeFunction(addrNewStringUTF, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]);        var result = null;        Java.perform(function()&#123;            var Jstring = Java.vm.getEnv().newStringUtf(contents)            // var Jstring = NewStringUTF(Java.vm.getEnv(), Memory.allocUtf8String(contents));            result = method01(Java.vm.getEnv(), Jstring, Jstring)            console.log(&quot;result is =&gt;&quot;,result)            console.log(&quot;result is &quot;, Java.vm.getEnv().getStringUtfChars(result, null).readCString())            result = Java.vm.getEnv().getStringUtfChars(result, null).readCString();        &#125;)        return result;    &#125;&#125;function invoke_method02(contents)&#123;    if(method02_addr &amp;&amp; addrNewStringUTF)&#123;        console.log(&quot;method02_addr is =&gt;&quot;, method02_addr)        var method02 = new NativeFunction(method02_addr, &#x27;pointer&#x27;,[&#x27;pointer&#x27;,&#x27;pointer&#x27;,&#x27;pointer&#x27;])        var NewStringUTF = new NativeFunction(addrNewStringUTF,&#x27;pointer&#x27;,[&#x27;pointer&#x27;,&#x27;pointer&#x27;])        var result = null;        Java.perform(function()&#123;            var Jstring = Java.vm.getEnv().newStringUtf(contents)            // var Jstring = NewStringUTF(Java.vm.getEnv(), Memory.allocUtf8String(contents));            result = method02(Java.vm.getEnv(), Jstring, Jstring)            console.log(&quot;result is =&gt;&quot;,result)            console.log(&quot;result is &quot;, Java.vm.getEnv().getStringUtfChars(result, null).readCString())            result = Java.vm.getEnv().getStringUtfChars(result, null).readCString();        &#125;)        return result;    &#125;&#125;rpc.exports = &#123;    invoke1:invoke_method01,    invoke2:invoke_method02&#125;function main()&#123;    hook_dlopen(&quot;libroysue.so&quot;, hook_Native_JNi)&#125;setImmediate(main)\n\nfrida invoke  纯native(动态，静态)（基于RegisterNatives）通过RegisterNatives获取到jni函数地址，进行调用\nvar addrNewStringUTF = null;var method02addr = null;function find_RegisterNatives() &#123;    var symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    var addrRegisterNatives = null;    for (var i = 0; i &lt; symbols.length; i++) &#123;        var symbol = symbols[i];        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;                symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;NewStringUTF&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrNewStringUTF = symbol.address;            console.log(&quot;NewStringUTF is at &quot;, symbol.address, symbol.name);        &#125;        //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;                symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            hook_RegisterNatives(addrRegisterNatives)        &#125;    &#125;&#125;function hook_RegisterNatives(addrRegisterNatives) &#123;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);                var env = args[0];                var java_class = args[1];                var class_name = Java.vm.tryGetEnv().getClassName(java_class);                //console.log(class_name);                var methods_ptr = ptr(args[2]);                var method_count = parseInt(args[3]);                for (var i = 0; i &lt; method_count; i++) &#123;                    var name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    var sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    var fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    var name = Memory.readCString(name_ptr);                    var sig = Memory.readCString(sig_ptr);                    var find_module = Process.findModuleByAddress(fnPtr_ptr);                    console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr,  &quot; fnOffset:&quot;, ptr(fnPtr_ptr).sub(find_module.base), &quot; callee:&quot;, DebugSymbol.fromAddress(this.returnAddress));                    if (name.indexOf(&quot;decrypt&quot;) &gt;= 0)&#123;                        method02addr = fnPtr_ptr;                        var method01addr = Module.findExportByName(&quot;libroysue.so&quot;, &quot;Java_com_roysue_easyso1_MainActivity_method01&quot;);                        console.log(&quot;method01 address:&quot;, method02addr)                        console.log(&quot;method02 address:&quot;, method01addr)                        // if(method01addr)&#123;                        //     Interceptor.attach(method01addr, &#123;                        //         onEnter: function(args)&#123;                        //             // env-&gt;GetStringUTFChars(str_, JNI_FALSE)                        //             console.log(&quot;method01 args[2] ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(args[2], null).readCString())                        //         &#125;,                        //         onLeave: function(retval)&#123;                        //             console.log(&quot;method01 retval ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(retval, null).readCString())                        //         &#125;                        //     &#125;)                        // &#125;                        if(method02addr)&#123;                            Interceptor.attach(method02addr, &#123;                                onEnter: function(args)&#123;                                    console.log(&quot;method02 args[2] ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(args[2], null).readCString())                                &#125;,                                onLeave: function(retval)&#123;                                    console.log(&quot;method02 retval ==&gt; &quot;, Java.vm.getEnv().getStringUtfChars(retval, null).readCString())                                &#125;                            &#125;)                        &#125;                    &#125;                &#125;            &#125;        &#125;);    &#125;&#125;function invoke_method01(contents)&#123;    var method01_addr = Module.findExportByName(&quot;libroysue.so&quot;, &quot;Java_com_roysue_easyso1_MainActivity_method01&quot;)    if(method01_addr &amp;&amp; addrNewStringUTF)&#123;        console.log(&quot;method01_addr is =&gt;&quot;,method01_addr)        var method01 = new NativeFunction(method01_addr, &#x27;pointer&#x27;,[&#x27;pointer&#x27;,&#x27;pointer&#x27;,&#x27;pointer&#x27;])        var NewStringUTF = new NativeFunction(addrNewStringUTF, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]);        var result = null;        Java.perform(function()&#123;            var Jstring = NewStringUTF(Java.vm.getEnv(), Memory.allocUtf8String(contents));            result = method01(Java.vm.getEnv(), Jstring, Jstring)            console.log(&quot;result is =&gt;&quot;,result)            console.log(&quot;result is &quot;, Java.vm.getEnv().getStringUtfChars(result, null).readCString())            result = Java.vm.getEnv().getStringUtfChars(result, null).readCString();        &#125;)        return result;    &#125;&#125;function invoke_method02(contents)&#123;    if(method02addr &amp;&amp; addrNewStringUTF)&#123;        console.log(&quot;method02_addr is =&gt;&quot;, method02addr)        var method02 = new NativeFunction(method02addr, &#x27;pointer&#x27;,[&#x27;pointer&#x27;,&#x27;pointer&#x27;,&#x27;pointer&#x27;])        var NewStringUTF = new NativeFunction(addrNewStringUTF,&#x27;pointer&#x27;,[&#x27;pointer&#x27;,&#x27;pointer&#x27;])        var result = null;        Java.perform(function()&#123;            var Jstring = NewStringUTF(Java.vm.getEnv(), Memory.allocUtf8String(contents));            result = method02(Java.vm.getEnv(), Jstring, Jstring)            console.log(&quot;result is =&gt;&quot;,result)            console.log(&quot;result is &quot;, Java.vm.getEnv().getStringUtfChars(result, null).readCString())            result = Java.vm.getEnv().getStringUtfChars(result, null).readCString();        &#125;)        return result;    &#125;&#125;rpc.exports = &#123;    invoke1:invoke_method01,    invoke2:invoke_method02&#125;function main()&#123;    // hookJava()    // hook_dlopen(&quot;libroysue.so&quot;, hook_Native_JNi)    find_RegisterNatives(&quot;libroysue.so&quot;)&#125;setImmediate(main)\n\n\n\n\n注：可以获取jni的NewStringUTF的地址，然后创建函数自动调用。或者直接使用Java.vm.getEnv().newStringUtf(contents)作用：将java的string转jni的Jsting\n","tags":["frida"]},{"title":"Art中的c++对象内存布局","url":"/posts/64557/","content":"ART由C++11实现的，C++11中的类所占内存的大小主要是由成员变量（静态变量除外）决定的，成员函数（虚函数除外）是不计算在内的。成员函数的存储是以一般函数的模式进行存储。a.fun()是通过fun(a.this)来调用的，这时候this指针会做为隐藏的第一个参数传入成员函数，this指针的地址就是对象的地址。所谓成员函数只是名义上是在类里的。而成员函数的大小并不在类的对象里面，即同一个类的多个对象共享函数代码，因此可以简单将C++中的类当成C中的结构体即可。对象和成员函数的联系是靠:this指针，也是连接对象与其成员函数的唯一桥梁。\n简单总结：空的类是会占用内存空间的，而且大小是1，原因是c++要求每个实例在内存中都有独一无二的地址。\n\n类内部的成员变量：普通的变量：是要占用内存的，但是要注意对齐原则（这点和struct类型很相似）。static修饰的静态变量：不占用内存，原因是编辑器将其放在全局变量区。\n类内部的成员函数：普通函数：不占用内存虚函数：要占用4个以上字节，用来指定虚函数的虚函数表的入口地址。所以一个类的虚函数所占用的大小是不变的，和虚函数的个数是没有关系的。 32位下占4字节，64位占8字节。\n多重继承，函数函数覆盖考虑下面情况，三个父类虚函数表中的f()的位置被替换成子类的函数指针。这样就可以任一父类对象指针来指向子类，并调用子类的f()了。也会导致虚函数表的指针增加，继承几个就会增加几个。假设，基类和派生类又如下关系：派生类i中覆盖了基类的虚函数f\n\n\nart中的内存布局将&#x2F;art&#x2F;runtime&#x2F;dex_file.h下的DexFile类拷贝出来，除去属性外其余都删掉在脱壳过程中拿到DexFile对象后，只需要知道它的begin和size的偏移删除后的DexFile精简代码如下\nclass DexFile &#123;public:    // First Dex format version supporting default methods.    static const uint32_t kDefaultMethodsVersion = 37;    // First Dex format version enforcing class definition ordering rules.    static const uint32_t kClassDefinitionOrderEnforcedVersion = 37;    static const uint8_t kDexMagic[];    static constexpr size_t kNumDexVersions = 2;    static constexpr size_t kDexVersionLen = 4;    static const uint8_t kDexMagicVersions[kNumDexVersions][kDexVersionLen];    static constexpr size_t kSha1DigestSize = 20;    static constexpr uint32_t kDexEndianConstant = 0x12345678;    // name of the DexFile entry within a zip archive    static const char* kClassesDex;    // The value of an invalid index.    static const uint32_t kDexNoIndex = 0xFFFFFFFF;    // The value of an invalid index.    static const uint16_t kDexNoIndex16 = 0xFFFF;    // The separator character in MultiDex locations.    static constexpr char kMultiDexSeparator = &#x27;:&#x27;;    // Closes a .dex file.    virtual ~DexFile() &#123;&#125;;public:    // The base address of the memory mapping.    uint8_t* begin_;    // The size of the underlying memory allocation in bytes.    size_t size_;    std::string location_;    uint32_t location_checksum_;&#125;;\n进行调用，分别以32和64位运行\nextern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_cpp6_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    DexFile dexFile;    void * beginAddress = (void *) &amp;(dexFile.begin_);    void * sizeAddress = (void *) &amp;(dexFile.size_);    unsigned long dexFileAddress = reinterpret_cast&lt;unsigned long&gt; (&amp;dexFile);  // 拿到DexFile对象的地址    unsigned long beginOffset = reinterpret_cast&lt;unsigned long&gt; (beginAddress)-dexFileAddress;  // 拿到begin_的偏移量    unsigned long sizeOffset = reinterpret_cast&lt;unsigned long&gt; (sizeAddress)-dexFileAddress;  // 拿到size_的偏移量    __android_log_print(4, &quot;cpp11&quot;, &quot;beginOffset: %lu, sizeOffset: %lu&quot;, beginOffset, sizeOffset);    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());&#125;\n\n输出日志：arm32 com.example.cpp6 I&#x2F;cpp11: beginOffset: 4, sizeOffset: 8arm64 com.example.cpp6 I&#x2F;cpp11: beginOffset: 8, sizeOffset: 16去不去掉前面的static属性，都对内存布局没影响，对于脱壳而言，内存布局从前完后，而我们之关注begin_，size_。可以再把上面的DexFile类精简为结构体\nstruct DexFileStruct&#123;    void* vptr;  // 虚函数表指针    void* begin_;    uint32_t size_;&#125;;\n先测试一下，在libart.so中随便找一个函数参数有DexFile的，以 art::ClassLinker::LoadMethod(art::DexFile const&amp;, art::ClassDataItemIterator const&amp;, art::Handleart::mirror::Class, art::ArtMethod *) 为例，使用frida进行hook\nfunction hookart()&#123;    var libart_module = Process.getModuleByName(&quot;libart.so&quot;);    var LoadMethodaddr = null;    libart_module.enumerateExports().forEach(function(symbol)&#123;        // _ZN3art11ClassLinker10LoadMethodERKNS_7DexFileERKNS_21ClassDataItemIteratorENS_6HandleINS_6mirror5ClassEEEPNS_9ArtMethodE        // 在安卓7和8中LoadMethod的参数发生了变化，所以这里直接找函数的特征        if (symbol.name.indexOf(&quot;ClassLinker&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;LoadMethod&quot;) &gt;= 0 &amp;&amp;             symbol.name.indexOf(&quot;DexFile&quot;) &gt;= 0 &amp;&amp;             symbol.name.indexOf(&quot;1ClassDataItemIterator&quot;) &gt;= 0 &amp;&amp;            symbol.name.indexOf(&quot;ArtMethod&quot;) &gt;= 0)&#123;            console.log(symbol.name, symbol.address);            LoadMethodaddr = symbol.address;        &#125;    &#125;)    // 在安卓8.1下 art::ClassLinker::LoadMethod(art::DexFile const&amp;, art::ClassDataItemIterator const&amp;, art::Handle&lt;art::mirror::Class&gt;, art::ArtMethod *)    if (LoadMethodaddr != null) &#123;        console.log(&quot;start hook LoadMethodaddr&quot;);        Interceptor.attach(LoadMethodaddr, &#123;            onEnter: function (args) &#123;                var dexfileptr = args[1];                var dexfilebegin = ptr(dexfileptr).add(Process.pointerSize * 1).readPointer();                var dexfilesize = ptr(dexfileptr).add(Process.pointerSize * 2).readU32();                console.warn(&quot;get a dex:size:&quot; + dexfilesize + &quot;---&quot; + hexdump(dexfilebegin, &#123;                    length: 16                &#125;))                console.log(&quot;go into LoadMethodaddr-&gt;&quot; + hexdump(dexfileptr, &#123;                    length: 32                &#125;));            &#125;, onLeave: function () &#123;            &#125;        &#125;)    &#125;&#125;function main()&#123;    hookart()&#125;setImmediate(main);\n\nget a dex:size:730868---             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF7893d1a01c  64 65 78 0a 30 33 35 00 7f 66 c3 d6 bb 9f a5 71  dex.035..f.....qgo into LoadMethodaddr-&gt;             0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF78c4c40060  20 5e 11 cd 78 00 00 00 1c a0 d1 93 78 00 00 00   ^..x.......x...78c4c40070  f4 26 0b 00 00 00 00 00 81 00 00 00 00 00 00 00  .&amp;..............\n可以看到dex的模值dex 037，也验证了dex的内存布局在函数粒度的修复与脱壳中，还需要关注ArtMethod将&#x2F;art&#x2F;runtime&#x2F;art_method.h下的ArtMethod类拷贝出来，除去属性外其余都删掉删除后的ArtMethod精简代码如下\nclass ArtMethod &#123;public://    GcRoot &lt;mirror::Class&gt; declaring_class_; ==&gt; uint32_t reference_;    uint32_t reference_;    uint32_t access_flags_;    // Offset to the CodeItem.    uint32_t dex_code_item_offset_;    // Index into method_ids of the dex file associated with this method.    uint32_t dex_method_index_;    uint16_t method_index_;    uint16_t hotness_count_;&#125;;\n抽取壳的过程主要关注两个字段，dex_code_item_offset_和dex_method_index_脱壳过程中的应用在脱壳过程中，重点是从内存中提取出被保护或加密的DEX文件，或从已经加载到内存中的DEX文件中提取出方法字节码。这时，dex_code_item_offset_和dex_method_index_就起到了关键作用：\n\n使用dex_code_item_offset_加上DEX文件基址，可以计算出方法字节码在内存中的实际地址。\n通过dex_method_index_，可以找到该方法在DEX文件中的定义，从而获得方法的名称、所属类及其签名等信息。ArtMethod是没有虚函数的，所以在32位或64位下dex_code_item_offset_和dex_method_index_的偏移都是8， 12修改frida代码if (LoadMethodaddr != null) &#123;        console.log(&quot;start hook LoadMethodaddr&quot;);        Interceptor.attach(LoadMethodaddr, &#123;            onEnter: function (args) &#123;                var dexfileptr = args[1];                this.artmethodptr = args[4];                this.dexfilebegin = ptr(dexfileptr).add(Process.pointerSize * 1).readPointer();                this.dexfilesize = ptr(dexfileptr).add(Process.pointerSize * 2).readU32();                // console.warn(&quot;get a dex:size:&quot; + dexfilesize + &quot;---&quot; + hexdump(dexfilebegin, &#123;                //     length: 16                // &#125;))                // console.log(&quot;go into LoadMethodaddr-&gt;&quot; + hexdump(dexfileptr, &#123;                //     length: 32                // &#125;));            &#125;, onLeave: function () &#123;                var dex_code_item_offset = ptr(this.artmethodptr).add(8).readU32();  // 在dex文件中函数的偏移， dexfilebegin+偏移就是函数的绝对地址                var dex_method_index = ptr(this.artmethodptr).add(12).readU32();  // 在dex文件中的方法索引                console.log(this.dexfilesize + &quot;--&gt;LoadMethodaddr index:&quot; + dex_method_index, &quot;--&gt;&quot; + this.dexfilebegin.add(dex_code_item_offset));            &#125;        &#125;)     &#125;\n日志：_ZN3art11ClassLinker10LoadMethodERKNS_7DexFileERKNS_21ClassDataItemIteratorENS_6HandleINS_6mirror5ClassEEEPNS_9ArtMethodE 0x78ccc2868cstart hook LoadMethodaddr3926232--&gt;LoadMethodaddr index:29945 --&gt;0x78984d12643926232--&gt;LoadMethodaddr index:29946 --&gt;0x7898686a3c3926232--&gt;LoadMethodaddr index:29949 --&gt;0x7898686a543926232--&gt;LoadMethodaddr index:29950 --&gt;0x7898686bd03926232--&gt;LoadMethodaddr index:29952 --&gt;0x7898686e103926232--&gt;LoadMethodaddr index:29947 --&gt;0x78986870003926232--&gt;LoadMethodaddr index:29948 --&gt;0x789868711c...\n对app解压，也能看到dex的大小也是3926232，把dex放进010editor查看函数的执行顺序struct method_id_item method_id[29945]\tvoid s.h.e.l.l.S.&lt;clinit&gt;()\t8A5E0h\t8h\tFg: Bg:0x008080\tMethod IDstruct method_id_item method_id[29946]\tvoid s.h.e.l.l.S.&lt;init&gt;()\t8A5E8h\t8h\tFg: Bg:0x008080\tMethod IDstruct method_id_item method_id[29949]\tvoid s.h.e.l.l.S.c(java.util.zip.ZipFile, java.util.zip.ZipEntry, java.io.File)\t8A600h\t8h\tFg: Bg:0x008080\tMethod IDstruct method_id_item method_id[29950]\tlong s.h.e.l.l.S.g(java.io.File)\t8A608h\t8h\tFg: Bg:0x008080\tMethod ID\n\n打开apk的AndroidManifest.xml，跟artmethod打印的顺序是一致的，”s.h.e.l.l.S”是程序的入口\n&lt;application android:theme=&quot;0x7f090002&quot; android:label=&quot;0x7f080000&quot; android:icon=&quot;0x7f020029&quot; android:name=&quot;s.h.e.l.l.S&quot; android:debuggable=&quot;true&quot; android:allowBackup=&quot;true&quot; android:largeHeap=&quot;true&quot;&gt;\n最先执行的两个函数分别是初始化类和对象，当类加载时，JVM会解析类的字节码，并为每个方法生成对应的 ArtMethod 实例。这个过程确保了Java函数和 ArtMethod 是一一对应的关系。每个Java方法都有一个与之对应的 ArtMethod 对象，它负责存储和管理该方法的信息。可以说Java函数和 ArtMethod 是一一对应的关系，它们之间的对应关系是固定的，且在类加载和初始化过程中被建立\n","tags":["脱壳"]},{"title":"Art中的函数inline","url":"/posts/4035/","content":"在art中有大量的inline内联函数，就先来了解什么是inline\n什么是inlineinline： 内联函数是一种优化技术，可以减少函数调用的开销，渐少参数压栈时消耗空间，从而提高代码的执行效率。使用inline关键字声明的函数在编译时会被内联展开，即编译器会在每个调用该函数的地方插入该函数的实际代码，而不是生成函数调用。关键字inline必须与函数定于放在一起才能使函数成为内联函数，仅仅将inline放在函数声明前面是不起任何作用。inline对编译器来水只是一种建议，编译器可以选择忽略这个建议，因此有inline不一定就会被编译器内联编译。ALWAYS_INLINE: 是强制内联，所有加 inline __attribute__((always_inline))   修饰的函数在被调用的时候不会被编译成函数调用，而是直接扩展到调用函数体内。当含有递归的函数在任何情况下都不会被编译器进行inline 编译。\n__attribute__((always_inline)) int add(int a, int b) &#123;    return a + b;&#125;int sum(int m) &#123;    int result = 0;    for (int i = 0; i &lt; m; ++i) &#123;        result = add(result, i);    &#125;    return result;&#125;\n在加与不加__attribute__((always_inline))的情况下，编译后的内容如下\n__int64 __fastcall sum(int a1)&#123;  int i; // [xsp+4h] [xbp-Ch]  unsigned int v3; // [xsp+8h] [xbp-8h]  v3 = 0;  for ( i = 0; i &lt; a1; ++i )    v3 = add(v3, i);  return v3;&#125;__int64 __fastcall add(int a1, int a2)&#123;  return (unsigned int)(a1 + a2);&#125;\n\n\n加了__attribute__((always_inline)) 后的sum函数\n__int64 __fastcall sum(int a1)&#123;    int i; // [xsp+Ch] [xbp-14h]    unsigned int v3; // [xsp+10h] [xbp-10h]    v3 = 0;    for ( i = 0; i &lt; a1; ++i )        v3 += i;    return v3;&#125;\n\n少了 BL add，相比于原来的，汇编指令减少了，也省去了函数调用时栈空间的花销。总结：\n\n内联函数在编译器最终生成的代码中是没有定义的，这个函数是不存在的，也就无法实现对内联函数的hook。\n内联函数没有普通函数调用时的额外开销（压栈，跳转，返回等）\n内联函数是一种特殊的函数，在源码中具有普通函数的特征。\n内联函数是对编译器的一种请求，因此编译器有可能拒绝这种请求。\n内联函数由编译器处理，直接将编译后的函数插入调用的地方。\n内联和宏的效果很像，但是宏代码是由预处理器处理，进行简单的文本替换，没有任何编译过程\n\n基于frida版的art上一篇写了art下DexFile的内存布局，那如何拿到DexFile的对象呢？通过查看源码发现在ART中获取dexfile对象的函数是个inline，那又要怎么去调用呢\ninline const DexFile* ArtMethod::GetDexFile() &#123;  return GetDexCache()-&gt;GetDexFile();&#125;\n当在源码中进行定制ART时，任何inline函数都可以直接访问，只需要注意访问权限即可，那如果是使用frida等hook技术进行ART的定制呢？自然inline函数无法被hook，那当需要这个inline函数的功能时，如何实现inline函数的主动调用呢？两种解决方案：1. 分析inline函数的源码逻辑，自行参考实现即可2. 在源码中添加一个导出函数调用该inline函数，编译后直接参考ida反编译的该函数内容即可实现第二种接下来解决从一个artmethod对象得到一个该对象所属的dexfile对象。在源码 &#x2F;art&#x2F;runtime&#x2F;art_method-inl.h 添加如下代码导出dexfile对象\nextern &quot;C&quot; const DexFile* getDexFileByMethod(ArtMethod* artmethod) SHARED_LOCKS_REQUIRED(Locks::mutator_lock_) &#123;  return artmethod-&gt;GetDexFile();&#125;;\n重新编译，找到编译好后lib32，lib64下的libart.so，ida打开找到添加的函数片段，在nexus 5 android6和pixel android8下\n// nexus5 arm32int __fastcall getDexFileByMethod(int a1)&#123;  return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 16) + 32);&#125;// pixel arm32int __fastcall getDexFileByMethod(int a1)&#123;  int result; // r0  if ( *(_DWORD *)(a1 + 4) &amp; 0x40000 )    result = *((_DWORD *)art::ArtMethod::GetObsoleteDexCache((char *)a1) + 4);  else    result = *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 16) + 16);  return result;&#125;// pixel arm64__int64 __fastcall getDexFileByMethod(art::ArtMethod *a1)&#123;  __int64 result; // x0  if ( *((_DWORD *)a1 + 1) &amp; 0x40000 )    result = *(_QWORD *)(art::ArtMethod::GetObsoleteDexCache(a1) + 16LL);  else    result = *(_QWORD *)(*(unsigned int *)(*(unsigned int *)a1 + 0x10LL) + 0x10LL);  return result;&#125;\n实际是artmethod对象获取dexfile对象inline函数的内联编译生成的片段，现在参考ida反编译的该函数，根据自己的安卓系统版本做调整\n#include &lt;jni.h&gt;#include &lt;string&gt;#include &lt;android/log.h&gt;#define _DWORD uint32_t#define __int64 long long#define _QWORD uint64_t// #if defined(__arm__)// typedef uint32_t (GetObsoleteDexCache)(void *a1);// //arm32 a1=artmethod指针,a2是函数art::ArtMethod::GetObsoleteDexCache(art::ArtMethod *this)的地址// extern &quot;C&quot; JNIEXPORT uint32_t GetDexFile(void *a1, GetObsoleteDexCache funcptr) &#123;//     uint32_t result; // r0//     if (*((_DWORD *) a1 + 1) &amp; 0x40000)//         result = *(_DWORD *) (funcptr(a1) + 16);//     else//         result = *(_DWORD *) (*(_DWORD *) (*(_DWORD *) a1 + 16) + 16);//     return result;// &#125;// #else// typedef uint64_t (GetObsoleteDexCache)(void *a1);// //arm64 a1=artmethod指针,a2是函数art::ArtMethod::GetObsoleteDexCache(art::ArtMethod *this)的地址// extern &quot;C&quot; JNIEXPORT __int64 GetDexFile(void*a1, GetObsoleteDexCache funcptr)// &#123;//     __int64 result; // x0//     if ( *((_DWORD *)a1 + 1) &amp; 0x40000 )//         result = *(_QWORD *)(funcptr(a1) + 16LL);//     else//         result = *(_QWORD *)(*(unsigned int *)(*(unsigned int *)a1 + 0x10LL) + 0x10LL);//     return result;// &#125;// #endif// a1=artmethod指针extern &quot;C&quot; JNIEXPORT uint32_t GetDexFile(void* a1)&#123;    return *(_DWORD *)(*(_DWORD *)(*(_DWORD *)a1 + 16) + 32);&#125;extern &quot;C&quot; JNIEXPORT jstring JNICALLJava_com_example_zsk_MainActivity_stringFromJNI(        JNIEnv* env,        jobject /* this */) &#123;    std::string hello = &quot;Hello from C++&quot;;    return env-&gt;NewStringUTF(hello.c_str());&#125;\n打包解压，把lib目录下的so推送到手机上，修改777权限编写frida脚本\n\n先加载导入的so，枚举该so的导出函数，找到编写的GetDexFile地址\n如果是安卓8及以上，需要枚举libart.so的符号表，找到GetObsoleteDexCache的地址\n声明GetDexFile函数\n通过反射获取任意类的java层函数，通过$handle获取函数的引用，再由jni的函数fromReflectedMethod转为artmethod对象\n将参数传入声明的GetDexFile函数得到dexfile对象\n根据art中的DexFile内存布局dump内容function getDexFileByMethod()&#123;    Java.perform(function()&#123;        console.log(&quot;go into init,&quot; + &quot;Process.arch:&quot; + Process.arch);        var module_libext = null;        // 加载导入的so        if (Process.arch == &quot;arm64&quot;) &#123;            module_libext = Module.load(&quot;/data/local/tmp/libmy_64.so&quot;);        &#125; else if (Process.arch == &quot;arm&quot;) &#123;            module_libext = Module.load(&quot;/data/local/tmp/libmy.so&quot;);        &#125;        var getDexFileByMethodFunc = null;        var getDexFileByMethodAddr = null;        if (module_libext != null) &#123;            module_libext.enumerateExports().forEach(function(symbol)&#123;                // 找到编写的GetDexFile函数                if (symbol.name.indexOf(&quot;GetDexFile&quot;) != -1) &#123;                    console.log(JSON.stringify(symbol))                    getDexFileByMethodAddr = symbol.address;                &#125;            &#125;)        &#125;        if (getDexFileByMethodAddr != null) &#123;            getDexFileByMethodFunc = new NativeFunction(getDexFileByMethodAddr, &quot;pointer&quot;, [&quot;pointer&quot;]);            // 第一个参数是artmethod，第二个参数是GetObsoleteDexCache            // getDexFileByMethodFunc = new NativeFunction(getDexFileByMethodAddr, &quot;pointer&quot;, [&quot;pointer&quot;, &quot;pointer&quot;]);        &#125;        // 找到GetObsoleteDexCache,安卓8及以上才需要        // var GetObsoleteDexCacheAddr = null;        // var libartmodule = Process.getModuleByName(&quot;libart.so&quot;);        // libartmodule.enumerateSymbols().forEach(function(symbol)&#123;        //     if (symbol.name.indexOf(&quot;GetObsoleteDexCache&quot;) != -1) &#123;        //         console.log(JSON.stringify(symbol))        //         GetObsoleteDexCacheAddr = symbol.address;        //     &#125;        // &#125;)                // 通过反射获取任意一个java层函数, 再将函数转为artmethod对象        var MainActivity = Java.use(&quot;com.example.zsk.MainActivity&quot;);        var methods = MainActivity.class.getDeclaredMethods(); // 枚举所有函数        methods.forEach(function (method) &#123;            // console.log(method);            var methodhandle = method.$handle;  // 获取函数引用            console.log(methodhandle)            var ArtMethodPtr = Java.vm.tryGetEnv().fromReflectedMethod(methodhandle)  // 将java函数转为artmethod对象            if (getDexFileByMethodFunc != null) &#123;                var dexfilePtr = getDexFileByMethodFunc(ArtMethodPtr);                // var dexfilePtr = getDexFileByMethodFunc(ArtMethodPtr, GetObsoleteDexCacheAddr);                console.log(method.toString() + &quot;------&quot; + ArtMethodPtr + &quot;------&quot; + dexfilePtr);                var dexfileBegin = ptr(dexfilePtr).add(Process.pointerSize * 1).readPointer();                var dexfileSize = ptr(dexfilePtr).add(Process.pointerSize * 2).readU32();                console.warn(&quot;get a dex:size:&quot; + dexfileSize + &quot;---&quot; + hexdump(dexfileBegin, &#123;                    length: 16                &#125;))                console.log(&quot;go into LoadMethodaddr-&gt;&quot; + hexdump(dexfilePtr, &#123;                    length: 32                &#125;));            &#125;        &#125;)    &#125;)&#125;function main()&#123;    getDexFileByMethod();&#125;setImmediate(main);\n打印内容如下go into init,Process.arch:arm&#123;&quot;type&quot;:&quot;function&quot;,&quot;name&quot;:&quot;GetDexFile&quot;,&quot;address&quot;:&quot;0x9cb9d471&quot;&#125;0x1004c2protected void com.example.zsk.MainActivity.onCreate(android.os.Bundle)------0xb0697cf0------0xab0da3c0get a dex:size:2100---           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF9fc11078  64 65 78 0a 30 33 35 00 ee 74 d8 e6 95 2a 0a 65  dex.035..t...*.ego into LoadMethodaddr-&gt;           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFab0da3c0  e8 3e c3 b4 78 10 c1 9f 34 08 00 00 41 00 00 00  .&gt;..x...4...A...ab0da3d0  32 00 00 00 40 b2 53 ab e5 9a 18 6c 00 00 00 00  2...@.S....l....0x1004depublic native java.lang.String com.example.zsk.MainActivity.stringFromJNI()------0xb0697d18------0xab0da3c0get a dex:size:2100---           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF9fc11078  64 65 78 0a 30 33 35 00 ee 74 d8 e6 95 2a 0a 65  dex.035..t...*.ego into LoadMethodaddr-&gt;           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFab0da3c0  e8 3e c3 b4 78 10 c1 9f 34 08 00 00 41 00 00 00  .&gt;..x...4...A...ab0da3d0  32 00 00 00 40 b2 53 ab e5 9a 18 6c 00 00 00 00  2...@.S....l....\n\n","tags":["脱壳"]},{"title":"Unidbg操作说明","url":"/posts/24643/","content":"补环境的三条准则\n常规object，比如jstring，jarray使用Unidbg封装的API\n除此之外的jobject使用vm.resolveClass(className).newObject(object)，jclass使用vm.resolveClass(className)\n如果object不可得，传空&#x2F;方法签名&#x2F;标识\n\n目录\nAndroidEmulator\nAndroidEmulator介绍\n创建AndroidEmulator实例\nAndroidEmulator操作接口\ngetMemory\ncreateDalvikVM\nloadLibrary\ngetDalvikVM\nshowRegs\ngetBackend\ngetPid\ngetProcessName\ngetContext\nisRunning\nTrace\nSet&#x2F;Get\nSyscallHandler\nDebugger\nemulateSignal\ndisassemble\nclose\ngetUnwinder\n\n\n\n\nMemory\nMemory介绍\nMemory操作\n获取Memory实例\nsetLibraryResolver\nfindModule\nallocateStack\nmalloc\nsetErrno\ngetStackPoint\ndisableCallInitFunction\ngetMemoryMap\npointer\naddModuleListener\nload\n\n\nMemory总结\n\n\nVM\nVM介绍\nVM介绍\nVM接口\n日志控制\n设置JNI\n调用JNI_OnLoad函数\n获取模拟器实例\n获取APK相关信息\n加载模块\n\n\nVM总结\n\n\nCallMethod\n执行JNI函数\n执行任意函数\n执行main函数\nJNI方法封装\nvoid\nboolean\nint\nlong\nfloat\ndouble\n对象类型\n\n\nJNI方法签名\n\n\nHook\nHook介绍\nHook框架分类\nHookZz\n获取HookZz实例\nHookZz API\nwrap\nreplace\ninstrument\n\n\n\n\nDobby\n获取Dobby实例\nDobby API\nreplace\ninstrument\n\n\n\n\nxHook\n获取xHook实例\nxHook API\nregister\nrefresh\n\n\n\n\nWhale\n获取Whale实例\nWhale API\n\n\npatch\n\n\n\n\nJNI\nJNI介绍\n类&#x2F;类型\n对象&#x2F;实例\n包装对象\nString\nArray\nList\n\n\n\n\nModule\nModule介绍\nModule常用的属性\nbase\nname\ncallEntry\nfindSymbolByName\n\n\n\n\nBackend\nBackend介绍\nBackend列表\nUnicorn&#x2F;Unicorn2\n使用Unicorn2后端:\nUnicorn后端特点\n\n\nDynarmic\n使用Dynarmic后端\nDynarmic后端特点\n\n\nHypervisor\n使用Hypervisor后端\nHypervisor后端特点\n\n\nKvm\n使用Kvm后端\nKvm后端特点\n\n\n\n\nBackend接口\n\n\nDebugger\nDebugger介绍\nConsoleDebugger\n使用步骤\n调试指令\n\n\nGDB_SERVER\nANDROID_SERVER_V7\nBlock\n\n\nSyscallHandler\nSyscallHandler介绍\nAPI\n获取SyscallHandler实例\nsetVerbose\naddIOResolver\nsetEnableThreadDispatcher\nsetFileListener\ngetFileIO\n\n\n自处理系统调用\nFileResult\nsuccess\nfailed\nfallback\n\n\n\n\nVirtualModule\nVirtualModule介绍\nunidbg自带虚拟模块\n自定义虚拟模块\n模拟场景\n首次尝试\n处理问题\n完整代码\n\n\n\n\nJnitrace\n使用\njnitrace函数调用返回的是地址的时候\n堆栈检测\n\n\n函数调用的两种方式\n符号调用\n地址调用\n\n\n构建类的两种方式\n类继承的写法\nunidbg补获取系统属性\n文件重定向，实现-IOResolver\n一些常用功能\n反制unidbg\nUnidbg报错\n\n基本框架private final AndroidEmulator emulator;private final VM vm;private final Module module;xxxx() &#123;    // 创建模拟器实例,进程名建议依照实际进程名填写，可以规避针对进程名的校验    emulator = AndroidEmulatorBuilder.for32Bit().setProcessName(&quot;xxxxx&quot;).build();    // 获取模拟器的内存操作接口    final Memory memory = emulator.getMemory();    // 设置系统类库解析    memory.setLibraryResolver(new AndroidResolver(23));    // 创建Android虚拟机,传入APK，Unidbg可以替我们做部分签名校验的工作    vm = emulator.createDalvikVM(new File(&quot;apk路径&quot;));    // 加载目标SO    DalvikModule dm = vm.loadLibrary(new File(&quot;so路径&quot;), true); // 加载so到虚拟内存    //获取本SO模块的句柄,后续需要用它    module = dm.getModule();    vm.setJni(this); // 设置JNI    vm.setVerbose(true); // 打印日志    dm.callJNI_OnLoad(emulator); // 调用JNI OnLoad&#125;;\n\nAndroidEmulatorAndroidEmulator介绍AndroidEmulator是一个抽象的Android模拟器接口。它作为一个枢纽，协调unidbg中大多数模块相互工作，至关重要。我们需要的大多数操作也都需要借助于它。\n创建AndroidEmulator实例AndroidEmulator build = AndroidEmulatorBuilder    // 指定32位CPU    .for32Bit()    // 添加后端，推荐使用Dynarmic，运行速度快，但并不支持某些新特性    .addBackendFactory(new DynarmicFactory(true))    // 指定进程名，推荐以安卓包名做为进程名    .setProcessName(&quot;com.github.unidbg&quot;)    // 设置根路径    .setRootDir(new File(&quot;target/rootfs/default&quot;))    // 生成AndroidEmulator实例    .build();\n\nAndroidEmulator操作接口getMemory// 获取内存操作接口Memory memory = emulator.getMemory();\n获取内存操作接口，关于Memory接口介绍查看Memory。\ngetPid// 获取进程pidint pid = emulator.getPid();\n\ncreateDalvikVM// 创建虚拟机VM vm = emulator.createDalvikVM();// 创建虚拟机并指定APK文件VM vm = emulator.createDalvikVM(new File(&quot;apk file path&quot;));\n创建虚拟机，关于VM的接口查看VM介绍\nloadLibrary//参数一: So或可执行ELF文件//参数二: 是否强制执行Init初始化系列函数Module module = emulator.loadLibrary(new File(&quot;Elf文件路径&quot;), true);//省略参数二，默认为falseModule module = emulator.loadLibrary(new File(&quot;Elf文件路径&quot;));\n\ngetDalvikVM// 获取已创建的虚拟机VM vm = emulator.getDalvikVM();\n获取已创建的虚拟机。\nshowRegs//打印所有寄存器信息emulator.showRegs();//打印指定寄存器信息emulator.showRegs(ArmConst.UC_ARM_REG_R0, ArmConst.UC_ARM_REG_R1);\n打印当前寄存器信息。\ngetBackend// 获取后端CPUBackend backend = emulator.getBackend();\n获取后端，关于后端请查看Backend介绍\ngetProcessName// 获取进程名String processName = emulator.getProcessName();\n获取进程名。\ngetContext// 获取寄存器RegisterContext context = emulator.getContext();\n获取寄存器上下文，关于寄存器上下文介绍请查看RegisterContext介绍。\nisRunning// 是否正在运行boolean running = emulator.isRunning();\n是否正在运行。\nTrace//Trace汇编指令emulator.traceCode();//指定起始结束范围Trace汇编指令。emulator.traceCode(1, 0);//带回调的Trace，每条指令都会回调onInstruction方法emulator.traceCode(1, 0, new TraceCodeListener() &#123;    @Override    public void onInstruction(Emulator&lt;?&gt; emulator, long address, Instruction insn) &#123;        String mnemonic = insn.getMnemonic();        if (mnemonic.equals(&quot;svc&quot;) || mnemonic.equals(&quot;swi&quot;))&#123;            System.out.println(&quot;0x&quot;+Long.toHexString(address)+&quot;执行了svc指令&quot;);        &#125;    &#125;&#125;);//Trace读内存emulator.traceRead();// emulator.traceRead(起始地址，结束地址);  // 哪里做了读取//Trace写内存emulator.traceWrite(); // emulator.traceWrite(起始地址，结束地址);  // 哪里做了赋值\n注意：Trace功能仅支持Unicorn后端引擎如使用带范围的Trace，起始位置大于结束位置将全部进行Trace。与无参方法作用相同。每种Trace都包含了三种重载，参照traceCode()即可。\nSet&#x2F;Getemulator.set(&quot;Test&quot;,this);DocTest test = emulator.&lt;DocTest&gt;get(&quot;Test&quot;);\nemulator内部维护了一个Map，如有全局的对象需要存储，可借助这两个API来操作，无需额外维护Map对象\nSyscallHandlerSyscallHandler&lt;AndroidFileIO&gt; syscallHandler = emulator.getSyscallHandler();\n获取系统调用处理器，其API请查看SyscallHandler介绍。\nDebugger//无参默认CONSOLE调试器Debugger attach = emulator.attach();//指定调试器Debugger attach = emulator.attach(DebuggerType.CONSOLE);public enum  DebuggerType &#123;    //console debugger    CONSOLE,    //gdb server    GDB_SERVER,    //ida android server v7.x    ANDROID_SERVER_V7&#125;\n附加调试器。关于调试器请查看Debugger介绍。\nemulateSignal//参数为SIG_NUM Linux执行 kill -l 查看信号列表boolean success = emulator.emulateSignal(2);\n模拟向进程发送一个信号。\ndisassemble// 参数一: 地址// 参数二: 机器码// 参数三: 是否为Thumb指令// 参数四: 最多处理多少条指令byte[] code = new byte[]&#123;0x00, 0x20&#125;;Instruction[] disassemble = emulator.disassemble(0, code, true, 1);\n如需灵活转换，请使用Capstone，此处只是Capstone的简单封装。disassemble方法的另一重载不推荐大家使用，为Trace而封装的，了解即可。\ncloseemulator.close();\n调用此方法来释放Android虚拟机使用的资源。\ngetUnwinderemulator.getUnwinder().unwind();\n此方法用来打印调用栈\nMemoryMemory介绍Memory内存接口主要提供了两个功能\n\n内存管理\nELF文件的加载\n\n下面我们来介绍下Memory操作的主要接口。\nMemory操作获取Memory实例//emulator为模拟器实例Memory memory = emulator.getMemory();\n\nsetLibraryResolver//指定Android SDK 版本，目前支持19和23两个版本memory.setLibraryResolver(new AndroidResolver(23));\n此接口属于必调用接口。设置SDK版本，管理了Android提供的常用基本so库。如不调用此方法，在处理Elf文件的依赖时，需要自行处理依赖问题。只有So中无任何依赖的情况下可以不调用此方法。\nfindModule//根据名称获取已加载模块Module module = memory.findModule(&quot;libc.so&quot;);//根据模块在内存中的地址查找已加载模块Module module = memory.findModuleByAddress(address);//获取所有已经加载过的模块Collection&lt;Module&gt; loadedModules = memory.getLoadedModules();\n上面两个方法都为获取已加载的模块，需在自行加载模块之后调用。\nallocateStack//参数为申请栈空间的大小UnidbgPointer pointer = memory.allocateStack(0x10);//在栈空间写入数据并返回指针UnidbgPointer pointer = memory.writeStackBytes(new byte[]&#123;0x01, 0x02&#125;);//在栈空间写入字符串并返回指针UnidbgPointer pointer = memory.writeStackString(&quot;doc&quot;);\n不要在程序运行期间修改栈，如果你不清楚在做什么，最好不要自行开辟栈空间，unidbg会自行维护。\nmalloc//参数一: 分配内存的大小//参数二: runtime标志MemoryBlock malloc = memory.malloc(0x10, true);//获取已分配内存的指针来操作该内存UnidbgPointer pointer = malloc.getPointer();//释放已分配的内存malloc.free();\n参数二的runtime标志：true表示使用mmap按页大小分配，相应的调用MemoryBlock.free方法则使用munmap释放。false表示使用libc.malloc分配，相应的调用MemoryBlock.free方法则使用libc.free释放。\nsetErrnomemory.setErrno(UnixEmulator.EPERM); \n如需在模拟执行某函数前需要指定errno，可使用此方法设置。\ngetStackPointlong stackPoint = memory.getStackPoint(); \n返回当前SP寄存器指向的地址。\ndisableCallInitFunctionmemory.disableCallInitFunction();//参数一: 指定是否调用初始化memory.setCallInitFunction(false);\n禁用Elf加载时调用初始化函数。需配合加载模块的forceCallInit参数使用。如不进行上述设置，默认为true。\ngetMemoryMapCollection&lt;MemoryMap&gt; memoryMap = memory.getMemoryMap();//打印当前内存映射情况for (MemoryMap map : memoryMap)&#123;    System.out.println(map);&#125;\n获取内存映射信息，所有正在使用的内存块都维护在此Map中。\npointerUnidbgPointer pointer = memory.pointer(0x40000000);UnidbgPointer pointer2 = UnidbgPointer.pointer(emulator, 0x40000000);\n在unidbg中，可以借助unidbgPointer封装的API来读写内存，此API供已知地址的情况下，获得一个指针指向已知地址，继而进行操作。可以理解为指哪打哪。具体内存读写操作请查看UnidbgPointer。\naddModuleListenermemory.addModuleListener(new ModuleListener() &#123;    @Override    public void onLoaded(Emulator&lt;?&gt; emulator, Module module) &#123;        System.out.println(module.name + &quot;已被加载&quot;);    &#125;&#125;);\n添加一个模块加载监听器，当一个新模块被加载后，会回调ModuleListener的onLoaded方法，用来感知某模块加载。一般用于想在某个模块加载后接着进行hook的操作。需在模块加载前设置，否则无效。\nloadModule module = memory.load(new File(&quot;文件地址&quot;)); \n其余几个重载就不介绍了，emulator接口提供的模块加载API和VM提供的加载API底层都基于此，仅是对此API的一层封装。\nMemory总结Memory模块封装了关于内存管理的各个接口，其余未介绍的方法不推荐大家使用，多为unidbg内部封装的功能。\nVMVM介绍如果要加载的模块中存在JNI交互的场景，需要创建VM。VM主要的作用就是代理了一套JNI，在模拟执行的过程中，如果需要借助JNI来操作Java层，就少不了VM的帮助。\nVM创建在AndroidEmulator一节我们介绍过，主要有两种创建VM的方式\n//创建虚拟机VM dalvikVM = emulator.createDalvikVM();//创建虚拟机并指定APK文件VM dalvikVM = emulator.createDalvikVM(new File(&quot;apk file path&quot;));\n推荐使用指定APK文件进行创建，某些API需要指定APK文件才可使用。\nVM接口日志控制//设置是否输出JNI运行日志 vm.setVerbose(true);\n此开关只控制VM的日志，主要表现为JNI交互的详细日志。\n设置JNI//设置JNI接口 dalvikVM.setJni(this);\n如程序中存在使用JNI的接口，必须设置JNI。推荐自实现的类继承AbstractJni类，此类封装了绝大部份常用的方法，免去部分繁杂的内容。如签名校验(需指定APK文件创建VM)、常用JDK操作等。 关于JNI部分请查看JNI介绍\n调用JNI_OnLoad函数// 参数一: 模拟器实例 // 参数二: 要执行JNI_OnLoad函数的模块 dalvikVM.callJNI_OnLoad(emulator,module);\n对JNI_OnLoad函数进行模拟执行。如某些JNI方法在JNI_OnLoad函数进行动态绑定需调用此函数后才能够调用JNI方法，推荐加载模块后紧接执行此方法。\n获取模拟器实例Emulator&lt;?&gt; emulator = dalvikVM.getEmulator(); \n\n获取APK相关信息//指定APK文件以后，可调用该方法获取资源文件byte[] bytes = dalvikVM.openAsset(&quot;fileName&quot;);//指定APK文件以后，可调用该方法获取APK包名String packageName = dalvikVM.getPackageName();//指定APK文件以后，可调用该方法获取APK版本名称String versionName = dalvikVM.getVersionName();//指定APK文件以后，可调用该方法获取APK版本号long versionCode = dalvikVM.getVersionCode();//指定APK文件以后，可调用该方法获取Manifest清单信息String manifestXml = dalvikVM.getManifestXml();\n\n加载模块//参数一: 模块名称//参数二: 是否强制执行Init初始化DalvikModule docModule = dalvikVM.loadLibrary(&quot;doc&quot;, true);//参数一: 模块名称//参数二: 要加载模块的字节数据//参数三: 是否强制执行Init初始化DalvikModule docModule = dalvikVM.loadLibrary(&quot;doc&quot;, soFile.getBytes(), true);\nVM同样能够加载Elf模块，具体的差异就是如果指定了APK文件，可以使用上述第一个重载方法指定模块名称，unidbg会自行从APK文件中提取该So文件进行加载。第二个重载方法使用较少，指定byte[]数据进行加载，名称由参数一指定。返回一个DalvikModule实例，可调用JNI_OnLoad函数:\ndocModule.callJNI_OnLoad(emulator); \n该实例还维护了一个Module实例，可使用下面方法获取。\nModule module = docModule.getModule(); \n有关Module实例请查看Module\nVM总结上述的几个接口主要来控制VM或获取APK文件信息，VM其中的方法不止于这些，我们留到JNI部分来介绍，因为其他的几个方法都是有关于JNI交互场景的，也就是unidbg中的环境问题。unidbg补环境、JNI交互请查看JNI介绍\nCallMethod执行JNI函数\n我们首先来写一段小案例来说明如何在unidbg中执行JNI函数\n\nJava层:\npackage com.github.unidbg;public class Test &#123;    static &#123;        System.loadLibrary(&quot;native-doc&quot;);    &#125;    public native String jnitest(String arg);&#125;\nSo层:\n#include &lt;jni.h&gt;#include &lt;string&gt;using namespace std;extern &quot;C&quot;JNIEXPORT jstring JNICALLJava_com_github_unidbg_Test_jnitest(JNIEnv *env, jobject thiz, jstring arg) &#123;    const char *c_arg = env-&gt;GetStringUTFChars(arg, nullptr);    string hello = &quot;unidbg:&quot;;    hello.append(c_arg);    return env-&gt;NewStringUTF(hello.c_str());&#125;\n非常简单的一段小例子，我们就以该例子来说明如何调用libnative-doc.so中的jnitest函数。\n\n第一步: 创建一个DvmObject，此对象相当于在Java层去调用native函数的类的实例对象\n//创建一个类的实例对象DvmObject&lt;?&gt; obj = vm.resolveClass(&quot;com/github/unidbg/Test&quot;).newObject(null);\n关于实例对象的介绍请查看JNI对象&#x2F;实例\n\n第二步: 使用该对象调用JNI方法\n//参数一: Emulator实例//参数二: 方法的签名//参数三: 可变参数，传需要向该方法传递的参数boolean result = obj.callJniMethodObject(emulator, &quot;jnitest(Ljava/lang/String;)Ljava/lang/String;&quot;, &quot;yyds!&quot;);\n我们拥有了一个实例对象，就可以像在Java中那样来调用native方法了，针对Java层中不同返回值调用的API不同，请查看JNI方法封装参数二是方法的签名，此参数如何填写请查看JNI方法签名\n\n\n执行任意函数当我们想执行的函数并非导出函数，也可使用地址进行调用，请自行参考unidbg对JNI函数调用的封装，自行实现此部分。\n执行main函数如果加载的文件是一个可执行文件，需要持有该文件被加载后返回的Module实例来调用callEntry方法，请查看Module\nJNI方法封装voidDvmClass testClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);DvmObject&lt;?&gt; obj = testClass.newObject(null);//调用void返回值的函数testClass.callStaticJniMethod(emulator, &quot;signature&quot;, args);obj.callJniMethod(emulator,&quot;signature&quot;, args);\n\nbooleanDvmClass testClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);DvmObject&lt;?&gt; obj = testClass.newObject(null);//调用boolean返回值的函数boolean ret = testClass.callStaticJniMethodBoolean(emulator, &quot;signature&quot;, args);boolean ret = obj.callJniMethodBoolean(emulator, &quot;signature&quot;, args);\n\nintDvmClass testClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);DvmObject&lt;?&gt; obj = testClass.newObject(null);//调用int返回值的函数int ret = testClass.callStaticJniMethodInt(emulator, &quot;signature&quot;, args);int ret = obj.callJniMethodInt(emulator, &quot;signature&quot;, args);\n\nlongDvmClass testClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);DvmObject&lt;?&gt; obj = testClass.newObject(null);//调用long返回值的函数long ret = testClass.callStaticJniMethodLong(emulator, &quot;signature&quot;, args);long ret = obj.callJniMethodLong(emulator, &quot;signature&quot;, args);\n\nfloatDvmClass testClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);DvmObject&lt;?&gt; obj = testClass.newObject(null);int ret = testClass.callStaticJniMethodInt(emulator, &quot;signature&quot;, args);int ret = obj.callJniMethodInt(emulator, &quot;signature&quot;, args);\n先拿到4字节的int数据，然后将其转换\nByteBuffer allocate = ByteBuffer.allocate(4);allocate.putInt(ret);allocate.flip();float f_ret = allocate.getFloat();\n\ndoubleDvmClass testClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);DvmObject&lt;?&gt; obj = testClass.newObject(null);long ret = testClass.callStaticJniMethodLong(emulator, &quot;signature&quot;, args);long ret = obj.callJniMethodLong(emulator, &quot;signature&quot;, args);\n先拿到8字节的long数据，然后将其转换\nByteBuffer allocate = ByteBuffer.allocate(8);allocate.putLong(ret);allocate.flip();double d_ret = allocate.getDouble();\n\n对象类型DvmClass testClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);DvmObject&lt;?&gt; obj = testClass.newObject(null);//调用对象类型返回值的函数DvmObject&lt;?&gt; ret = testClass.callStaticJniMethodObject(emulator, &quot;signature&quot;, args);DvmObject&lt;?&gt;  ret = obj.callJniMethodObject(emulator, &quot;signature&quot;, args);\n基本类型外的所有类型都为对象类型，包括基本类型的数组类型\nJNI方法签名通过类名与方法签名的配合，才能定位到唯一的函数。所以一定要将方法签名填写正确，unidbg才可以找到对应的函数，所有的类型都按JNI本身定义的签名一致。\n\n\n\nJava类型\n类型签名\n\n\n\nboolean\nZ\n\n\nbyte\nB\n\n\nchar\nC\n\n\nlong\nJ\n\n\nfloat\nF\n\n\ndouble\nD\n\n\nshort\nS\n\n\nint\nI\n\n\n类\nL全限定类名;\n\n\n数组\n[元素类型签名\n\n\nunidbg方法签名如下格式:方法名(参数列表)返回值 举个例子:\npublic native String jnitest(String arg);\n对应的方法签名为:\njnitest(Ljava/lang/String;)Ljava/lang/String;\n\n\n\nHookHook介绍Hook模块为unidbg引入第三方Hook框架而封装的一个模块，使用它可以快速对目标So进行hook操作。而API基本与第三方Hook框架保持一致。如果是32位程序，要注意Hook目标地址是否为Thumb模式，手动处理+1操作。\nHook框架分类HookZzHookZz为Dobby的前身，32位模式下推荐使用HookZz。支持inline hook。\n获取HookZz实例HookZz hook = HookZz.getInstance(emulator);\n在使用任何Hook框架之前都需要拿到unidbg对该Hook框架的封装实例。\nHookZz APIwrapwrap的作用相当于在目标地址进行一层包装，回调到我们的代码，可以对其打印当前参数或寄存器的值。\n// 1.获取HookZz实例HookZz hookZz = HookZz.getInstance(emulator);// 2.创建hook触发回调WrapCallback&lt;HookZzArm32RegisterContextImpl&gt; wrapCallback = new WrapCallback&lt;HookZzArm32RegisterContextImpl&gt;() &#123;    @Override    public void preCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContextImpl ctx, HookEntryInfo info) &#123;        //hook函数进入前回调        System.out.println(&quot;arg0:&quot; + ctx.getIntArg(0));    &#125;        @Override    public void postCall(Emulator&lt;?&gt; emulator, HookZzArm32RegisterContextImpl ctx, HookEntryInfo info) &#123;        //hook函数返回后回调        System.out.println(&quot;ret:&quot; + ctx.getIntArg(0));    &#125;&#125;;// 3.wraplong functionAddress = module.base + 0xC09D/*偏移*/;hookZz.wrap(functionAddress, wrapCallback);// 3.wrap重载, hook导出符号Symbol symbol = module.findSymbolByName(&quot;symbolName&quot;);hookZz.wrap(symbol, wrapCallback);\n\nreplacereplace可以进行替换目标函数。\n//获取HookZz实例HookZz hookZz = HookZz.getInstance(emulator);//创建replace触发回调ReplaceCallback replaceCallback = new ReplaceCallback() &#123;    @Override    public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) &#123;        //函数调用前回调。上层会根据HookStatus来决定程序流程        //先来介绍几个参数        //emulator: 模拟器实例        //context: Hook上下文，可根据此参数获取各种参数。也可存储临时数据。        //originFunction: 原函数地址                //获取参数一并打印        int arg0 = context.getIntArg(0);        System.out.println(&quot;arg0:&quot;+arg0);                //获取指针参数二并存入context        context.push(context.getPointerArg(1));                //修改参数三的值为0        EditableArm32RegisterContext ctx = (EditableArm32RegisterContext) context;        ctx.setR2(0);                //可以在此改变函数流程        long newFuncAddr = module.base + 0xDC0/*偏移*/;        return HookStatus.RET(emulator, newFuncAddr);                /*        //也可以直接返回一个值而不调用函数        long retValue = 0L;        return HookStatus.LR(emulator, retValue);        */    &#125;        @Override    public void postCall(Emulator&lt;?&gt; emulator, HookContext context) &#123;        //此回调会根据hookZz.replace方法的第三个参数enablePostCall决定        //可以获取context存储的数据        UnidbgPointer arg2 = context.pop();        //可在此修改函数返回值        super.postCall(emulator, context);    &#125;&#125;;long functionAddress = module.base + 0xC09D/*偏移*/;//对目标地址进行inline hook, 并传入回调实例hookZz.replace(functionAddress, replaceCallback);//replace重载，第三个参数控制是否可以修改返回值hookZz.replace(functionAddress, replaceCallback, true);Symbol symbol = module.findSymbolByName(&quot;symbolName&quot;);//使用符号进行hookhookZz.replace(symbol, replaceCallback);hookZz.replace(symbol, replaceCallback, true);\n\ninstrumentinstrument提供了一种对单行汇编进行Hook的能力，使用场景较少。\n//获取HookZz实例HookZz hookZz = HookZz.getInstance(emulator);//创建InstrumentCallback实例InstrumentCallback&lt;RegisterContext&gt; instrumentCallback = new InstrumentCallback&lt;RegisterContext&gt;() &#123;    @Override    public void dbiCall(Emulator&lt;?&gt; emulator, RegisterContext ctx, HookEntryInfo info) &#123;        System.out.println(ctx.getIntArg(0));    &#125;&#125;;long functionAddress = module.base + 0xC09D/*偏移*/;//对单行地址进行hookhookZz.instrument(functionAddress, instrumentCallback);Symbol symbol = module.findSymbolByName(&quot;symbolName&quot;);hookZz.instrument(symbol, instrumentCallback);\n\nDobby64位模式下推荐使用Dobby进行inline hook。\n获取Dobby实例Dobby dobby = Dobby.getInstance(emulator);\n\nDobby APIreplaceDobby dobby = Dobby.getInstance(emulator);long functionAddress = module.base + 0xC09D/*偏移*/;dobby.replace(functionAddress, new ReplaceCallback() &#123;    @Override    public HookStatus onCall(Emulator&lt;?&gt; emulator, HookContext context, long originFunction) &#123;        Pointer result = context.getPointerArg(0);        System.out.println(&quot;input:&quot; + result.getString(0));        return super.onCall(emulator, context, originFunction);    &#125;    @Override    public void postCall(Emulator&lt;?&gt; emulator, HookContext context) &#123;        super.postCall(emulator, context);    &#125;&#125;,true);\nDobby.replace的用法同HookZz，详细使用请查看HookZz-replace\ninstrument同HookZz中的instrument。\nxHookxHook框架实现原理本身就存在局限性，只能够hook符号表函数。有好有坏，它的优点就是稳定。\n获取xHook实例IxHook hook = XHookImpl.getInstance(emulator);\n\nxHook APIregisterIxHook hook = XHookImpl.getInstance(emulator);\nxHook的register方法的第一个参数为pathname_regex_str, 其支持POSIX BRE (Basic Regular Expression) 定义的正则表达式语法。用来检索符合条件的So。第二个参数为符号名。详情请看xhook介绍\nrefreshhook.refresh(); \n在使用xHook进行hook时，务必调用此方法进行刷新才能生效。\nWhaleWhale Hook框架为跨平台的Hook框架，在Android中的实现为inline hook。\n获取Whale实例IWhale whale &#x3D; Whale.getInstance(emulator); \nWhale APITODO\n原生hookemulator.attach().addBreakPoint(module.findSymbolByName(&quot;memcmp&quot;).getAddress(), new BreakPointCallback() &#123;    @Override    public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;        System.out.println(&quot;callMemcmp作比较&quot;);        RegisterContext registerContext = emulator.getContext();        UnidbgPointer arg1 = registerContext.getPointerArg(0);        UnidbgPointer arg2 = registerContext.getPointerArg(1);        int length = registerContext.getIntArg(2);        Inspector.inspect(arg1.getByteArray(0, length), &quot;arg1&quot;);        Inspector.inspect(arg2.getByteArray(0, length), &quot;arg2&quot;);        if (arg1.getString(0).equals(&quot;Context&quot;))&#123;            emulator.attach().debug();            // mr1        &#125;        return true;    &#125;&#125;);\n\npatch第一种，使用arm转机器码转换网址 https://armconverter.com/\npublic void patch()&#123;    UnidbgPointer pointer = UnidbgPointer.pointer(emulator,module.base + 0x3E8);    byte[] code = new byte[]&#123;(byte) 0xd0, 0x1a&#125;;    pointer.write(code);&#125;\n第二种，使用keystone\npublic void patch2()&#123;    UnidbgPointer pointer = UnidbgPointer.pointer(emulator,module.base + 0x3E8);    Keystone keystone = new Keystone(KeystoneArchitecture.Arm, KeystoneMode.ArmThumb);    String s = &quot;subs r0, r2, r3&quot;;    byte[] machineCode = keystone.assemble(s).getMachineCode();    //byte[] code = ;    pointer.write(machineCode);&#125;\n\nJNIJNI介绍当一个So在模拟执行的过程中，它要与Java层进行交互，比如获取Java层某个字段的值、调用Java层的某个方法获取返回值等等，如果你不告诉unidbg如何做，那程序就无法执行下去。你告诉undibg碰到访问Java层的某些东西的时候该怎么做的这个过程，从而让程序正确的执行下去，就叫做补环境。我们在JNI部分来介绍unidbg如何来补环境，首先我们要来看unidbg中的几个概念\n类&#x2F;类型Java中可以抽象出一个类，一个类可以创建对象，可以调用该类上的静态方法。一个类的基本属性有很多，unidbg模拟了父类和接口。在unidbg中对应的为DvmClass。\n//参数一: 类名DvmClass Test = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);//重载方法，可以指定父类型。也就是表示了TestUnidbg继承了Test类。DvmClass dvmClass = vm.resolveClass(&quot;com/github/unidbg/TestUnidbg&quot;, Test);\nVM的resolveClass方法会创建出一个类型，可以理解为Java中的一个类，参数为全限定类名，将.换为&#x2F;。这样就创建出来一种类型了。我们可以基于此类型创建对象。\n对象&#x2F;实例Java层肯定会有对象的，或者叫做实例，unidbg中对应的叫做DvmObject。unidbg中所有的Java层的对象都直接或间接的继承自DvmObject。模拟创建对象:\n\n第一种方法\nDvmClass dvmClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);//参数一: 值DvmObject&lt;?&gt; obj = dvmClass.newObject(null);\n在Java中，有了类，就可以new对象了对吧。unidbg的newObject操作就类似这样。它可以有了一种类型后进行创建对象，其中的参数你可以存储任意类型的数据，此数据就会与该DvmObject绑定。\n\n第二种方法\n//根据数据来创建DvmObject//参数一: VM实例//参数二: valueDvmObject&lt;?&gt; obj = ProxyDvmObject.createObject(vm, this);\nunidbg会根据此value值的类型来创建DvmObject。如果value为基本数据类型则会被封装为该基本类型的包装类型。如果value为一个对象，则会获取该对象所对应的Class，根据Class名称来自动创建该类型，然后创建一个对象，相当于对第一种方法的一个封装。如果为数组类型，则会被封装为由unidbg创建的包装对象。\n\n\n包装对象理论上所有的Java层的对象在unidbg中都可以按照上面所述的方法进行创建。但unidbg内部有部分封装，所以在使用的时候我们要使用unidbg的包装对象\nStringString类型被封装为StringObject\nnew StringObject(vm,&quot;unidbg&quot;); \n\nArray数组类型在使用的时候按如下使用\n//byte[]ByteArray byteArray = new ByteArray(vm, new byte[]&#123;1, 2, 3&#125;);//int[]IntArray intArray = new IntArray(vm, new int[]&#123;1, 2, 3&#125;);//short[]ShortArray shortArray = new ShortArray(vm, new short[]&#123;1, 2, 3&#125;);//float[]FloatArray floatArray = new FloatArray(vm, new float[]&#123;1.0f, 2.0f, 3.0f&#125;);//double[]DoubleArray doubleArray = new DoubleArray(vm, new double[]&#123;1.0d, 2.0d, 3.0d&#125;);//Object[]new ArrayObject(byteArray, intArray);\n\nListList类型的数据被封装为ArrayListObject\nDvmClass Test = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);List&lt;DvmObject&lt;?&gt;&gt; list = new ArrayList&lt;&gt;();list.add(Test.newObject(null));new ArrayListObject(vm,list);\n\n\n\nModuleModule介绍在undibg中，经过Memory加载到内存中的Elf文件，都被抽象为一个Module(LinuxModule)对象。无论是Emulator还是VM加载的，底层都是对Memory的load进行了封装，返回值就是一个Module实例。\nModule常用的属性baseModule module = emulator.loadLibrary(file, true);System.out.println(&quot;加载的基址: &quot;+module.base);\nbase属性维护了该Elf文件被加载到内存中的基址。\nnameModule module = emulator.loadLibrary(file, true);System.out.println(&quot;模块的名称: &quot;+module.name);\nname属性维护了该模块的名称，通常为文件名。\ncallEntryModule module = emulator.loadLibrary(file, true);int ret = module.callEntry(emulator);\n当被加载的文件是可执行文件时，需要通过该方法来调用main函数。\nfindSymbolByNameModule module = emulator.loadLibrary(file, true);Symbol symbol = module.findSymbolByName(&quot;symbolName&quot;);\n通过名字查找当前模块中的符号。\nBackendBackend介绍unidbg内置了五种Backend。Backend的作用是用来模拟执行机器指令。它作为一个模块被unidbg引入，提供了模拟CPU的能力，且被封装为统一的Backend接口。\nBackend列表unidbg默认使用Unicorn后端。即在创建AndroidEmulator时无额外添加BackendFactory即为Unicorn后端。\nUnicorn&#x2F;Unicorn2Unicorn官网\n使用Unicorn2后端:emulator &#x3D; AndroidEmulatorBuilder           .for32Bit()           .addBackendFactory(new Unicorn2Factory(true))           .build();Unicorn2Factory构造方法的参数表示在Unicorn2创建失败时，是否退回使用Unicorn后端。如设置false，在Unicorn2后端创建失败后就退出，而不选择使用Unicorn后端。\nUnicorn后端特点\n执行较其他后端慢\n支持原生Hook\n支持Debugger功能\n支持原生Trace\n\n对调试、Trace功能支持较好，缺点是执行较慢。推荐在实验环境中使用。\nDynarmicDynarmic官网\n使用Dynarmic后端emulator = AndroidEmulatorBuilder          .for32Bit()          .addBackendFactory(new DynarmicFactory(true))          .build();\n\nDynarmic后端特点\n执行速度快\n无原生Hook功能\n\n生产环境推荐使用，速度比Unicorn快很多。\nHypervisorHypervisor官网\n使用Hypervisor后端emulator = AndroidEmulatorBuilder          .for32Bit()          .addBackendFactory(new HypervisorFactory(true))          .build()\n\nHypervisor后端特点\n支持Apple M1\n最快的ARM64后端\n\nKvmKvm官网\n使用Kvm后端emulator = AndroidEmulatorBuilder          .for64Bit()          .addBackendFactory(new KvmFactory(false))          .build();\n\nKvm后端特点\n支持Raspberry Pi B4\n\nBackend接口Backend为CPU的抽象接口，通过它可以直接读写CPU的寄存器的值、内存读写。unidbg对此类接口都有对应的封装，不建议直接使用此类接口。\nDeggbuerDebugger介绍重要提醒: 只有unicorn后端支持调试功能！！！ 重要提醒: 只有unicorn后端支持调试功能！！！ 重要提醒: 只有unicorn后端支持调试功能！！！调试是在逆向工程中不可缺少的一个功能，可以帮助我们快速定位问题。在unidbg也是支持的，而且这部分功能基于原生Unicorn后端，支持非常好。主要功能:\n\n断点调试\n内存读写\n寄存器读写\n单步调试\n堆栈搜索\n调用栈打印\n反汇编\npatch\n\nConsoleDebugger使用步骤第零步再提示一下，先将后端切换回Unicorn。如何切换请查看: Backend\n第一步得到控制台调试器实例。\nDebugger debugger = emulator.attach();\n\n第二步下断点。下断点有多种重载方便使用:\n\n模块 + 偏移\n模块 + 符号名\n绝对地址//模块 + 偏移debugger.addBreakPoint(module, 0x8607);//模块 + 符号debugger.addBreakPoint(module, &quot;Java_com_github_unidbg_Test_sign&quot;);// 绝对地址long address = module.base + 0x8607;debugger.addBreakPoint(address);\n下断点无需手动thumb指令+1操作，手动+1下断点也是一样的效果。但手动+1会有其他的作用，如查看断点等功能，推荐手动+1。还有其他三种断点重载，添加一个断点回调:BreakPointCallback breakPointCallback = new BreakPointCallback() &#123;    @Override    public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;      //当断点命中会回调此方法      //do something...      //返回值决定是否进入手动调试。      //返回true，则只回调此方法，不进入调试      return false;    &#125;&#125;;debugger.addBreakPoint(module, 0x8607, breakPointCallback);debugger.addBreakPoint(module, &quot;Java_com_github_unidbg_Test_sign&quot;, breakPointCallback);long address = module.base + 0x8607;debugger.addBreakPoint(address, breakPointCallback);\n\n第三步执行。无论使用哪种方式对目标地址下断点，在执行起来后如果执行到断点位置，就会在控制台断下等待命令的输入。以我目前例子，命中断点后输出如下所示:\ndebugger break at: 0x40008606 @ Function32 address=0x40008607, arguments=[unidbg@0xfffe12a0[libadd.so]0x2a0, 17037394, 1]&gt;&gt;&gt; r0=0xfffe12a0(-126304) r1=0x103f852 r2=0x1 r3=0x2 r4=0x0 r5=0x0 r6=0x0 r7=0x0 r8=0x0 sb=0x0 sl=0x0 fp=0x0 ip=0x401315e0&gt;&gt;&gt; SP=0xbffff730 LR=unidbg@0xffff0000 PC=RX@0x40008606[libnative-doc.so]0x8606 cpsr: N=0, Z=1, C=0, V=0, T=1, mode=0b10000&gt;&gt;&gt; d0=0x0(0.0) d1=0x3220302034203720(3.002229861217884E-67) d2=0x3436333832203236(3.5366761868402984E-57) d3=0x3120323938343135(4.583358096989596E-72) d4=0x2030203020302030(1.2027122125173386E-153) d5=0x2030203020302030(1.2027122125173386E-153) d6=0x2030203020302030(1.2027122125173386E-153) d7=0x2030203020302030(1.2027122125173386E-153)&gt;&gt;&gt; d8=0x0(0.0) d9=0x0(0.0) d10=0x0(0.0) d11=0x0(0.0) d12=0x0(0.0) d13=0x0(0.0) d14=0x0(0.0) d15=0x0(0.0)Java_com_github_unidbg_Test_sign + 0x0=&gt; *[libnative-doc.so*0x08607]*[80b5    ]*0x40008606:*&quot;push &#123;r7, lr&#125;&quot;    [libnative-doc.so 0x08609] [6f46    ] 0x40008608: &quot;mov r7, sp&quot;    [libnative-doc.so 0x0860b] [84b0    ] 0x4000860a: &quot;sub sp, #0x10&quot;    [libnative-doc.so 0x0860d] [0390    ] 0x4000860c: &quot;str r0, [sp, #0xc]&quot;    [libnative-doc.so 0x0860f] [0291    ] 0x4000860e: &quot;str r1, [sp, #8]&quot;    [libnative-doc.so 0x08611] [0192    ] 0x40008610: &quot;str r2, [sp, #4]&quot;    [libnative-doc.so 0x08613] [0198    ] 0x40008612: &quot;ldr r0, [sp, #4]&quot;    [libnative-doc.so 0x08615] [4ff48061] 0x40008614: &quot;mov.w r1, #0x400&quot;    [libnative-doc.so 0x08619] [fff75aec] 0x40008618: &quot;blx #0x40007ed0&quot;    [libnative-doc.so 0x0861d] [04b0    ] 0x4000861c: &quot;add sp, #0x10&quot;    [libnative-doc.so 0x0861f] [80bd    ] 0x4000861e: &quot;pop &#123;r7, pc&#125;&quot;    [libnative-doc.so 0x08621] [80b5    ] 0x40008620: &quot;push &#123;r7, lr&#125;&quot;    [libnative-doc.so 0x08623] [6f46    ] 0x40008622: &quot;mov r7, sp&quot;    [libnative-doc.so 0x08625] [82b0    ] 0x40008624: &quot;sub sp, #8&quot;    [libnative-doc.so 0x08627] [0190    ] 0x40008626: &quot;str r0, [sp, #4]&quot;    [libnative-doc.so 0x08629] [0198    ] 0x40008628: &quot;ldr r0, [sp, #4]&quot;\n主要信息有: 断点和当前函数参数信息，当前所有寄存器信息，当前位置的反汇编信息。 看到如上调试信息后，unidbg就会等待命令的输入，命令才是ConsoleDebugger的核心。下面我们就来看如何使用命令来操作ConsoleDebugger。\n调试指令helphelp \n会看到下面的输出，此为ConsoleDebugger的帮助文档。我们下面也是介绍此帮助文档的内容。\nhelpc: continuen: step overbt: back tracest hex: search stackshw hex: search writable heapshr hex: search readable heapshx hex: search executable heapnb: break at next blocks|si: step intos[decimal]: execute specified amount instructions(blx): execute util BLX mnemonic, low performancem(op) [size]: show memory, default size is 0x70, size may hex or decimalmr0-mr7, mfp, mip, msp [size]: show memory of specified registerm(address) [size]: show memory of specified address, address must start with 0xwr0-wr7, wfp, wip, wsp &lt;value&gt;: write specified registerwb(address), ws(address), wi(address) &lt;value&gt;: write (byte, short, integer) memory of specified address, address must start with 0xwx(address) &lt;hex&gt;: write bytes to memory at specified address, address must start with 0xb(address): add temporarily breakpoint, address must start with 0x, can be module offsetb: add breakpoint of register PCr: remove breakpoint of register PCblr: add temporarily breakpoint of register LRp (assembly): patch assembly at PC addresswhere: show java stack tracetrace [begin end]: Set trace instructionstraceRead [begin end]: Set trace memory readtraceWrite [begin end]: Set trace memory writevm: view loaded modulesvbs: view breakpointsd|dis: show disassembled(0x): show disassemble at specify addressstop: stop emulationrun [arg]: run testgc: Run System.gc()cc size: convert asm from 0x40008608 - 0x40008608 + size bytes to c function\nshrshr 637c777bf26b6fc5\n内存查找字节\nshow disassembled | dis\n打印当前位置反编译信息。\nd(address)//如d0x40008607\n打印指定地址处的反编译信息。\ncontinuec\n继续执行。直至遇到下一个断点断下或运行结束。\nstep overn\n单步步过，不进入跳转指令。\nstep intos | si \n单步执行。执行一句指令。\ns10 \n执行10句指令。\nsblx \n执行到blx指令。性能较低。\nnext blocknb \n执行到下一block处。\nbb \n可在当前PC处下断点。\nb0x40008607 \n指定地址下断点。\nb0x8607 \n指定偏移下断点，会根据当前位置的模块来计算。\nblr \n在LR处下断点。\nrr \n删除当前位置的断点。\nblr在函数返回时候下断点\nvbsvbs \n查看当前下的所有断点。\nback tracebt \n打印当前位置调用栈。\nshow memorymr0-mr7 | mfp | mip | msp [size]//如mr1 0x10\n读取对应寄存器所指向的地址的内存。size指定大小，默认0x70大小。\nm(address) [size]//如m0xbffff730 10\n读取指定地址的内存。地址必须为0x开头的十六进制数。\nwrite memorywr0-wr7, wfp, wip, wsp &lt;value&gt;//如wr2 0x100\n向对应寄存器写入value指定的值。此值可为0x开头十六进制数，可为十进制数。\nwb(address), ws(address), wi(address) &lt;value&gt;//如wb0x40008606 1ws0x40008606 0xb502\n向指定地址写入value指定的值。写入的宽度由不同指令所指定，wb能写入一个字节数据、ws能short数据、wi能写入int数据，且大小端序会被自动转换。\nwx(address) &lt;hex&gt;//如wx0x40008606 b502\n向指定地址写入hex数据，此处hex不能加0x开头，直接写十六进制就可以了。\nsearch stackst &lt;hex&gt;//如st 313233\n在当前栈上搜索指定的hex数据。\nsearch writable heapshr &lt;hex&gt;//如shr 313233\n在可写的内存搜索指定的hex数据。\nsearch readable heapshx &lt;hex&gt;//如shx 6f46\n在可读的内存搜索指定的hex数据。\nsearch executable heapshx &lt;hex&gt;//如shx 6f46\n在可执行的内存搜索指定的hex数据。\nwherewhere \n打印当前unidbg的调用栈。\nvmvm \n查看当前所有加载的模块。\nstopstop \n停止运行。\npatchp &lt;assembly&gt;//如p movs r0, #1\n将当前位置进行patch，无需关心thumb。\ntracetrace [begin end]//如trace 0x40008606 0x40008612traceRead [begin end]traceWrite [begin end]\n指定起始结束位置进行trace。\nGDB_SERVER不推荐使用。请使用ConsoleDebugger。\nANDROID_SERVER_V7不推荐使用。请使用ConsoleDebugger。\nBlock什么叫做block？简单来说就是未发生跳转的一整段汇编为一个block，如发生B系列指令跳转，就会进入下一block。\nRegisterContextTODO\nSyscallHandlerSyscallHandler介绍SyscallHandler模块为处理系统调用处理器的核心模块，模拟了在执行过程中所产生的大大小小的系统调用。虽然该模块为核心模块，但提供的API并不多，我们来看。\nAPI获取SyscallHandler实例SyscallHandler&lt;AndroidFileIO&gt; syscallHandler = emulator.getSyscallHandler(); \n\nsetVerbosesyscallHandler.setVerbose(true); \n部分系统调用日志开关。\naddIOResolversyscallHandler.addIOResolver(new IOResolver&lt;AndroidFileIO&gt;() &#123;    @Override    public FileResult&lt;AndroidFileIO&gt; resolve(Emulator&lt;AndroidFileIO&gt; emulator, String pathname, int oflags) &#123;        //参数二: 文件路径        //参数三: 操作文件标志        //返回值: FileResult         return null;    &#125;&#125;);\n添加IO处理器。如果在模拟执行期间，有读写文件操作，可由自定义指定的IO处理器进行处理，且自定义IO处理器的优先级最高。关于返回值请查看FileResult。\nsetEnableThreadDispatchersyscallHandler.setEnableThreadDispatcher(true); \n多线程自动调度开关。开启此开关，会以多线程模式运行，当有线程创建会自动进行处理调度。\nsetFileListenersyscallHandler.setFileListener(new FileListener() &#123;    @Override    public void onOpenSuccess(Emulator&lt;?&gt; emulator, String pathname, FileIO io) &#123;        System.out.println(pathname+&quot;文件打开成功！&quot;);    &#125;    @Override    public void onClose(Emulator&lt;?&gt; emulator, FileIO io) &#123;        System.err.println(io.getPath()+&quot;文件打开失败&quot;);    &#125;&#125;);\n设置文件监听器。此API在在运行期间，可以监听所有成功打开和关闭的文件，打开失败的文件不会进行回调。\ngetFileIOFileIO fileIO = syscallHandler.getFileIO(0); \n根据fd查询对应的File。\n自处理系统调用如果unidbg处理的系统调用不足以满足你的需求，可以自己参考unidbg的处理方式，定制SyscallHandler来处理。\nFileResult在自定义IO处理中，FileResult作为回调方法的返回值。其有3个静态方法，分别代表对文件的不同操作。\nsuccessFileResult.&lt;AndroidFileIO&gt;success(new SimpleFileIO(oflags, new File(&quot;filepath&quot;),pathname));\nsuccess方法表示一个文件正常处理。参数是一个NewFileIO接口的实现，根据不同的场景返回不同。如上面例子，就是返回一个普通文件，就使用SimpleFileIO实现，如果是一个文件夹，就使用DirectoryFileIO实现，其他场景可自行查看接口的实现类。\nfailedFileResult.failed(2);\n表示文件打开失败。参数是一个errno，会由上层处理将errno设置为该参数。\nfallbackFileResult.&lt;AndroidFileIO&gt;fallback(new DirectoryFileIO(oflags,pathname,new File(&quot;filepath&quot;)));\n表示降低自己的优先级，在其他处理器无法找到该文件时，由fallback指定的文件IO来代替。\nVirtualModuleVirtualModulem介绍VirtualModule是unidbg提供的一种虚拟模块方案。它的用途是当一个So由于某种原因，无法完整加载进unidbg，或想自己实现该So的部分功能时，就可以使用虚拟模块来解决。\nunidbg自带虚拟模块unidbg中自带了两个虚拟模块:\n\nAndroidModule(libandroid.so)\nJniGraphics(libjnigraphics.so)\n\n这两个模块中的部分常用符号已经在unidbg中有提供，当我们要模拟执行一个So时，而它又正好使用了libandroid.so，我们就可以这样做:\nnew AndroidModule(emulator,vm).register(memory); \n然后再加载目标So。libjnigraphics.so同理。\n自定义虚拟模块当然我们也可以自己实现一个虚拟模块。下面我们以一个例子来说明虚拟模块应该如何使用。\n模拟场景我们先来模拟一个使用虚拟So的场景。先来看Java层的代码:\npackage com.github.unidbg;public class Test &#123;    static &#123;        System.loadLibrary(&quot;native-doc&quot;);    &#125;    public native int sign(int a);&#125;\nJava层加载了libnative-doc.so，有一个sign方法，参数跟返回值都为int类型。我们再来看So层的代码:\n#include &lt;jni.h&gt;#include &quot;myAdd.h&quot;extern &quot;C&quot;JNIEXPORT jint JNICALLJava_com_github_unidbg_Test_sign(JNIEnv *env, jobject thiz, jint a) &#123;     return myAdd(a, 1024);&#125;\nSo的代码有sign方法的实现，而且实现非常简单，调用了myAdd函数。但是这个myAdd函数是来自其他的So的一个函数，而且这个So还由于某种原因不能被正常加载或没必要去加载，我们来看在unidbg中该如何去做。\n首次尝试现在首先要做的是在unidbg中加载native-doc模块，看代码:\npackage com.github.unidbg.android;import com.alibaba.fastjson.util.IOUtils;import com.github.unidbg.*;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import java.io.File;public class DocTest extends AbstractJni &#123;    public static void main(String[] args) &#123;        DocTest test = new DocTest();        test.sign();        test.destroy();    &#125;    private void destroy() &#123;        //清理资源        IOUtils.close(emulator);    &#125;    private final AndroidEmulator emulator;    private final Module module;    private final VM vm;    private DocTest() &#123;        //创建模拟器实例        emulator = AndroidEmulatorBuilder                .for32Bit()                .build();        //获取Memory接口        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        //创建虚拟机        vm = emulator.createDalvikVM();        //加载模块        module = emulator.loadLibrary(new File(&quot;unidbg-android/src/test/java/com/github/unidbg/libnative-doc.so&quot;), true);        //执行JNI_OnLoad函数        vm.callJNI_OnLoad(emulator, module);    &#125;    private void sign() &#123;        //调用com/github/unidbg/Test类下的sign方法        DvmClass testClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);        DvmObject&lt;?&gt; obj = testClass.newObject(null);        int ret = obj.callJniMethodInt(emulator, &quot;sign(I)I&quot;, 1);        System.out.println(&quot;执行结果: &quot; + ret);    &#125;&#125;\n当我们写完上面的代码，执行时会发现如下错误:\nlibnative-doc.so load dependency libadd.so failed\nunidbg会提示你libnative-doc.so需要一个libadd.so，而unidbg又找不到这个So来加载，所以就无法执行出正常的结果。这个libadd.so提供了myAdd函数的实现，但是它无法被正常加载，我们知道的是myAdd函数的实现是什么样子的。它就是将两个参数进行相加，然后返回结果。我们知道实现就好办了，下面通过虚拟So来解决这个问题。\n处理问题处理这种问题就分两步。第一步创建虚拟模块，来处理未找到的符号:\n//继承VirtualModule类public static class Add extends VirtualModule&lt;VM&gt;&#123;    public Add(Emulator&lt;?&gt; emulator, VM extra)&#123;        //参数三为我们无法加载的So模块名称全称        super(emulator,extra,&quot;libadd.so&quot;);    &#125;    @Override    protected void onInitialize(Emulator&lt;?&gt; emulator, VM extra, Map&lt;String, UnidbgPointer&gt; symbols) &#123;        SvcMemory svcMemory = emulator.getSvcMemory();        //添加一个myAdd符号        symbols.put(&quot;_Z5myAddii&quot;,svcMemory.registerSvc(new ArmSvc() &#123;            @Override            public long handle(Emulator&lt;?&gt; emulator) &#123;                RegisterContext context = emulator.getContext();                int arg0 = context.getIntArg(0);                int arg1 = context.getIntArg(1);                return arg0 + arg1;            &#125;        &#125;));    &#125;&#125;\n第二步，在加载我们目标So时，先来加载我们的虚拟So:\n//加载虚拟模块new Add(emulator, vm).register(memory);\n这样就可以搞定啦。\n完整代码package com.github.unidbg.android;import com.alibaba.fastjson.util.IOUtils;import com.github.unidbg.*;import com.github.unidbg.Module;import com.github.unidbg.arm.ArmSvc;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.memory.Memory;import com.github.unidbg.memory.SvcMemory;import com.github.unidbg.pointer.UnidbgPointer;import com.github.unidbg.virtualmodule.VirtualModule;import java.io.File;import java.util.Map;public class DocTest extends AbstractJni &#123;    public static void main(String[] args) &#123;        DocTest test = new DocTest();        test.sign();        test.destroy();    &#125;    private void destroy() &#123;        //清理资源        IOUtils.close(emulator);    &#125;    private final AndroidEmulator emulator;    private final Module module;    private final VM vm;    private DocTest() &#123;        //创建模拟器实例        emulator = AndroidEmulatorBuilder                .for32Bit()                .build();        //获取Memory接口        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        //创建虚拟机        vm = emulator.createDalvikVM();        //加载虚拟模块        new Add(emulator, vm).register(memory);        //加载模块        module = emulator.loadLibrary(new File(&quot;unidbg-android/src/test/java/com/github/unidbg/libnative-doc.so&quot;), true);        //执行JNI_OnLoad函数        vm.callJNI_OnLoad(emulator, module);    &#125;    private void sign() &#123;        //调用com/github/unidbg/Test类下的sign方法        DvmClass testClass = vm.resolveClass(&quot;com/github/unidbg/Test&quot;);        DvmObject&lt;?&gt; obj = testClass.newObject(null);        int ret = obj.callJniMethodInt(emulator, &quot;sign(I)I&quot;, 1);        System.out.println(&quot;执行结果: &quot; + ret);    &#125;    public static class Add extends VirtualModule&lt;VM&gt; &#123;        public Add(Emulator&lt;?&gt; emulator, VM extra) &#123;            super(emulator, extra, &quot;libadd.so&quot;);        &#125;        @Override        protected void onInitialize(Emulator&lt;?&gt; emulator, VM extra, Map&lt;String, UnidbgPointer&gt; symbols) &#123;            SvcMemory svcMemory = emulator.getSvcMemory();            //添加一个myAdd符号            symbols.put(&quot;_Z5myAddii&quot;, svcMemory.registerSvc(new ArmSvc() &#123;                @Override                public long handle(Emulator&lt;?&gt; emulator) &#123;                    RegisterContext context = emulator.getContext();                    int arg0 = context.getIntArg(0);                    int arg1 = context.getIntArg(1);                    return arg0 + arg1;                &#125;            &#125;));        &#125;    &#125;&#125;\n\nJnitrace使用jnitrace -l so文件 包名 &gt; xxx.txt\n\njnitrace函数调用返回的是地址的时候 SO运行存在多线程的问题，多线程会给Trace分析带来干扰，我们在文本中查找TID 11372，跟着这个线 程走下去   此处在获取0x49即我们的字符串的长度，继续往下   此处将jstring转成Native 字符串，在JNI开发中，大部分JObject都属于局部引用，局部引用在用完之后需要手动释放   比如GetStringUTFChars获取的资源，最后一定要ReleaseStringUTFChars，JNItrace会在Releasexxx这 系列API中，打印内容   但是需要注意的是，引用的释放方式有两种，除了Releasexx系列，也可以用DeleteLocalRef释放局部引 用，如果通过DeleteLocalRef释放，JNItrace并不会打印出具体值  \n堆栈检测“java&#x2F;lang&#x2F;Throwable-&gt;()V” new一个异常之后“java&#x2F;lang&#x2F;Throwable-&gt;getStackTrace()[Ljava&#x2F;lang&#x2F;StackTraceElement;”查看堆栈，这不就是堆栈检测吗，如果被Xposed Hook了，堆栈里会有Xposed这一 层。   new 异常之后，getStackTrace即得到异常堆栈数组，写代码验证一下继续看JNItrace 首先获取数据长度，这很好理解嘛，后面肯定是想循环遍历取出完整的调用栈，得知道调用栈有多长 获取数组第0个元素 getClassName，即获取具体的类名 因为是在JNI中处理，所以后面还得getString 用完之后Release释放这个字符串资源，防止内存泄漏 com.xunmeng.pinduoduo.secure.DeviceNative即调用栈的第一层 然后它对数组的第二个元素做同样的操作，一套流程总结下来，就是构造异常后读取调用栈嘛\n推荐使用objection查看堆栈\n函数调用两种方式Unidbg call 参数传递，到底是自己call 地址 还是用Unidbg封装的API？各有优劣，用API的话代码量小一些，自己call的话更灵活，限制小。熟能生巧。\n符号调用DvmObject obj = ProxyDvmObject.createObject(vm,this);String data = &quot;dta&quot;;DvmObject dvmObject = obj.callJniMethodObject(emulator, &quot;md5(Ljava/lang/String;)Ljava/lang/String;&quot;, data);String result = (String) dvmObject.getValue();System.out.println(&quot;[symble] Call the so md5 function result is ==&gt; &quot;+ result);\n\n地址调用Pointer jniEnv = vm.getJNIEnv();DvmObject obj = ProxyDvmObject.createObject(vm,this);StringObject data = new StringObject(vm,&quot;dta&quot;);List&lt;Object&gt; args = new ArrayList&lt;&gt;();args.add(jniEnv);args.add(vm.addLocalObject(obj));args.add(vm.addLocalObject(data));Number[] numbers = module.callFunction(emulator, 0x8E81, args.toArray());DvmObject&lt;?&gt; object = vm.getObject(numbers[0].intValue());String value = (String) object.getValue();System.out.println(&quot;[addr] Call the so md5 function result is ==&gt; &quot;+ value);\n\n构建类的两种方式以当前包类为类名\nDvmObject obj = ProxyDvmObject.createObject(vm,this);\n自定义包名类名\nDvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/content/Context&quot;).newObject(null);\n\n类继承的写法链式继承vm.resolveClass(“子类”, vm.resolveClass(“父类”, vm.resolveClass(“父类的父类”))).newObject(signature);\ncase &quot;android/app/ActivityThread-&gt;getApplication()Landroid/app/Application;&quot;: &#123;    return vm.resolveClass(&quot;android/app/Application&quot;, vm.resolveClass(&quot;android/content/ContextWrapper&quot;, vm.resolveClass(&quot;android/content/Context&quot;))).newObject(signature);&#125;\n多行的写法\nDvmClass context = vm.resolveClass(&quot;android/content/Context&quot;);DvmClass ContextWrapper = vm.resolveClass(&quot;android/content/ContextWrapper&quot;,context);DvmClass Application = vm.resolveClass(&quot;android/app/Application&quot;,ContextWrapper);return Application.newObject(signature);\n\nunidbg补获取系统属性unidbg补获取系统属性可以使用unidbg封装好的hook方法知道系统调用了哪些系统属性，__system_property_get\nSystemPropertyHook systemPropertyHook = new SystemPropertyHook(emulator);systemPropertyHook.setPropertyProvider(new SystemPropertyProvider() &#123;    @Override    public String getProperty(String key) &#123;        System.out.println(&quot;lilac Systemkey:&quot;+key);        switch (key)&#123;        &#125;        return &quot;&quot;;    &#125;;&#125;);memory.addHookListener(systemPropertyHook);\n\n文件重定向，实现 IOResolver需要继承 IOResolver 重写 resolve方法在定义emulator好后，在so加载前添加文件重定位器emulator.getSyscallHandler().addIOResolver(this);指定路径文件定向（单文件）\nif(pathname.equals(&quot;/data/user/0/com.example.fileinunidbg/files/key.txt&quot;))&#123;    return FileResult.success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/FileDemo/key.txt&quot;), pathname));//            return FileResult.success(new ByteArrayFileIO(oflags, pathname, String.valueOf(System.currentTimeMillis()).getBytes(StandardCharsets.UTF_8)));//            return null;//            return FileResult.failed(13);&#125;// 返回对应的文件夹（目录文件）if(pathname.equals(&quot;/data/user/0/com.example.fileinunidbg/files/demo2&quot;))&#123;    return FileResult.success(new DirectoryFileIO(oflags, pathname,            new DirectoryFileIO.DirectoryEntry(true, String.valueOf(System.currentTimeMillis())), new DirectoryFileIO.DirectoryEntry(true, &quot;1234&quot;)));&#125;if(pathname.equals(&quot;/data/user/0/com.example.fileinunidbg/files/demo2/1.txt&quot;))&#123;    return FileResult.success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/FileDemo/demo2/1.txt&quot;), pathname));&#125;if(pathname.equals(&quot;/data/user/0/com.example.fileinunidbg/files/demo2/2.txt&quot;))&#123;    return FileResult.success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/FileDemo/demo2/2.txt&quot;), pathname));&#125;if(pathname.equals(&quot;/data/user/0/com.example.fileinunidbg/files/demo2/3.txt&quot;))&#123;    return FileResult.success(new SimpleFileIO(oflags, new File(&quot;unidbg-android/src/test/resources/FileDemo/demo2/3.txt&quot;), pathname));&#125;if ((&quot;proc/&quot; + emulator.getPid() + &quot;/status&quot;).equals(pathname)) &#123;return FileResult.success(new ByteArrayFileIO(oflags, pathname, (&quot;文本内容.....&quot;).getBytes())&#125;\n或者是虚拟目录（对比文件夹里的文件比较多的情况下比较好）在创建emulator的时候直接指定目录\nemulator = AndroidEmulatorBuilder.for32Bit().setRootDir(new File(&quot;unidbg-android/src/test/resources/FileDemo/VFS&quot;)).build();\n\n补了虚拟目录和代码，哪边会生效？代码执行会先看有没有重写文件重定位器，没有就默认重定位器，两个都没有找到就到虚拟目录系统找，\n一些常用功能打印内存，hexdumpInspector.inspect(ctx.getR0Pointer().getByteArray(0, 0x10), &quot;Arg1&quot;);\n\nunidbg下断点普通断点emulator.attach().addBreakPoint(module.base + 0x3161E);内存写入断点emulator.traceWrite(module.base + 0x3A0C0,module.base + 0x3A0C0);\n\n开启所有的日志Logger.getLogger(&quot;com.github.unidbg.linux.ARM32SyscallHandler&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.unix.UnixSyscallHandler&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.AbstractEmulator&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.linux.android.dvm.DalvikVM&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.linux.android.dvm.BaseVM&quot;).setLevel(Level.DEBUG);Logger.getLogger(&quot;com.github.unidbg.linux.android.dvm&quot;).setLevel(Level.DEBUG);所需要的头文件import org.apache.log4j.Level;import org.apache.log4j.Logger;\n\n计算汇编的行数计算某个函数的汇编行数前使用\npublic void traceLength()&#123;    emulator.getBackend().hook_add_new(new CodeHook() &#123;        int count = 0;        @Override        public void hook(Backend backend, long address, int size, Object user) &#123;            count += 1;            System.out.println(count);        &#125;        @Override        public void onAttach(UnHook unHook) &#123;        &#125;        @Override        public void detach() &#123;        &#125;    &#125;, module.base, module.base + module.size, null);&#125;\n\n打印函数返回值或修改返回值public void hookRandom()&#123;       emulator.attach().addBreakPoint(module.findSymbolByName(&quot;lrand48&quot;, true).getAddress(), new BreakPointCallback() &#123;           @Override           public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;               System.out.println(&quot;call lrand48&quot;);               // 打印调用栈               emulator.getUnwinder().unwind();               // 打印返回值或修改返回值               emulator.attach().addBreakPoint(emulator.getContext().getLRPointer().peer, new BreakPointCallback() &#123;                   @Override                   public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                       //emulator.getBackend().reg_write(ArmConst.UC_ARM_REG_R0, 0x12345678);                       Number number = emulator.getBackend().reg_read(ArmConst.UC_ARM_REG_R0);                       System.out.println(&quot;number &quot; + number.intValue());                       return true;                   &#125;               &#125;);               return true;           &#125;       &#125;);   &#125;\n\n随机数函数返回值固定程序中最常见的随机变量是时间戳和随机数，绝大多数情况下，程序会使用 arc4random 这样的库函数获取随机数，其底层依赖于 /dev/urandom、/dev/random 等随机文件，或者直接访问这些文件，获取随机数。在 Unidbg 里，这几个伪设备文件的模拟位置在 src/main/java/com/github/unidbg/linux/file/DriverFileIO.java。\npublic static DriverFileIO create(Emulator&lt;?&gt; emulator, int oflags, String pathname) &#123;    if (&quot;/dev/urandom&quot;.equals(pathname) || &quot;/dev/random&quot;.equals(pathname) || &quot;/dev/srandom&quot;.equals(pathname)) &#123;        return new RandomFileIO(emulator, pathname);    &#125;    if (&quot;/dev/alarm&quot;.equals(pathname) || &quot;/dev/null&quot;.equals(pathname)) &#123;        return new DriverFileIO(emulator, oflags, pathname);    &#125;    if (&quot;/dev/ashmem&quot;.equals(pathname)) &#123;        return new Ashmem(emulator, oflags, pathname);    &#125;    if (&quot;/dev/zero&quot;.equals(pathname)) &#123;        return new ZeroFileIO(emulator, oflags, pathname);    &#125;    return null;&#125;\n到 RandomFileIO 类里，把 randBytes 函数里的 ThreadLocalRandom.current().nextBytes(bytes); 注释掉\n获取 Trace使用方式看 Trace，下面是保存到文件如果不希望 trace 只是打印在日志里，而是要重定位到文件里，所以要多几行代码\nString traceFile = &quot;unidbg-android/src/test/resources/trace/tracecode.txt&quot;;PrintStream traceStream;try &#123;    traceStream = new PrintStream(new FileOutputStream(traceFile), true);    emulator.traceCode(module.base,module.base+module.size).setRedirect(traceStream);&#125; catch (FileNotFoundException e) &#123;    e.printStackTrace();&#125;\n大概80w行耗时3分钟左右，是否可以优化和加速 Unidbg trace 的速度。指令追踪的耗时有两部分，1 是为了实现指令追踪的能力，所做的指令膨胀和插桩。2 是在展示上的耗时。前一部分的损耗我们很难控制，而后一部分展示上的耗时，可做很多优化。在展示上，trace 需要包括三要素。● 地址● 汇编代码● 寄存器、内存的值变化展示耗时主要在要素二，反汇编机器码获取汇编代码上。在 Unidbg 的处理逻辑里，运行每一条指令都会对它重新做反汇编。但我们都知道，如果地址和机器码都不变化（即没有发生代码自修改的情况里），使用先前对这个地址缓存下来的反汇编即可。接下来让我们对 Unidbg 的源码做一点修改，下面只处理 ARM64。找到unidbg-api/src/main/java/com/github/unidbg/arm/AbstractARM64Emulator.java，在类中添加一个 HashMap 用于存储反汇编结果，我们将使用它来缓存反汇编。\nprivate final Map&lt;Long, Instruction[]&gt; disassembleCache = new HashMap&lt;&gt;();\nprintAssemble 函数的代码原先如下\n@Overridepublic Instruction[] printAssemble(PrintStream out, long address, int size, int maxLengthLibraryName, InstructionVisitor visitor) &#123;    Instruction[] insns = disassemble(address, size, 0);    printAssemble(out, insns, address, ARM.isThumb(backend), maxLengthLibraryName, visitor);    return insns;&#125;\n修改它，当调用 printAssemble 函数时，首先检查缓存中是否已有相应的反汇编结果，如果有则直接使用，否则进行反汇编并将结果存入缓存。\n@Overridepublic Instruction[] printAssemble(PrintStream out, long address, int size, int maxLengthLibraryName, InstructionVisitor visitor) &#123;    Instruction[] insns = disassembleCache.get(address);    if (insns == null) &#123;        insns = disassemble(address, size, 0);        disassembleCache.put(address, insns);    &#125;    printAssemble(out, insns, address, maxLengthLibraryName, visitor);    return insns;&#125;\n\n重新测试 trace，这次重定向到 tracecode2.txt。\nString traceFile = &quot;unidbg-android/src/test/resources/trace/tracecode2.txt&quot;;PrintStream traceStream;try &#123;    traceStream = new PrintStream(new FileOutputStream(traceFile), true);    emulator.traceCode(module.base,module.base+module.size).setRedirect(traceStream);&#125; catch (FileNotFoundException e) &#123;    e.printStackTrace();&#125;\n在耗时上，仅花费半分钟不到，可以说是速度大大提升，这么算的话，即使 trace 指令流的行数以亿计，也能在短短几个小时内 trace 完。接下来继续修改 printAssemble 函数的代码，上面的代码没有考虑到代码自修改的情况，自修改即程序在运行期间修改自身指令，不管是出于解密、反调，还是其它目的，自修改都是一件常事。所以我们还要判断一下字节是否发生了改变。\n@Overridepublic Instruction[] printAssemble(PrintStream out, long address, int size, int maxLengthLibraryName, InstructionVisitor visitor) &#123;    Instruction[] insns = disassembleCache.get(address);    byte[] currentCode = backend.mem_read(address, size);    boolean needUpdateCache = false;    if (insns != null) &#123;        byte[] cachedCode = new byte[size];        int offset = 0;        for (Instruction insn : insns) &#123;            byte[] insnBytes = insn.getBytes();            System.arraycopy(insnBytes, 0, cachedCode, offset, insnBytes.length);            offset += insnBytes.length;        &#125;        if (!Arrays.equals(currentCode, cachedCode)) &#123;            needUpdateCache = true;        &#125;    &#125; else &#123;        needUpdateCache = true;    &#125;    if (needUpdateCache) &#123;        insns = disassemble(address, currentCode, false, 0);        disassembleCache.put(address, insns);    &#125;    printAssemble(out, insns, address, maxLengthLibraryName, visitor);    return insns;&#125;\n新代码会判断当前地址的机器码是否和缓存的这个地址上的机器码一致，这增加了一点开销，运行完毕后比较一下，也就慢了几秒钟，完全能承受。\nString traceFile = &quot;unidbg-android/src/test/resources/trace/tracecode3.txt&quot;;PrintStream traceStream;try &#123;    traceStream = new PrintStream(new FileOutputStream(traceFile), true);    emulator.traceCode(module.base,module.base+module.size).setRedirect(traceStream);&#125; catch (FileNotFoundException e) &#123;    e.printStackTrace();&#125;\n\n获取函数调用流基于对指令流中BL、BLR等函数调用指令的监控，Unidbg 实现了对函数的监控和追踪，我们稍作处理，将它重定向到文件。\nString traceFile = &quot;unidbg-android/src/test/resources/trace/tracefunction.txt&quot;;try &#123;    final PrintStream traceStream;    traceStream = new PrintStream(new FileOutputStream(traceFile), true);    emulator.attach().traceFunctionCall(module, new FunctionCallListener() &#123;        @Override        public void onCall(Emulator&lt;?&gt; emulator, long callerAddress, long functionAddress) &#123;        &#125;        @Override        public void postCall(Emulator&lt;?&gt; emulator, long callerAddress, long functionAddress, Number[] args) &#123;            traceStream.println(&quot;onCallFinish caller=&quot; + UnidbgPointer.pointer(emulator, callerAddress) + &quot;, function=&quot; + UnidbgPointer.pointer(emulator, functionAddress));        &#125;    &#125;);&#125; catch (FileNotFoundException e) &#123;    e.printStackTrace();&#125;\n代码置于 JNI_OnLoad 后。\n在内存中搜索数据出现的位置假如目标数据是EC 03 CE 8A 99 16 7F 9A 8F 2D F5 CD 8E E1 47 F2。● 这串数据在第 25w 行左右的地址生成，地址是 A● 在 36w 行的位置由 A 赋值给 B，即 A –&gt; B● 在 47w 行的位置 B –&gt; C● 在 55w 行的位置 C –&gt; D● 在 82w 行的位置 D –&gt; E● 在 97w 行的位置 E–&gt; F在逆向追溯时，从 F 开始做 traceWrite，经过四五次跳转，最终才能找到 A，非常的麻烦。在这个 Android Native Runtime 里，只需要处理单个 SO 里的单个函数，因此它所使用和操纵的内存区块很有效，只有几 MB 大小。因此我们可以从函数起始点开始，高频率的搜索内存里是否出现了某个值，从而确定某个数据最早出现的位置，下面是基本的实现代码。\nimport com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.*;import com.github.unidbg.pointer.UnidbgPointer;import com.sun.jna.Pointer;import java.util.*;public class DataSearch &#123;    private final Emulator&lt;?&gt; emulator;    private final TreeSet&lt;Long&gt; addressUsed = new TreeSet&lt;&gt;();    private final Map&lt;Long, Byte&gt; memoryData = new HashMap&lt;&gt;();    private final byte[] data;    private boolean find = false;    private int interval;    private long count = 0;    private final List&lt;long[]&gt; activePlace = new ArrayList&lt;&gt;();    public DataSearch(Emulator&lt;?&gt; emulator, String data) &#123;        this.emulator = emulator;        this.data = hexStringToByteArray(data);        this.interval = 100;        hookReadAndWrite();        hookBlock();    &#125;    public DataSearch(Emulator&lt;?&gt; emulator, String data, int interval) &#123;        this.emulator = emulator;        this.data = hexStringToByteArray(data);        this.interval = interval;        hookReadAndWrite();        hookBlock();    &#125;    public static byte[] hexStringToByteArray(String s) &#123;        int len = s.length();        byte[] data = new byte[len / 2];        for (int i = 0; i &lt; len; i += 2) &#123;            data[i / 2] = (byte) ((Character.digit(s.charAt(i), 16) &lt;&lt; 4)                    + Character.digit(s.charAt(i + 1), 16));        &#125;        return data;    &#125;    private void hookReadAndWrite() &#123;        WriteHook writeHook = new WriteHook() &#123;            @Override            public void onAttach(UnHook unHook) &#123;            &#125;            @Override            public void detach() &#123;            &#125;            @Override            public void hook(Backend backend, long address, int size, long value, Object user) &#123;                for (int offset = 0; offset &lt; size; offset++) &#123;                    memoryData.put(address + offset, (byte) (value &gt;&gt;&gt; (offset * 8)));                &#125;                updateActivePlace(address, size);            &#125;        &#125;;        ReadHook readHook = new ReadHook() &#123;            @Override            public void onAttach(UnHook unHook) &#123;            &#125;            @Override            public void detach() &#123;            &#125;            @Override            public void hook(Backend backend, long address, int size, Object user) &#123;                byte[] readBytes = emulator.getBackend().mem_read(address, size);                for (int offset = 0; offset &lt; size; offset++) &#123;                    memoryData.put(address + offset, readBytes[offset]);                &#125;                updateActivePlace(address, size);            &#125;        &#125;;        emulator.getBackend().hook_add_new(writeHook, 1, 0, null);        emulator.getBackend().hook_add_new(readHook, 1, 0, null);    &#125;    private void hookBlock() &#123;        BlockHook blockHook = new BlockHook() &#123;            @Override            public void onAttach(UnHook unHook) &#123;            &#125;            @Override            public void detach() &#123;            &#125;            @Override            public void hookBlock(Backend backend, long address, int size, Object user) &#123;                count++;                if (!find &amp;&amp; (count % interval == 0)) &#123;                    searchData();                &#125;            &#125;        &#125;;        emulator.getBackend().hook_add_new(blockHook, 1, 0, null);    &#125;    private void searchData() &#123;        if (!find) &#123;            for (long[] range : activePlace) &#123;                if (searchDataInRange(range)) &#123;                    find = true;                    printAddress(range);                    emulator.attach().debug();                    break;                &#125;            &#125;        &#125;    &#125;    private boolean searchDataInRange(long[] range) &#123;        for (long i = range[0], max = range[1] - data.length; i &lt;= max; i++) &#123;            boolean found = true;            for (int j = 0; j &lt; data.length; j++) &#123;                Byte value = memoryData.get(i + j);                if (value == null || value != data[j]) &#123;                    found = false;                    break;                &#125;            &#125;            if (found) &#123;                return true;            &#125;        &#125;        return false;    &#125;    private void printAddress(long[] range) &#123;        Collection&lt;Pointer&gt; pointers = searchMemory(range[0], range[1], data);        System.out.println(&quot;Search data matches &quot; + pointers.size() + &quot; count&quot;);        for (Pointer pointer : pointers) &#123;            System.out.println(&quot;data address: &quot; + pointer);        &#125;    &#125;    private Collection&lt;Pointer&gt; searchMemory(long start, long end, byte[] data) &#123;        List&lt;Pointer&gt; pointers = new ArrayList&lt;&gt;();        if (end - start &gt;= data.length) &#123;            for (long i = start, max = end - data.length; i &lt;= max; i++) &#123;                boolean found = true;                for (int j = 0; j &lt; data.length; j++) &#123;                    Byte value = memoryData.get(i + j);                    if (value == null || value != data[j]) &#123;                        found = false;                        break;                    &#125;                &#125;                if (found) &#123;                    pointers.add(UnidbgPointer.pointer(emulator, i));                &#125;            &#125;        &#125;        return pointers;    &#125;    private void updateActivePlace(long address, int size) &#123;        for (int i = 0; i &lt; size; i++) &#123;            long newAddress = address + i;            if (addressUsed.add(newAddress)) &#123;                updateActivePlace(newAddress);            &#125;        &#125;    &#125;    private void updateActivePlace(long address) &#123;        Long lower = addressUsed.lower(address);        Long higher = addressUsed.higher(address);        boolean connectToLower = lower != null &amp;&amp; lower + 1 == address;        boolean connectToHigher = higher != null &amp;&amp; address + 1 == higher;        long[] lowerRange = null;        long[] higherRange = null;        for (long[] range : activePlace) &#123;            if (connectToLower &amp;&amp; range[1] == lower) &#123;                lowerRange = range;            &#125;            if (connectToHigher &amp;&amp; range[0] == higher) &#123;                higherRange = range;            &#125;        &#125;        if (connectToLower &amp;&amp; connectToHigher) &#123;            assert lowerRange != null;            lowerRange[1] = higherRange[1];            activePlace.remove(higherRange);        &#125; else if (connectToLower) &#123;            assert lowerRange != null;            lowerRange[1] = address;        &#125; else if (connectToHigher) &#123;            assert higherRange != null;            higherRange[0] = address;        &#125; else &#123;            activePlace.add(new long[]&#123;address, address&#125;);        &#125;    &#125;&#125;\n它使用上非常简单，在 loadlibaray 前添加下面一行代码即可。\nnew DataSearch(Emulator&lt;?&gt; emulator, String data);\n其中 data 是你所需要搜索内容的 hexstring 形式，加不加空格都行。\nnew DataSearch(emulator, &quot;cd 8e ec&quot;);new DataSearch(emulator, &quot;cd8eec&quot;);\nDataSearch 默认的搜索频率是每 100指令流，如果处理千万级或亿级的指令流，那么可以使用 DataSearch 的另外一个构造函数。\nnew DataSearch(Emulator&lt;?&gt; emulator, String data, int interval);\ninterval 用于指定每隔多少个基本块做一次内存检索，建议千万级指令流选择 500 左右，亿级指令流选择 2000 左右。检索频率越高，搜索的准确度越高，越可能发现数据的第一生成现场；检索越稀疏，搜索的耗时就越小，但可能会错过第一生成现场。因此，我们需要在性能和准确度之间找个均衡点。DataSearch 并非万能，如果数据过短小，比如两三个字节，那么在内存中就不具有标识性和唯一性，无法用它处理。这种情景请使用污点分析或类似的其它分析技术。除了搜索某个指定字节数组外，DataSearch 稍加修改，可以用于搜索 Key、字符串等等，比如下面是 StringSearch，它会打印内存中出现过的所有可见字符串。\nimport com.github.unidbg.Emulator;import com.github.unidbg.arm.backend.*;import com.github.unidbg.pointer.UnidbgPointer;import com.sun.jna.Pointer;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.PrintWriter;import java.util.*;public class StringSearch &#123;    private final Emulator&lt;?&gt; emulator;    private final TreeSet&lt;Long&gt; addressUsed = new TreeSet&lt;&gt;();    private final Map&lt;Long, Byte&gt; memoryData = new HashMap&lt;&gt;();    private Set&lt;String&gt; foundStrings = new HashSet&lt;&gt;();    private int interval;    private int minLength;    private long count = 0;    private final List&lt;long[]&gt; activePlace = new ArrayList&lt;&gt;();    private PrintWriter output;    public StringSearch(Emulator&lt;?&gt; emulator, int minLength, String outputFile) &#123;        this.emulator = emulator;        this.interval = 100;        this.minLength = minLength;        try &#123;            this.output = new PrintWriter(new FileOutputStream(outputFile));        &#125; catch (FileNotFoundException e) &#123;            throw new RuntimeException(e);        &#125;        hookReadAndWrite();        hookBlock();    &#125;    public StringSearch(Emulator&lt;?&gt; emulator, int minLength, int interval, String outputFile)&#123;        this.emulator = emulator;        this.interval = interval;        this.minLength = minLength;        try &#123;            this.output = new PrintWriter(new FileOutputStream(outputFile));        &#125; catch (FileNotFoundException e) &#123;            throw new RuntimeException(e);        &#125;        hookReadAndWrite();        hookBlock();    &#125;    private void hookReadAndWrite() &#123;        WriteHook writeHook = new WriteHook() &#123;            @Override            public void onAttach(UnHook unHook) &#123;            &#125;            @Override            public void detach() &#123;            &#125;            @Override            public void hook(Backend backend, long address, int size, long value, Object user) &#123;                for (int offset = 0; offset &lt; size; offset++) &#123;                    memoryData.put(address + offset, (byte) (value &gt;&gt;&gt; (offset * 8)));                &#125;                updateActivePlace(address, size);            &#125;        &#125;;        ReadHook readHook = new ReadHook() &#123;            @Override            public void onAttach(UnHook unHook) &#123;            &#125;            @Override            public void detach() &#123;            &#125;            @Override            public void hook(Backend backend, long address, int size, Object user) &#123;                byte[] readBytes = emulator.getBackend().mem_read(address, size);                for (int offset = 0; offset &lt; size; offset++) &#123;                    memoryData.put(address + offset, readBytes[offset]);                &#125;                updateActivePlace(address, size);            &#125;        &#125;;        emulator.getBackend().hook_add_new(writeHook, 1, 0, null);        emulator.getBackend().hook_add_new(readHook, 1, 0, null);    &#125;    private void hookBlock() &#123;        BlockHook blockHook = new BlockHook() &#123;            @Override            public void onAttach(UnHook unHook) &#123;            &#125;            @Override            public void detach() &#123;            &#125;            @Override            public void hookBlock(Backend backend, long address, int size, Object user) &#123;                count++;                if (count % interval == 0)&#123;                    searchString();                &#125;            &#125;        &#125;;        emulator.getBackend().hook_add_new(blockHook, 1, 0, null);    &#125;    private void searchString() &#123;        for (long[] range : activePlace) &#123;            searchStringInRange(range);        &#125;    &#125;    private void searchStringInRange(long[] range) &#123;        int length = (int) (range[1] - range[0] + 1);        byte[] codes = new byte[length];        for (int i = 0; i &lt; length; i++) &#123;            codes[i] = memoryData.get(i + range[0]);        &#125;        searchVisibleStringsInMemory(codes, range[0]);    &#125;    public void searchVisibleStringsInMemory(byte[] memory, long addr) &#123;        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; memory.length; i++) &#123;            byte b = memory[i];            if (b &gt;= 32 &amp;&amp; b &lt;= 126) &#123;                sb.append((char) b);            &#125; else &#123;                processVisibleString(sb, addr + i - sb.length());            &#125;        &#125;        processVisibleString(sb, addr + memory.length - sb.length());    &#125;    private void processVisibleString(StringBuilder sb, long addr) &#123;        if (sb.length() &gt;= minLength) &#123;            String visibleString = sb.toString();            if (foundStrings.add(visibleString)) &#123;                String result = &quot;Address: 0x&quot; + Long.toHexString(addr) + &quot;, String: &quot; + visibleString;                output.println(result);                output.flush();            &#125;        &#125;        sb.setLength(0);    &#125;    private void updateActivePlace(long address, int size) &#123;        for (int i = 0; i &lt; size; i++) &#123;            long newAddress = address + i;            if (addressUsed.add(newAddress)) &#123;                updateActivePlace(newAddress);            &#125;        &#125;    &#125;    private void updateActivePlace(long address) &#123;        Long lower = addressUsed.lower(address);        Long higher = addressUsed.higher(address);        boolean connectToLower = lower != null &amp;&amp; lower + 1 == address;        boolean connectToHigher = higher != null &amp;&amp; address + 1 == higher;        long[] lowerRange = null;        long[] higherRange = null;        for (long[] range : activePlace) &#123;            if (connectToLower &amp;&amp; range[1] == lower) &#123;                lowerRange = range;            &#125;            if (connectToHigher &amp;&amp; range[0] == higher) &#123;                higherRange = range;            &#125;        &#125;        if (connectToLower &amp;&amp; connectToHigher) &#123;            assert lowerRange != null;            lowerRange[1] = higherRange[1];            activePlace.remove(higherRange);        &#125; else if (connectToLower) &#123;            assert lowerRange != null;            lowerRange[1] = address;        &#125; else if (connectToHigher) &#123;            assert higherRange != null;            higherRange[0] = address;        &#125; else &#123;            activePlace.add(new long[]&#123;address, address&#125;);        &#125;    &#125;&#125;\n使用上也很简单，参数 1 是模拟器实例，参数 2 是可见字符串的最短长度，参数 3 是输出的文件路径。\npublic StringSearch(Emulator&lt;?&gt; emulator, int minLength, String outputFile)\n它的默认搜索频率是 100 个基本块，可以使用它的重载方法，修改这个值。\npublic StringSearch(Emulator&lt;?&gt; emulator, int minLength, int interval, String outputFile)\n具体使用上，比如下面这样\nnew StringSearch(emulator, 5,&quot;unidbg-android/src/test/resources/trace/strings.log&quot;);\n效果如下，运行时的字符串可以给出很多指引。\nfindCryptInTrace哈希算法主要关注下面这几点。● 使用了哪种哈希算法● 哈希的输入是什么● 哈希的输出是什么● 哈希算法是否魔改首先要确定使用了什么哈希算法，上面用 IDA Findcrypt 插件看到，样本里有 SHA256 的魔数，但这并不意味着我们的目标函数就使用了这个算法，对吧。但是，如果我们能在 trace 里找到 SHA256 算法的相关魔数，那就证实了 SHA256 的存在。我写过一个 010Editor 小脚本，叫 findCryptInTrace.1sc，其内容如下。\nint md5[4] = &#123;0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee&#125;;int sha1[4] = &#123;0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xCA62C1D6&#125;;int sha256[4] = &#123;0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5&#125;;int sm3[2] = &#123;0x79cc4519, 0x7a879d8a&#125;;int crc32[2] = &#123;0x77073096, 0xEE0E612C&#125;;int chacha20[2] = &#123;0x61707865, 0x3320646e&#125;;int hmac[2] = &#123;0x36363636, 0x5C5C5C5C&#125;;int tea[1] = &#123;0x9e3779b9&#125;;int twofish[4] = &#123;0xBCBC3275, 0xECEC21F3, 0x202043C6, 0xB3B3C9F4&#125;;int salsa20[4] = &#123;0x61707865, 0x3320646e, 0x79622d32, 0x6b206574&#125;;int blowfish[2] = &#123;0x243f6a88, 0x85a308d3&#125;;int rc6[2] = &#123;0xb7e15163, 0x9e3779b9&#125;;int aes[2] = &#123;0xC66363A5, 0xF87C7C84&#125;;int aplib[1] = &#123;0x32335041&#125;;void search(int arr[], string name)&#123;    int num = sizeof(arr)/sizeof(arr[0]);    local int i;    local string s;    local uchar exist = false;    for( i = 0; i &lt; num; i++ )&#123;        SPrintf(s, &quot;%X&quot;, arr[i]);        if(FindFirst(s, false) &gt; 0)&#123;            exist = true;            break;        &#125;    &#125;    if(exist)&#123;        Printf(&quot;Find &quot;+name +&quot;, num:0x&quot;+s+&quot;\\n&quot;);    &#125;&#125;Printf(&quot;***********Findcrypt Search Start****************\\n&quot;);search(md5, &quot;MD5&quot;);search(sha1, &quot;SHA1&quot;);search(sha256, &quot;SHA256&quot;);search(sm3, &quot;sm3&quot;);search(crc32, &quot;crc32&quot;);search(chacha20, &quot;chacha20&quot;);search(hmac, &quot;hmac&quot;);search(tea, &quot;tea&quot;);search(twofish,&quot;twofish&quot;);search(salsa20, &quot;salsa20&quot;);search(blowfish, &quot;blowfish&quot;);search(rc6,&quot;rc6&quot;);search(aes,&quot;aes&quot;);search(aplib,&quot;aplib&quot;);Printf(&quot;***********Findcrypt Search Over****************\\n&quot;);\n原理和 Findcrypt 类似，搜索各种常见算法所使用的常量，下面演示它的使用。打开我们的脚本，选择运行。trace 里明确找到了 SHA256 算法以及 HMAC 方案的特征。这说明样本可能使用了 HMAC-SHA256，也可能是 SHA256 + HMAC-SHA256，或者其它，这都说不清，需要进一步分析。\n\n\n\n反制unidng如何增加跑通Unidbg模拟执行的成本  ？\n一、JNI交互主要有两点 \n\n尽可能增加补JAVA环境所需的时间成本\n\n打个比方，在SO中编写1000个对JAVA层的访问和调用函数，每次计算时根据时间戳使用其中的50 个，这样做的话，运算的时间成本不高，但因为时间戳一直在变，所以得在Unidbg中补齐全量的 JAVA访问。 \n\n使用Unidbg暂不支持的JNI调用\n\nsrc&#x2F;main&#x2F;java&#x2F;com&#x2F;github&#x2F;unidbg&#x2F;linux&#x2F;android&#x2F;dvm&#x2F;DalvikVM.java 是Unidbg中实现JNI方法 的类，可以发现，只实现了最常用的那部分JNI方法，所以可以在样本中使用这些Unidbg尚未实现 的JNI方法。 \n二、系统调用Unidbg实现了许多常见的系统调用，但还有一些偏冷门的系统调用未实现，以及不偏僻但较难完美实现 的系统调用，典型代表——fork相关系统调用。 \n三、文件访问尽可能多的文件访问和交互 \n四、检测Unidbg样本可以感知并检测自己运行在Unidbg环境中，并走向错误的分支。这一块我的了解不多，但确实是可 以的，Unidbg的执行环境和真机是有很大差距的。打个比方，每个Android进程都有一些初始化环境变 量，Android系统启动时通过setEnv设置，Unidbg中则没有。 \n五、目标函数无法被单独执行尽其所能的增加目标函数被执行的”前置条件“，或者说初始化函数。这里面可以玩的花招、阴招太多 了。这应该作为一个主要的反Unidbg的方向，它是有效且杀伤力巨大的  \n六、在真机上使用GetStaticMethodID寻找一个不存在的方法在真机上，使用GetStaticMethodID寻找一个不存在的方法，系统会返回一个错误。在unidbg中使用GetStaticMethodID，像是无论存不存在都会模拟一个jmethodID返回给so关于这个反unidbg的思路和形成，如果java层不存在某个类或者方法，jni中使用findclass或者getmethodid就会报错（这很合理嘛，因为找不到），而Unidbg因为没办法了解Java环境具体咋样，所以不管你find啥class还是get什么method，它都当做这是存在的。解决，如果你想让Unidbg findclass找不到一个类，可以使用BaseVM的addNotFoundClass方法，如果想让Unidbg找不到某个方法，可以修改AbstractJni中的acceptMethod方法。\nUnidbg报错Illegal JNI version JNI版本错误，而只意味 JNIOnLoad 运行过程中出了错。至于具体出错的原因有很多，一个常见的问题是SO的依赖库缺失。   我们的目标SO依赖了 libc++_shared.so ，这个库是C++的支持库，但不在Unidbg默认支持的SO里。 我们要在apk的lib里把它拷贝出来。   还有另一个更通用的办法 ，当报错时，就把 traceCode打开，记录执行流，看最后在哪儿停下来。   比如此处，我在JNI_OnLoad前面打开traceCode，在IDA中跳转到最后一条运行地址 0x177C   可以发现正是C++的标准库函数，符合上面的猜测。  添加之后正常加载\napp开发过程中的失误，释放变量后还调用运行样本后，发现内存错误第一种尝试，把Unidbg的日志全开，src&#x2F;test&#x2F;resources&#x2F;log4j.properties中的INFO全配置改为DEBUG再次运行后会在报错的地方停下来。输入bt查看调用栈unidbg提供了大量详情的调用回溯信息，直接拉到底部，看目标样本是从哪里调用。用IDA跳到0xabf奇了怪了，打个日志还报错？把日志等级改为INFO，在此处下个断点分析。emulator.attach().addBreakPoint(module.base+0x00abf);_android_log_print是常用函数，参数1是此日志的优先级，参数2是tag，参数3是格式化字符串，之后的都是内容。都可以在Console Debugger中验证参数1是6，可以直接看，通过mrx查看其余参数，参数23也都正常，那参数4呢内存异常了，返回IDA查看代码可以看到上面释放了变量，下面还在调用。怎么解决？直接patch，改为两条无效指令，需要修改4个字节首先写入0046，debug发现不对，调整了一下大小端序，再DEBUG似乎OK了\npublic void patchLog()&#123;\tint patchCode = 0x46004600;\temulator.getMemory().pointer(module.base + 0xABE).setInt(0,patchCode);&#125;\n另一种填入两个nop也可以\npublic void patchLog1()&#123;    Pointer pointer = UnidbgPointer.pointer(emulator, module.base + 0xABE);    assert pointer != null;    try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm,KeystoneMode.ArmThumb)) &#123;\t\tKeystoneEncoded encoded = keystone.assemble(&quot;nop&quot;);\t\tbyte[] patch = encoded.getMachineCode();        pointer.write(0, patch, 0, patch.length);        pointer.write(2, patch, 0, patch.length);    &#125;&#125;;\n第三种方法，前面两种都是静态打patch，和用IDA的KeyPatch直接打patch没啥区别\npublic void patchLog2()&#123;    emulator.attach().addBreakPoint(module.base + 0xABE, new BreakPointCallback() &#123;        @Override        public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;        \temulator.getBackend().reg_write(ArmConst.UC_ARM_REG_PC,(address)+5);        \treturn true;        &#125;    &#125;);&#125;\n解释一下做了什么，我们在log的调用处下了一个断点，inline hook 都是在调用前断下来了，所以在执 行前断了下来，然后加了BreakPointCallback回调，在这个时机做处理，我们将PC指针直接往前加了 5，PC指向哪里，函数就执行哪里，本来PC指向“blx log”这个地址，程序即将去执行log函数。但我们直 接将PC加了5，为什么加5？我们知道这里的log是个坑，它长四个字节，我们要越过这个坑，但加4不够，我们是thumb模式，再+1，所以就是+5。\n","tags":["Unidbg"]},{"title":"动静态SO层算法还原和脱机(吾爱论坛2021春节安卓题目)","url":"/posts/29413/","content":"文章的案例来自吾爱论坛2021春节安卓题目链接：案例链接\njava用的是unicode编码，c语言用的是ASCII编码\n明文限制的长度是30，检测函数在nativel-lib文件里\n解压apk并用ida打开so文件大概分析一下，传进来的参数判断是否为30位，然后进入sub_B90进行处理后，再进入sub_D90处理，结果为v9，最后v9和v19作比较，相等返回1，不等返回0；\n用ida动态调试调试前先把ida目录下的dbgsrv、android-server拷贝到手机上并修改权限 777这里需要开启frida去获取so的基址+sub_B90的偏移量&#x3D;sub_B90的绝对地址先运行frida，再运行android-serverfrida代码\nfunction hook_KeyStore_load() &#123;    Java.perform(function () &#123;        var addr_libnatuve = Module.findBaseAddress(&quot;libnative-lib.so&quot;)        if(addr_libnatuve) &#123;            console.log(&quot;so基址：&quot;, addr_libnatuve)                    &#125;    &#125;);&#125;setImmediate(hook_KeyStore_load)\n打印结果so基址： 0x76133130000x7613313000+8AC所以需要在动调调试的时候在位置打上断点没显示汇编按空格\n以go方式打开ida\n选择Debugger–》Attach–》Remote ARM Linux&#x2F;Android debugger输入手机IP，选择进程\n加载好后跳到指定位置，或者快捷键G\n打上断点后，点击绿色小箭头继续运行，app点击验证，会断到当前位置可以转为汇编跟静态ida的作比较，Edit–》Code，或者快捷键C按F8单步调试打开寄存器，进入\n用Frida这里直接用fridahook 函数，sub_B90sub_B90的偏移量为B90这就是第一轮加密后的\nhook 第二个函数这是明文经两轮加密后的结果\nfunction hook_KeyStore_load() &#123;    Java.perform(function () &#123;        var addr_libnatuve = Module.findBaseAddress(&quot;libnative-lib.so&quot;)        if(addr_libnatuve) &#123;            console.log(&quot;so基址：&quot;, addr_libnatuve)            var sub_B90 = addr_libnatuve.add(0xB90)            Interceptor.attach(sub_B90, &#123;                onEnter: function(args)&#123;                    this.arg0 = args[0]                    this.arg1 = args[1]                    this.arg2 = args[2]                    // console.log(&quot;&quot;,hexdump(this.arg0))                    // console.log(&quot;&quot;,this.arg1);                    // console.log(&quot;&quot;,hexdump(this.arg2));                    console.log(&quot;参数一：&quot;,Memory.readCString(this.arg0))                    console.log(&quot;参数二：&quot;,this.arg1.toInt32());                    console.log(&quot;参数三&quot;,Memory.readCString(this.arg2))                &#125;,                onLeave: function(retval)&#123;                    console.log(&quot;sub_B90 onLeave&quot;);                    console.log(&quot;运算结果&quot;);                    console.log(Memory.readByteArray(this.arg0, 30)); // 这里把结果赋值给了第一个参数                &#125;            &#125;)            var sub_D90 = addr_libnatuve.add(0xD90)            Interceptor.attach(sub_D90, &#123;                onEnter: function(args)&#123;                    console.log(&quot;sub_D90 onEnter&quot;);                    this.arg0 = args[0]                    this.arg1 = args[1]                    console.log(&quot;参数一：&quot;,Memory.readByteArray(args[0], 30))                    console.log(&quot;参数二：&quot;, this.arg1.toInt32())                &#125;,                onLeave: function(retval)&#123;                    console.log(&quot;sub_D90 onLeave&quot;);                    console.log(&quot;运算结果&quot;);                    console.log(Memory.readCString(retval));                &#125;            &#125;)        &#125;    &#125;);&#125;setImmediate(hook_KeyStore_load)\n\n主动调用# -*- coding: UTF-8 -*- import frida, sys jscode = &#x27;&#x27;&#x27; var destAddr = &#x27;&#x27;;  //定位xsp地址  function inline_hook() &#123;    var so_addr = Module.findBaseAddress(&quot;libnative-lib.so&quot;);              if (so_addr) &#123;        console.log(&quot;so_addr:&quot;, so_addr);                 var addr_b90 = so_addr.add(0xB90);        var sub_b90 = new NativeFunction(addr_b90 , &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;, &#x27;pointer&#x27;]);        Interceptor.attach(sub_b90, &#123;            onEnter: function(args)            &#123;             destAddr = args[0];            console.log(&#x27;onEnter B90&#x27;);            &#125;,            //在hook函数之后执行的语句            onLeave:function(retval)            &#123;            console.log(&#x27;onLeave B90&#x27;);            &#125;        &#125;);               var addr_b2c = so_addr.add(0xb2c);        console.log(&quot;The addr_b2c:&quot;, addr_b2c);        Java.perform(function() &#123;            Interceptor.attach(addr_b2c, &#123;                onEnter: function(args) &#123;                console.log(&quot;addr_b2c OnEnter :&quot;,  Memory.readByteArray(destAddr.sub(0x38),64) );                &#125;            &#125;)        &#125;)    &#125;&#125;setImmediate(inline_hook)      &#x27;&#x27;&#x27;def on_message(message, data):    if message[&#x27;type&#x27;] == &#x27;send&#x27;:        print(&quot; &#123;0&#125;&quot;.format(message[&#x27;payload&#x27;]))    else:        print(message)pass#print(frida.enumerate_devices())# 查找USB设备并附加到目标进程device =  frida.get_usb_device()#pid = device.spawn([&quot;com.live.xctv&quot;])  #session = device.attach(pid)session =device.attach(&#x27;cn.pojie52.cm01&#x27;) #这里是要注入的apk包名# 在目标进程里创建脚本script = session.create_script(jscode)# 注册消息回调script.on(&#x27;message&#x27;, on_message)print(&#x27; Start attach&#x27;)# 加载创建好的javascript脚本script.load()# 读取系统输入sys.stdin.read()\n\n异或大概分析一下sub_b90，是根据传入的第三个参数s把v20进行了一个初始化，然后再把参数a1和v20进行了异或运算，主要看这个异或运算，先设想一下，如果是把a1进行了异或，那么得到的结果和a1之前的数据再异或就可以计算出异或的key，这里我们把它叫做xorkey，那么先看一下我们传入的参数，是30个1，也就是30个0x31 ，然后看结果，第一位是0xe0，0x31^0xe0 &#x3D; 209，然后把参数改为30个2，即0x32，得出首位的结果是0xe3，0xe3^0x32结果也是209，证明我们的思路是正确的，然后依次求出所有的xorkey，\n这里的值是输入，30个1加密后异或来的明文 ^ 密钥 &#x3D; 密文# 拿到密钥明文 ^ 密文 &#x3D; 密钥\na = [0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,     0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31]b = [0xe0, 0x6b, 0x37, 0xa1, 0x75, 0xd7, 0xf6, 0xd4, 0xef, 0x19, 0xc6, 0xc3, 0x57, 0xa0, 0xf9, 0xb4, 0x73, 0xee, 0xc8,     0xd1, 0xb3, 0x30, 0x1a, 0x0a, 0x09, 0x52, 0x06, 0x8c, 0x1f, 0x7c]c = []for i in range(0, 30):    c.append(a[i] ^ b[i])print(c)\n结果：\n[209, 90, 6, 144, 68, 230, 199, 229, 222, 40, 247, 242, 102, 145, 200, 133, 66, 223, 249, 224, 130, 1, 43, 59, 56, 99, 55, 189, 46, 77]\n\n\n异或的key找到了，现在要找异或后的正确值，才能算出答案明文1.调试![image.png]调试到这里，要在寄存器钟拿到v19这里就是判断的地方，偏移量为B2C\n调试没计算前计算后这就是要的密文了“5Gh2&#x2F;y6Poq2&#x2F;WIeLJfmh6yesnK7ndnJeWREFjRx8”\n另一种方式hook寄存器基地址加B30就是结果寄存器的位置，同时我们需要的是x9寄存器的值\nfunction hook_KeyStore_load() &#123;    Java.perform(function () &#123;        var addr_libnatuve = Module.findBaseAddress(&quot;libnative-lib.so&quot;)        if(addr_libnatuve) &#123;            console.log(&quot;so基址：&quot;, addr_libnatuve)            var LDRB = addr_libnatuve.add(0xB30)            console.log(&quot;LDRB&quot;, LDRB)            Interceptor.attach(LDRB, &#123;                onEnter: function(args)&#123;                    console.log(Memory.readCString(this.context.x9))  // 上下文获取x9寄存器                &#125;,                onLeave: function(retval)&#123;                    console.log(&quot;运算结果&quot;);                    console.log(Memory.readCString(retval));                 &#125;            &#125;)        &#125;    &#125;);&#125;setImmediate(hook_KeyStore_load)\n\n异或出答案密钥：[‘0xd1’, ‘0x5a’, ‘0x6’, ‘0x90’, ‘0x44’, ‘0xe6’, ‘0xc7’, ‘0xe5’, ‘0xde’, ‘0x28’, ‘0xf7’, ‘0xf2’, ‘0x66’, ‘0x91’, ‘0xc8’, ‘0x85’, ‘0x42’, ‘0xdf’, ‘0xf9’, ‘0xe0’, ‘0x82’, ‘0x1’, ‘0x2b’, ‘0x3b’, ‘0x38’, ‘0x63’, ‘0x37’, ‘0xbd’, ‘0x2e’, ‘0x4d’]结果：“5Gh2&#x2F;y6Poq2&#x2F;WIeLJfmh6yesnK7ndnJeWREFjRx8”结果^密钥&#x3D;答案\nimport base64a = [0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31,     0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31, 0x31]b = [0xe0, 0x6b, 0x37, 0xa1, 0x75, 0xd7, 0xf6, 0xd4, 0xef, 0x19, 0xc6, 0xc3, 0x57, 0xa0, 0xf9, 0xb4, 0x73, 0xee, 0xc8,     0xd1, 0xb3, 0x30, 0x1a, 0x0a, 0x09, 0x52, 0x06, 0x8c, 0x1f, 0x7c]c = []for i in range(0, 30):    c.append(a[i] ^ b[i])print(c) # [209, 90, 6, 144, 68, 230, 199, 229, 222, 40, 247, 242, 102, 145, 200, 133, 66, 223, 249, 224, 130, 1, 43, 59, 56, 99, 55, 189, 46, 77]d = [0xd1, 0x5a, 0x6, 0x90, 0x44, 0xe6, 0xc7, 0xe5, 0xde, 0x28, 0xf7, 0xf2, 0x66, 0x91, 0xc8, 0x85, 0x42, 0xdf, 0xf9, 0xe0, 0x82, 0x1, 0x2b, 0x3b, 0x38, 0x63, 0x37, 0xbd, 0x2e, 0x4d]data = base64.b64decode(&#x27;5Gh2/y6Poq2/WIeLJfmh6yesnK7ndnJeWREFjRx8&#x27;.encode())flag = bytes([d[i] ^ data[i] for i in range(len(d))]).decode()print(flag)\n\n\n运行结果为：\n52pojieHappyChineseNewYear2021\n","tags":["frida","安卓逆向"]},{"title":"刷机","url":"/posts/56024/","content":"工具https://source.android.com/setup/start/build-numbershttps://developers.google.cn/android/images#anglerhttps://github.com/shadowsocks/shadowsocks-android/tagshttps://github.com/topjohnwu/Magisk/tags magisk，下载zip包https://eu.dl.twrp.me/angler/twrp-3.3.0-0-angler.img.html   nexus 6phttps://dl.twrp.me/sailfish/twrp-3.3.0-0-sailfish.img.htmlhttps://dl.twrp.me/bullhead/twrp-3.3.1-0-bullhead.img.html   nexus 5xhttps://www.kali.org/get-kali/#kali-mobile  kali nethuntSR5-SuperSU-v2.82-SR5-20171001224502.zip  超级授权\nnexus 6p刷安卓8下载刷机包\nwget https://dl.google.com/dl/android/aosp/angler-opm1.171019.011-factory-39448337.zip\n解压\n7z x angler-opm1.171019.011-factory-39448337.zip\n手机关机，先按住音量键下+电源键，进入reboot进入解压后的刷机包，运行\n./flash-all.sh\n等待过程，显示下图则成功\n\n刷入SuperSU（Android 8）连上数据线，开启开发者模式运行命令\nadb push SR5-SuperSU-v2.82-SR5-20171001224502.zip /sdcard/Download\nadb reboot bootloader \nfastboot flash recovery twrp-3.3.0-0-angler.img\n音量键向下按两次，进入recovery mode向右划选择install进入Download 选择SuperSU向右划点击reboot system向右划手机就会重启\n安装xpoder安装ssr\n“已连接，但无法访问互联网”开机后wifi有感叹号, 时间无法同步解决办法 在手机的shell里以root用户执行：# settings put global captive_portal_http_url https://www.google.cn/generate_204 # settings put global captive_portal_https_url https://www.google.cn/generate_204 # settings put global ntp_server 1.hk.pool.ntp.org # reboot\n打开xposed，向下拉刷新下载version 90\n刷magisk（Android 10有效）同样的方式刷入magisk，把magisk.zip放到sdcard根目录下\nadb push Magisk-v21.2.zip /sdcard/\n手机关机先按住音量键下+电源键进入reboot按两下音量键下，选择recovery mode点击install选择magisk.zip后，向右划重新启动\n刷nethunt下载，或者window直接下载\nproxychains wget https://images.kali.org/nethunter/nethunter-2021.2-angler-oreo-kalifs-full.zip \n把下载好后的nethunter放到sdcard下\nadb reboot bootloader\nfastboot flash recovery twrp-3.3.1-0-bullhead.img\n 按两下音量键下 选择nethunter就开始自动刷机\n\napt update\napt install neofetch jnettop htop nethogs\nneofetch\n\n点击NetHunter菜单选择KeX Manager点击SETUP LOCAL SERVER设置密码 点击START SERVER开启服务器\n连接手机\nssh root@xxx.xxx.xx.xx\n\n\n\n\n\n另一种 android8+magisk+LSPosedhttps://developers.google.cn/android/imageshttps://topjohnwu.github.io/Magisk/install.htmlandroid8+magisk+LSPosed下载刷机系统包后，解压，进入，输入 .&#x2F;flash-all.sh安装magisk修补镜像才能root刷完后从刷机包里的镜像压缩包找到boot.img ，推送到 &#x2F;sdcard&#x2F; 下打开magisk，点击安装，选择并修补一个文件，选择刚才推送的文件，点开始，然后就开始patch了显示All done后，adb shell进入到 &#x2F;sdcard&#x2F;Download&#x2F; 下，看到修补后的img，adb pull到电脑上进入到解压的系统包，输入adb root bootloader 到刷机界面输入 fastboot flash boot &#x2F;path&#x2F;to&#x2F;magisk_patched.img （这里用自己修补后的）刷完之后在输入 fastboot flash recovery &#x2F;path&#x2F;to&#x2F;magisk_patched.img 重启之后就root成功了\nhttps://github.com/LSPosed/LSPosed下载 Riru 压缩包，push到手机&#x2F;sdcard&#x2F;，打开magisk点击模块，选择Riru，安装后下载LSPosed，推送到 &#x2F;sdcard&#x2F;，，打开magisk点击模块，选择LSPosed，安装后重启\n","tags":["刷机"]},{"title":"对称加密算法AES的原理及分析","url":"/posts/57259/","content":"\nAES算法简述分组加密有几种方式分别是：\nECB：是一种基础的加密方式，密文被分割成分组长度相等的块（不足补齐），然后单独一个个加密，一个个输出组成密文。将整个明文分成若干段相同的小段，然后对每一小段进行加密00112233445566778899aabbccddee 还差2位hex（1个字节），填充01：00112233445566778899aabbccddee0100112233445566778899aabbccddeeff 等于128比特，需要填充一整个分组：00112233445566778899aabbccddeeff(hex)==&gt; 00112233445566778899aabbccddeeff10101010101010101010101010101010最少填充一字节，最多填充一整个分组，不能不填充。\nCBC：是一种循环模式，前一个分组的密文和当前分组的明文异或操作后再加密，这样做的目的是增强破解难度。先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密\nCFB/OFB实际上是一种反馈模式，目的也是增强破解的难度。密码算法的输出（指密码key而不是密文）会反馈到密码算法的输入中，OFB模式并不是通过密码算法对明文直接加密，而是通过将明文分组和密码算法的输出进行XOR来产生密文分组。\nECB和CBC的加密结果是不一样的，两者的模式不同，而且CBC会在第一个密码块运算时加入一个初始化向量。\n\nAES-128接收16字节的明文输入，16字节的密钥，输出16字节的密文结果。\n\n\n入参：明文：128比特（32个十六进制数、16个字节）KEY：128比特（32十六进制数、16个字节）出参：128比特（32个十六进制数、16个字节）\n明文：7a68656e677368616f6b756e79796473（hex）密钥：0123456789abcdef0123456789abcdef（hex）\n下方是整体流程图：\n首先看整体的流程图，我们发现，AES的整体图景可以分成左右两块，即明文的处理和密钥的编排。明文的处理主体是一个初始化轮密钥加和十轮运算，在初始化轮密钥加十轮运算中都需要使用密钥编排的结果。密钥编排将16个字节经过运算推演出11组轮密钥，每一组16个字节，称之为K0,K1,K2…K10\n密钥编排下面我们看一下密钥扩展是如何算出来的，这是我们的密钥Key 0123456789abcdef0123456789abcdef。为了区分密钥和密钥编排后的轮密钥，我们将此时的密钥叫主密钥。\n在AES-128中，密钥扩展后得16*11共176字节，使用时逐十六个字节划分成K0,K1,…K10使用，但是在生成时，它是逐四个字节生成的，即44*4。我们不妨用数组来描述它，即一个包含了44个元素的数组,叫W。\n这四十四个元素的生成规则有三种，如下图所示：\n\n不同颜色代表了不同规则。最上方的W0,W1,W2,W3 就是主密钥本身切成四段。Key = 0123456789abcdef0123456789abcdefW0 = 01234567W1 = 89abcdefW2 = 01234567W3 = 89abcdef\n左侧的红色部分，W4,W8,W12,….W40的生成复杂一点。Wn=g(Wn−1) xor Wn−4xor 是异或运算，比如 W4=g(W3) xor W0。g(当前元素前面那个元素) 异或 当前元素头顶上那个元素。\n那么关键点就是这个 g 函数了， g 函数一共三个步骤——循环左移、S盒替换、字节异或。 我们以W4运算中所需的W3为例。W3=89abcdef\ng函数——循环左移、S盒替换、字节异或循环左移首先是循环左移，规则固定—— 将最左边的一个字节挪到右边即可 \n\n循环左移后为 abcdef89\nS盒替换第二步是S盒替换，S盒替换听着很高级，但操作上很简单——将数值本身作为索引取出S数组中对用的值。S盒是固定的。\nSBox = [    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16]num = 0xabresult = SBox[num]print(hex(result))# 0x62\n\nS盒的背后有十分复杂的知识，但好在我们并不需要去了解。\nAB CD EF 89 经过S盒替换后为 62 BD DF A7\n最高字节和一个固定常量异或最后一个步骤更简单，将上一步结果中的最高字节和一个固定常量异或。W4的生成是第一个，用如下rcon表的第一个元素0x1。W40即第十次，用最后一个元素0x36.\nrcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36]#        W4    W8    W12   W16   W20   W24   W28   W32   W36   W40\n\n62 BD DF A7 最高位62与rcon第一个元素，即0x01异或后为：63 BD DF A7 W4 = g(W3) xor W0   = g(0x89abcdef) xor 0x01234567   = 0x63BDDFA7 xor 0x01234567   = 0x629e9ac0最后一步可以直接用python算: \nprint(hex(0x63BDDFA7 ^ 0x01234567))\n上图中蓝色和红色的部分都讲完了，那么橙色部分呢？相当的简单，和红色部分类似，去掉g函数即可Wn=Wn−1 xor Wn−4打个比方，W5 = W4 ^ W1 = 0x629e9ac0 ^ 0x89abcdef = 0xeb35572f 如下是完整的密钥编排部分的Python代码\nSbox = (    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,)Rcon = (0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36)def text2matrix(text):    matrix = []    for i in range(16):        byte = (text &gt;&gt; (8 * (15 - i))) &amp; 0xFF        if i % 4 == 0:            matrix.append([byte])        else:            matrix[i // 4].append(byte)    return matrixdef shiftRound(array, num):    '''    :param array: 需要循环左移的数组    :param num: 循环左移的位数    :return: 使用Python切片，返回循环左移num个单位的array    '''    return array[num:] + array[:num]def g(array, index):    '''    g 函数    :param array: 待处理的四字节数组    :index:从1-10，每次使用Rcon中不同的数    '''    # 首先循环左移1位    array = shiftRound(array, 1)    # 字节替换    array = [Sbox[i] for i in array]    # 首字节和rcon中对应元素异或    array = [(Rcon[index] ^ array[0])] + array[1:]    return arraydef xorTwoArray(array1, array2):    '''    返回两个数组逐元素异或的新数组    :param array1: 一个array    :param array2: 另一个array    :return:    '''    assert len(array1) == len(array2)    return [array1[i] ^ array2[i] for i in range(len(array1))]def showRoundKeys(kList):    for i in range(len(kList)):        print(\"K%02d:\" %i +\"\".join(\"%02x\" % k for k in kList[i]))def keyExpand(key):    master_key = text2matrix(key)    round_keys = [[0] * 4 for i in range(44)]    # 规则一(图中红色部分)    for i in range(4):        round_keys[i] = master_key[i]    for i in range(4, 4 * 11):        # 规则二(图中红色部分)        if i % 4 == 0:            round_keys[i] = xorTwoArray(g(round_keys[i - 1], i // 4), round_keys[i - 4])        # 规则三(图中橙色部分)        else:            round_keys[i] = xorTwoArray(round_keys[i - 1], round_keys[i - 4])    # 将轮密钥从44*4转成11*16,方便后面在明文的运算里使用    kList = [[] for i in range(11)]    for i in range(len(round_keys)):        kList[i//4] += round_keys[i]    showRoundKeys(kList)    return kListinput_bytes = 0x00112233445566778899aabbccddeeffkey = 0x2b7e151628aed2a6abf7158809cf4f3ckList = keyExpand(key)\n运行结果如下\nK00:0123456789abcdef0123456789abcdefK01:629e9ac0eb35572fea16124863bddfa7K02:1a00c63bf13591141b23835c789e5cfbK03:154ac987e47f5893ff5cdbcf87c28734K04:385dd190dc228903237e52cca4bcd5f8K05:4d5e90d9917c19dab2024b1616be9eeeK06:c355b89e5229a144e02bea52f69574bcK07:a9c7dddcfbee7c981bc596caed50e276K08:7a5fe58981b199119a740fdb7724edadK09:570a707cd6bbe96d4ccfe6b63beb0b1bK10:8821df9e5e9a36f31255d04529bedb5e\n我们对AES密钥编排部分的学习就基本完成了。\n明文运算现在开始学习明文的运算，即图中左边的部分。首先，我们要调整明文的格式，在AES中，数据以state的形式计算、中间存储和传输，中文名即状态。从明文转到state形式很简单，以我们的明文7a68656e677368616f6b756e79796473为例。从上到下，从左到右。千万不要颠倒顺序，第一行不是“7a 68 65 6e”。除此之外，state中的数，我们一般用十六进制表示，且不加0x前缀，这样看着比较舒服。除非特意强调是十进制，否则下文均为十六进制。\n\n接下来是轮密钥加步骤，因为是第一次轮密钥加步骤，所以也叫初始轮密钥加。轮密钥加步骤听着很怪，但实质很简单。只需要将对应的轮密钥和   一样从上到下，从左到右排列。两个矩阵逐字节异或，这就是轮密钥加步骤。为什么要叫轮密钥加而不是轮密钥异或？我们卖个关子，后面再说。初始的轮密钥加使用 K0 ，0123456789abcdef0123456789abcdef。\n\n接下来就是十轮主运算，看如下的伪代码，我们可以清楚看到一轮运算中有什么，以及第十轮和前九轮有什么区别。\n\n初始的明文转和最后的转明文自不必说，然后是初始轮密钥，使用 K0 。前九轮运算中，包含四个步骤： 字节替换，循环左移，列混淆，轮密钥加。 第十轮中，包含三个步骤：字节替换，循环左移，轮密钥加。相比前九轮缺一个列混淆，其余相同。十轮运算中的轮密钥加，和初始轮密钥加相比，除了使用的轮密钥不同外，并无不同，分别为K1…..K10。而  字节替换步骤，和密钥编排中的S盒替换完全一致。  即循环左移，和密钥编排中的循环左移类似，但有差异。密钥编排中， g 函数中也需循环左移，但其中待处理的数据仅有一行，而明文编排中  是四行。其循环左移规则如下：第一行不循环左移，第二行循环左移1字节，第三行循环左移2字节，第四行循环左移3字节。\n\n相对复杂的是列混淆步骤，列混淆步骤涉及两块知识，1是矩阵乘法，2是伽罗瓦域的加法和乘法。前者还好，后者属于抽象代数的内容，比较复杂。先看第一块——矩阵乘法。首先演示简单的矩阵相乘，左边准备相乘的两个矩阵，我们称它俩为矩阵A和矩阵B，如何求结果矩阵中的abcd ？规则如下：第m行第n列的值等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和。a是第一行第一列，那么就是A的第一行和B的第一列元素乘积之和同理可得即 \n所谓乘积之和，指乘法和加法。再来看AES列混淆中的矩阵乘法，我们的  ，左边乘如下所示固定矩阵看起来有些复杂，小例子中是2*2的矩阵要算4个值，这里是4*4的矩阵要算16个值。我们这里只管第一列，其他列的计算类似。\n\n\n列混淆中的的加法和乘法并不是小例子或日常中的那样，其中的加法指 异或运算 。2A + 3B + C + D 即 2A ^ 3B ^ C ^ D，这也是  叫轮密钥加而不是轮密钥异或的原因——加法就是异或。那么其中的乘法呢？乘法复杂一些，想真正理解的可以网上冲浪搜索伽罗瓦域内乘法。我们这里仅考虑如下三种情况，因为AES-128加密中，列混淆的乘法中，仅涉及这三个数。\n\n\n\n结合Python代码可以更清晰，函数名中 mul 是multiply（乘）的缩写。\n\n\n\nx * 1，结果为x本身\ndef mul_by_01(num):    return num\nx * 2，首先切换到二进制形式，最高位为0时，比特串左移1比特，最右边补0即可。如果最高位为1，比特串左移1比特，最右边补0，最后再异或上 0x1B\ndef mul_by_02(num):    if num &lt; 0x80:        res = (num &lt;&lt; 1)else:    res = (num &lt;&lt; 1) ^ 0x1b    return res % 0x100\nx * 3 = (x * 02) + x，注意”加“是异或哦。\ndef mul_by_03(num):    return (mul_by_02(num) ^ num)\n列混淆，就这么讲完了。下面看完整的AES代码实现 \nSbox = (    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,)Rcon = (0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36)def text2matrix(text):    matrix = []    for i in range(16):        byte = (text &gt;&gt; (8 * (15 - i))) &amp; 0xFF        if i % 4 == 0:            matrix.append([byte])        else:            matrix[i // 4].append(byte)    return matrixdef shiftRound(array, num):    '''    :param array: 需要循环左移的数组    :param num: 循环左移的位数    :return: 使用Python切片，返回循环左移num个单位的array    '''    return array[num:] + array[:num]def g(array, index):    '''    g 函数    :param array: 待处理的四字节数组    :index:从1-10，每次使用Rcon中不同的数    '''    # 首先循环左移1位    array = shiftRound(array, 1)    # 字节替换    array = [Sbox[i] for i in array]    # 首字节和rcon中对应元素异或    array = [(Rcon[index] ^ array[0])] + array[1:]    return arraydef xorTwoArray(array1, array2):    '''    返回两个数组逐元素异或的新数组    :param array1: 一个array    :param array2: 另一个array    :return:    '''    assert len(array1) == len(array2)    return [array1[i] ^ array2[i] for i in range(len(array1))]def showRoundKeys(round_keys):    # 将轮密钥从44*4转成11*16    kList = [[] for i in range(11)]    for i in range(len(round_keys)):        kList[i // 4] += round_keys[i]    for i in range(len(kList)):        print(\"K%02d:\" % i + \"\".join(\"%02x\" % k for k in kList[i]))def keyExpand(key):    master_key = text2matrix(key)    round_keys = [[0] * 4 for i in range(44)]    # 规则一(图中红色部分)    for i in range(4):        round_keys[i] = master_key[i]    for i in range(4, 4 * 11):        # 规则二(图中红色部分)        if i % 4 == 0:            round_keys[i] = xorTwoArray(g(round_keys[i - 1], i // 4), round_keys[i - 4])        # 规则三(图中橙色部分)        else:            round_keys[i] = xorTwoArray(round_keys[i - 1], round_keys[i - 4])    showRoundKeys(round_keys)    return round_keysdef AddRoundKeys(state, roundKey):    result = [[] for i in range(4)]    for i in range(4):        result[i] = xorTwoArray(state[i], roundKey[i])    return resultdef SubBytes(state):    result = [[] for i in range(4)]    for i in range(4):        result[i] = [Sbox[i] for i in state[i]]    return resultdef ShiftRows(s):    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]    return sdef mul_by_02(num):    if num &lt; 0x80:        res = (num &lt;&lt; 1)    else:        res = (num &lt;&lt; 1) ^ 0x1b    return res % 0x100def mul_by_03(num):    return mul_by_02(num) ^ numdef MixColumns(state):    for i in range(4):        s0 = mul_by_02(state[i][0]) ^ mul_by_03(state[i][1]) ^ state[i][2] ^ state[i][3]        s1 = state[i][0] ^ mul_by_02(state[i][1]) ^ mul_by_03(state[i][2]) ^ state[i][3]        s2 = state[i][0] ^ state[i][1] ^ mul_by_02(state[i][2]) ^ mul_by_03(state[i][3])        s3 = mul_by_03(state[i][0]) ^ state[i][1] ^ state[i][2] ^ mul_by_02(state[i][3])        state[i][0] = s0        state[i][1] = s1        state[i][2] = s2        state[i][3] = s3    return statedef state2Text(state):    text = sum(state, [])    return \"\".join(\"%02x\" % k for k in text)def encrypt(input_bytes, kList):    '''    :param input_bytes: 输入的明文    :param kList: K0-K10    :return:    '''    plainState = text2matrix(input_bytes)    # 初始轮密钥加    state = AddRoundKeys(plainState, kList[0:4])    for i in range(1, 10):        state = SubBytes(state)        state = ShiftRows(state)        state = MixColumns(state)        state = AddRoundKeys(state, kList[4 * i:4 * (i + 1)])    state = SubBytes(state)    state = ShiftRows(state)    state = AddRoundKeys(state, kList[40:44])    return stateinput_bytes = 0x7a68656e677368616f6b756e79796473key = 0x0123456789abcdef0123456789abcdefkList = keyExpand(key)cipherState = encrypt(input_bytes, kList)cipher = state2Text(cipherState)print(cipher)\n  \n","tags":["算法"]},{"title":"对称加密算法DES的原理及分析","url":"/posts/35582/","content":"图解\n手算DES入参：明文：64比特（16个十六进制数、8个字节）KEY：64比特（16个十六进制数、8个字节）出参：64比特（16个十六进制数、8个字节）\n明文：0123456789ABCDEF（hex）密钥：133457799BBCDFF1（hex）结果：85e813540f0ab405fdf2e174492922f8因为模式的原因，会进行填充，这里先把结果当成 85e813540f0ab405（hex）\n1.对明文初始置换（重排）PI置换表（IP表）\nPI = [58, 50, 42, 34, 26, 18, 10, 2,      60, 52, 44, 36, 28, 20, 12, 4,      62, 54, 46, 38, 30, 22, 14, 6,      64, 56, 48, 40, 32, 24, 16, 8,      57, 49, 41, 33, 25, 17, 9, 1,      59, 51, 43, 35, 27, 19, 11, 3,      61, 53, 45, 37, 29, 21, 13, 5,      63, 55, 47, 39, 31, 23, 15, 7]\n根据置换表的索引对明文进行重新排列（例如明文第58的位置放到第一位）明文 0123456789ABCDEF（hex）转为二进制 00000001 00100011 01000101 01100111 10001001 10101011 11001101 11101111重新排列后 11001100 00000000 11001100 11111111 11110000 10101010 11110000 10101010排列顺序如图所示：\n2.对密钥进行编排PC1（CP_1）（置换选择一表）\nCP_1 = [57, 49, 41, 33, 25, 17, 9,        1, 58, 50, 42, 34, 26, 18,        10, 2, 59, 51, 43, 35, 27,        19, 11, 3, 60, 52, 44, 36,        63, 55, 47, 39, 31, 23, 15,        7, 62, 54, 46, 38, 30, 22,        14, 6, 61, 53, 45, 37, 29,        21, 13, 5, 28, 20, 12, 4]\n密钥：133457799BBCDFF1（hex）转为二进制：00010011 00110100 01010111 01111001 10011011 10111100 11011111 11110001重新排列后：1111000 0110011 0010101 0101111 0101010 1011001 1001111 0001111对DES来说，密钥64位，只有56位被使用，每8个比特的最后一位被舍弃掉对重新编排后的拆分成左右两部分L0：1111000 0110011 0010101 0101111R0：0101010 1011001 1001111 0001111\n3.对编排后的密钥进行16轮循环左移生成16个子密钥对L0和R0进行16轮循环左移，每轮根据上一轮左移n位+本次左移的位数（或者是本次左移索引+前面左移索引位数），左移后加在一起LnRn，然后根据PC2（CP_2）表重新编排为K，只有48位，生成16个子密钥（注：索引是从1开始）。生成的16个子密钥subkeys会对应明文处理16轮每轮的key\nSHIFT = [1,1,2,2,2,2,2,2,1,2,2,2,2,2,2,1]\nCP_2 = [14, 17, 11, 24, 1, 5, 3, 28,        15, 6, 21, 10, 23, 19, 12, 4,        26, 8, 16, 7, 27, 20, 13, 2,        41, 52, 31, 37, 47, 55, 30, 40,        51, 45, 33, 48, 44, 49, 39, 56,        34, 53, 46, 42, 50, 36, 29, 32]\nL1：1110000 1100110 0101010 1011111R1：1010101 0110011 0011110 0011110L1R1：1110000 1100110 0101010 1011111 1010101 0110011 0011110 0011110编排后K1：00011011 00000010 11101111 11111100 01110000 01110010\n第二次左移2位（对L0和R0左移2位，或者对L1和R1左移1位）L2：1100001 1001100 1010101 0111111R2：0101010 1100110 0111100 0111101L2R2：1100001 1001100 1010101 0111111 0101010 1100110 0111100 0111101编排后K2：01111001 10101110 11011001 11011011 11001001 11100101\n第三次左移4位（对L0和R0左移4位，或者对L2和R2左移2位）L3：0000110 0110010 1010101 1111111R3：0101011 0011001 1110001 1110101L3R3：0000110 0110010 1010101 1111111 0101011 0011001 1110001 1110101编排后K3：010101 011111 110010 001010 010000 101100 111110 011001…\nK1 &#x3D; 000110 110000 001011 101111 111111 000111 000001 110010K2 &#x3D; 011110 011010 111011 011001 110110 111100 100111 100101K3 &#x3D; 010101 011111 110010 001010 010000 101100 111110 011001K4 &#x3D; 011100 101010 110111 010110 110110 110011 010100 011101K5 &#x3D; 011111 001110 110000 000111 111010 110101 001110 101000K6 &#x3D; 011000 111010 010100 111110 010100 000111 101100 101111K7 &#x3D; 111011 001000 010010 110111 111101 100001 100010 111100K8 &#x3D; 111101 111000 101000 111010 110000 010011 101111 111011K9 &#x3D; 111000 001101 101111 101011 111011 011110 011110 000001K10 &#x3D; 101100 011111 001101 000111 101110 100100 011001 001111K11 &#x3D; 001000 010101 111111 010011 110111 101101 001110 000110K12 &#x3D; 011101 010111 000111 110101 100101 000110 011111 101001K13 &#x3D; 100101 111100 010111 010001 111110 101011 101001 000001K14 &#x3D; 010111 110100 001110 110111 111100 101110 011100 111010K15 &#x3D; 101111 111001 000110 001101 001111 010011 111100 001010K16 &#x3D; 110010 110011 110110 001011 000011 100001 011111 110101\n4.对明文进行16轮运算加密明文重新编排后的 11001100 00000000 11001100 11111111 11110000 10101010 11110000 10101010拆分成左右两部分L0：11001100 00000000 11001100 11111111R0：11110000 10101010 11110000 10101010每一轮运算只对R进行改变加密：Li+1&#x3D;RiRi+1&#x3D;Li⊕F(Ri,Ki)解密：Ri&#x3D;Li+1Li&#x3D;Ri+1⊕F(Li+1,Ki)\n\nf函数：\n1. f函数首先将输入经过E表扩展置换，将32位的输入扩展为48位。\n2. 将48位结果与第i轮第密钥ki进行XOR(异或)操作\n3. 将异或操作第结果送入S盒进行压缩，压缩成32位\n4. 将32位的结果送入P盒置换\n\n\n\n\n\nExpand表\nE = [32, 1, 2, 3, 4, 5,     4, 5, 6, 7, 8, 9,     8, 9, 10, 11, 12, 13,     12, 13, 14, 15, 16, 17,     16, 17, 18, 19, 20, 21,     20, 21, 22, 23, 24, 25,     24, 25, 26, 27, 28, 29,     28, 29, 30, 31, 32, 1]\nS盒（S_BOX，8组）\nS_BOX = [    [[14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7], [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8], [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0], [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13],],[[15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10], [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5], [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15], [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9],],[[10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8], [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1], [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7], [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12],],[[7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15], [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9], [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4], [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14],],  [[2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9], [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6], [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14], [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3],], [[12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11], [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8], [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6], [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13],], [[4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1], [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6], [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2], [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12],],   [[13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7], [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2], [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8], [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11],]]\nP盒\nP = [16, 7, 20, 21, 29, 12, 28, 17,     1, 15, 23, 26, 5, 18, 31, 10,     2, 8, 24, 14, 32, 27, 3, 9,     19, 13, 30, 6, 22, 11, 4, 25]\n\n第一轮为例：R1&#x3D; L0⊕f(R0，K1)F函数\tP(S(E(Ri)⊕Ki))：R0：11110000 10101010 11110000 10101010经过E表编排：01111010 00010101 01010101 01111010 00010101 01010101与K1异或后：011000 010001 011110 111010 100001 100110 010100 100111把异或后的拆分8组，进行8轮S盒运算B1 &#x3D; 011000 B2 &#x3D; 010001 B3 &#x3D; 011110 B4 &#x3D; 111010 B5 &#x3D; 100001 B6 &#x3D; 100110 B7 &#x3D; 010100 B8 &#x3D; 100111将每一组前后1个比特拼接为row转十进制，中间4个比特为column转十进制，然后去S盒映射第i个row行column列B1\t0 1100 0 row：00 &#x3D;&#x3D;&gt; 0  （十进制）column：1100 &#x3D;&#x3D;&gt; 12  （十进制）(0, 12) &#x3D;&#x3D;&gt; S[0][0][12]&#x3D;&#x3D;&gt;5B1 &#x3D; 5 &#x3D;&#x3D;&gt; 0101 （二进制）\nB2 \t0 1000 1row：01 &#x3D;&#x3D;&gt; 1  （十进制）column：1000 &#x3D;&#x3D;&gt; 8  （十进制）(1, 8) &#x3D;&#x3D;&gt; S[1][1][8]&#x3D;&#x3D;&gt;12B1 &#x3D;12&#x3D;&#x3D;&gt; 1100（二进制）\nB3 \t0 1111 0 row：00 &#x3D;&#x3D;&gt; 0  （十进制）column：1111&#x3D;&#x3D;&gt; 15  （十进制）(0, 15) &#x3D;&#x3D;&gt; S[2][0][15]&#x3D;&#x3D;&gt;8B1 &#x3D;8&#x3D;&#x3D;&gt; 1000（二进制）…68&#x3D;48bit 经过8轮 48&#x3D;32bit把B1-B8拼接起来：01011100 10000010 10110101 10010111\n经过P盒置换后：00100011 01001010 10101001 10111011F函数结束，结果异或L0R1：11101111 01001010 01100101 01000100L1：R0…16轮后R16：00001010 01001100 11011001 10010101L16：01000011 01000010 00110010 00110100R16L16拼接（R在前），再经过末置换表（PI_1）（64位）：R16L16：00001010 01001100 11011001 10010101 01000011 01000010 00110010 00110100置换后：10000101 11101000 00010011 01010100 00001111 00001010 10110100 00000101转为hex就是结果了：85e813540f0ab405\nPI_1表\nPI_1 = [40, 8, 48, 16, 56, 24, 64, 32,        39, 7, 47, 15, 55, 23, 63, 31,        38, 6, 46, 14, 54, 22, 62, 30,        37, 5, 45, 13, 53, 21, 61, 29,        36, 4, 44, 12, 52, 20, 60, 28,        35, 3, 43, 11, 51, 19, 59, 27,        34, 2, 42, 10, 50, 18, 58, 26,        33, 1, 41, 9, 49, 17, 57, 25]\n\n\n分组密码的填充Passing只用于CBC和ECB模式，默认采用PKCS#7进行填充DES 64比特明文，64比特密钥，结果64比特输出那为什么明文刚好是64比特，如果输入是56比特？20比特？或者什么都不输入呢？明文会切割成每64比特为一组进行des加密，最后一组小于或等于64都会进行填充如果传入的是utf，需先转hex\n小于64比特：123456789（hex）&#x3D;&#x3D;&gt; 1234567809（hex）还差6位hex（3个字节），填充030303：1234567809030303\n123456789abcd（hex）&#x3D;&#x3D;&gt;123456789abc0d（hex）还差2位hex（1个字节），填充01：123456789abc0d01\n\n\n等于64比特，需要填充一整个分组0808080808080808：0123456789abcdef（hex）&#x3D;&#x3D;&gt; 0123456789abcdef0808080808080808\n最少填充一字节，最多填充一整个分组，不能不填充。\n分组密码的工作模式ECB相同的分组输入，计算后的结果是完全一致的，每个分组单独处理，叫ECB工作模式这种模式有很多好处，我们可以直接for 循环，将很长的输入分成对应个数的分组，每个分组得到结果后拼接在一起就行，而且这也意味着可以并行计算。 如果ECB模式是可行的、安全的，那么我们一定选择它，因为最简单和高效。那也就不会出现别的工作模式了，可惜的是它并不安全。\nCBC最常用的模式其实想法也很朴素，每个明文分组在加密前多一个步骤，和上一个分组的密文块进行异或运算。因为第一个明文块没有所谓的“上一个分组的密文块“，所以需要人给一个64比特，或者说8字节的输入，我们叫它初始化向量，IV。在cyberchef中验证一下\n\n明文：123456789ABCDEF0（hex）密钥：133457799BBCDFF1（hex）使用CBC模式IV：0123456789ABCDEF计算结果：0ecb68bac16aece07cbadcfa7a974bcc（hex）\n\n按照我们上面的说法0ecb68bac16aece0的明文应该就是123456789ABCDEF0和0123456789ABCDEF异或的结果得到结果1317131f1317131f使用cyberchef计算123456789ABCDEF0 ^ 0123456789ABCDEF 得到结果1317131f1317131f，单独计算其DES加密结果，注意这儿要用ECB模式: 0ecb68bac16aece0 fdf2e174492922f8，因为1317131f1317131f是一个分组的长度，所以要填充0808080808080808， fdf2e174492922f8是08的结果，所以不用管。可以发现，第一块加密结果0ecb68bac16aece0正是我们所预期的。\n接下来看一下第二块，第二块即0808080808080808，按照CBC的规则计算 0ecb68bac16aece0 ^ 0808080808080808 &#x3D; 06c360b2c962e4e8，单独计算ECB下的06c360b2c962e4e8 结果为7cbadcfa7a974bcc fdf2e174492922f8，第二块结果7cbadcfa7a974bcc也完全正确。\nCFB\n明文：123456789ABCDEF0密钥：133457799BBCDFF1IV：0123456789ABCDEF模式：CFB结果: 97dc452c95b66af5IV即0123456789ABCDEF的des加密结果85e813540f0ab40585e813540f0ab405 与 123456789ABCDEF0 的异或结果是97dc452c95b66af5\n\n\nOFB\n明文：123456789ABCDEF0密钥：133457799BBCDFF1IV：0123456789ABCDEF模式：OFB结果: 97dc452c95b66af5即一个分组的OFB与CFB是一样一样的\n\n两个分组的计算：\n\n明文：123456789ABCDEF0 123456789ABCDEF0密钥：133457799BBCDFF1IV：0123456789ABCDEF模式：OFB结果：97dc452c95b66af5 759a2c51fb637db5\n\n直接观察第二个分组759a2c51fb637db5是如何计算出来呢?它是明文和加密两次的IV的异或结果明文：123456789ABCDEF0 加密第一次：85e813540f0ab405 加密第二次 67ae7a2961dfa345f，最后异或 67ae7a2961dfa345f ^ 123456789ABCDEF0 &#x3D; 759a2c51fb637db5\nCTR","tags":["算法"]},{"title":"对称加解密算法RC4原理过程及实现","url":"/posts/3538/","content":"介绍RC4是一种流密码，可实现短密钥到长密钥的转换，流密码的加密就是比特的异或，为了安全性，关键就是密钥的生成，RC4就是解决密钥生成问题的。\n流密码结构：\n\n\n流密码类似于”一次一密”，不同的是”一次一密”使用的是真正的随机数流，而流密码使用的是伪随机数流。设计流密码的主要因素1、加密序列的周期要长，若出现重复的周期过短，容易被破解2、密钥流应该尽可能地接近真正随机数流的特征3、密钥长度要长，以避免琼穷举攻击\n\n\n\n\n步骤1. 密钥编排，向量S和Y初始化RC4的实现需要三个向量，初始向量S，密钥K,临时向量T\n初始化向量S和T，将向量S填充为0到255的数值，根据密钥K，填充向量T。如果密钥K\n比向量S短，就依次重复填充密钥K，如果与向量S等长，那么向量T与密钥K相同。\nS = []  # 状态数组T = []  # 临时数组# 初始化S和Tfor i in range(256):    S.append(i)    T.append(key[i % len(key)])\n\n\n\n2. 向量S的初始置换，将原来有序的向量S重新排列从0遍历到255，每次 j&#x3D;(j+S[i]+ord(T[i]))%256，然后交换S[i] 和 S[j]，这样S盒顺序就被打乱了\n# 用T产生S的初始置换j = 0for i in range(256):    j = (j + S[i] + ord(T[i])) % 256    S[i], S[j] = S[j], S[i]  # 交换S[i] 和 S[j]    # print(S)\n\n\n3. 密钥生成，每加密一个字符，就需要生成一个字节的密钥根据明文长度生成密钥流\nKs = []i = j = 0for _ in range(len(M)):    i = (i + 1) % 256    j = (j + S[i]) % 256    S[i], S[j] = S[j], S[i]    t = (S[i] + S[j]) % 256    Ks.append(t)\n\n\n\n4. 循环明文长度，每一个字符跟向量S异或C = &quot;&quot;for i in range(len(M)):    C += chr(ord(M[i]) ^ S[Ks[i]])return C\n\n解密也就是把密文当成明文再把加密执行一次\n代码python# 密钥编排函数def KSA(key):    S = []  # 状态数组    T = []  # 临时数组    # 初始化S和T    for i in range(256):        S.append(i)        T.append(key[i % len(key)])        # print(S)        # print(T)    # 用T产生S的初始置换    j = 0    for i in range(256):        j = (j + S[i] + ord(T[i])) % 256        S[i], S[j] = S[j], S[i]  # 交换S[i] 和 S[j]        # print(S)        # print(T)    return S# 密钥流生成函数def generateKey(S, M):    Ks = []    i = j = 0    for _ in range(len(M)):        i = (i + 1) % 256        j = (j + S[i]) % 256        S[i], S[j] = S[j], S[i]        t = (S[i] + S[j]) % 256        Ks.append(t)    return Ks# 加密函数def Rc4_encode(M, key):    C = &quot;&quot;    S = KSA(key)  # 密钥编排    Ks = generateKey(S, M)    for i in range(len(M)):        C += chr(ord(M[i]) ^ S[Ks[i]])    return C# 解密函数def Rc4_decode(C, key):    M = &quot;&quot;    S = KSA(key)  # 密钥编排    Ks = generateKey(S, C)    for i in range(len(C)):        M += chr(ord(C[i]) ^ S[Ks[i]])    return Mkey = &#x27;123456789&#x27;m = &#x27;hello&#x27;C = Rc4_encode(m, key)print(&quot;加密后密文：&quot;, C)M = Rc4_decode(C, key)print(&quot;解密后明文：&quot;, M)\n\n\n\nc++#include &lt;iostream&gt;#include &lt;cstring&gt;using namespace std;void rc4_init(unsigned char *S, char *key, int key_len) &#123;    unsigned char T[256] = &#123;0&#125;;    for (int i = 0; i &lt; 256; i++) &#123;        S[i] = i;        T[i] = key[i % key_len];    &#125;    int j = 0;    for (int i = 0; i &lt; 256; i++) &#123;        j = (j + S[i] + T[i]) % 256;        swap(S[i], S[j]);    &#125;&#125;void rc4_crypto(unsigned char *S, char *text, int text_len) &#123;    int i = 0, j = 0, t = 0;    for (int k = 0; k &lt; text_len; k++) &#123;        i = (i + 1) % 256;        j = (j + S[i]) % 256;        swap(S[i], S[j]);        t = (S[i] + S[j]) % 256;        text[k] ^= S[t];    &#125;&#125;string rc4_main(char *text, int text_len, char *key) &#123;    int key_len = sizeof key - 1;    unsigned char S[256] = &#123;0&#125;;    rc4_init(S, key, key_len);    rc4_crypto(S, text, text_len);    printf(&quot;result =&gt; %s\\n&quot;, text);    //    char out[100] = &#123;0&#125;;    //    base64_encode(text,out);    //    printf(&quot;result(base64) =&gt; %s&quot;, out);    return text;&#125;int main() &#123;    char key[] = &quot;12345&quot;;    char text[] = &quot;hello&quot;;    int text_len = sizeof(text) - 1;    string aa = rc4_main(text, text_len, key);    cout&lt;&lt;aa&lt;&lt;endl;    return 0;&#125;","tags":["算法"]},{"title":"抓包进阶之SSL unpinning","url":"/posts/36427/","content":"SSL Pinning Bypass客户端的证书绑定（pinning）。一种情况没有分析，就是客户端并不会默认信任系统根证书目录中的证书，而是在代码里再加一层校验，这就是证书绑定机制——SSL pinning，如果这段代码的校验过不了，那么客户端还是会报证书错误。两层校验，第一种不信任系统证书，使用自己的证书。第二种在自己证书上再做一层判断● Https客户端代码校验服务器证书案例是自己配置的证书，不是ca机构签发的。这段代码放了自己的证书，一段检验机制\n\n打开charles抓包，抓包失败\n\n信任所有证书，都为空表示都信任\n\n因为图片是https的，修改一下ssl\n\n成功抓包\n让客户端信任系统根证书目录中的证书把证书校验重新开起来\nhook住checkServerTrusted，将其所有重载都置空；使用spawn模式运行\nfunction main()&#123;    Java.perform(function ()&#123;        // 检查一个类是否继承某一个接口        function checkIsImplementeInterFace(clsName, interface_)&#123;            try&#123;              var cls = Java.use(clsName)              if(cls.class.isInterface())&#123;                return false              &#125;              if(cls.class != undefined)                if(interface_.class.isAssignableFrom(cls.class))&#123;                  return true                &#125;              return false            &#125;catch(e)&#123;              return false            &#125;          &#125;        var TrustManagerInterface = Java.use(&quot;javax.net.ssl.TrustManager&quot;)        Java.use(&quot;okhttp3.CertificatePinner&quot;).check.overload(&#x27;java.lang.String&#x27;, &#x27;[Ljava.security.cert.Certificate;&#x27;).implementation = function()&#123;            console.log(&quot;CertificatePinner check called!&quot;)        &#125;        Java.use(&quot;okhttp3.CertificatePinner&quot;).check.overload(&#x27;java.lang.String&#x27;, &#x27;java.util.List&#x27;).implementation = function()&#123;            console.log(&quot;CertificatePinner check called!&quot;)        &#125;        Java.enumerateLoadedClasses(&#123;            onMatch: function(clsName,handle)&#123;                if(checkIsImplementeInterFace(clsName,TrustManagerInterface))&#123;                    console.log(clsName)                    var targetClass = Java.use(clsName)                    var len = targetClass[&quot;checkServerTrusted&quot;].overloads.length                    for (var i = 0; i &lt; len; i++)&#123;                        targetClass[&quot;checkServerTrusted&quot;].overloads[i].implementation = function()&#123;                                                        console.log(clsName + i + &quot;checkServerTrusted Called!&quot;)                            //return targetClass[&quot;checkServerTrusted&quot;].overloads[i].apply(this,arguments)                                                    &#125;                    &#125;                &#125;            &#125;,            onComplete: function()&#123;                console.log(&quot;Search Classes Completed!&quot;)            &#125;        &#125;)            &#125;)&#125;setImmediate(main)\n成功抓到包\n\n过检验证书把证书检验开启\n\nobjection绕过检测使用objection，直接将SSL pinning给disable掉\nandroid sslpinning disable\n\nssl pinning+服务器检验客户端证书注册页面抓包，证书不信任\n用frida hook掉他的一些检测，\nssl pinning（hook掉证书验证(自定义证书)）方式一function main()&#123;    Java.perform(function ()&#123;        // 检查一个类是否继承某一个接口        function checkIsImplementeInterFace(clsName, interface_)&#123;            try&#123;              var cls = Java.use(clsName)              if(cls.class.isInterface())&#123;                return false              &#125;              if(cls.class != undefined)                if(interface_.class.isAssignableFrom(cls.class))&#123;                  return true                &#125;              return false            &#125;catch(e)&#123;              return false            &#125;          &#125;        var TrustManagerInterface = Java.use(&quot;javax.net.ssl.TrustManager&quot;)        // Java.use(&quot;okhttp3.CertificatePinner&quot;).check.overload(&#x27;java.lang.String&#x27;, &#x27;[Ljava.security.cert.Certificate;&#x27;).implementation = function()&#123;        //     console.log(&quot;CertificatePinner check called!&quot;)        // &#125;        // Java.use(&quot;okhttp3.CertificatePinner&quot;).check.overload(&#x27;java.lang.String&#x27;, &#x27;java.util.List&#x27;).implementation = function()&#123;        //     console.log(&quot;CertificatePinner check called!&quot;)        // &#125;        Java.enumerateLoadedClasses(&#123;            onMatch: function(clsName,handle)&#123;                if(checkIsImplementeInterFace(clsName,TrustManagerInterface))&#123;                    console.log(clsName)                    var targetClass = Java.use(clsName)                    var len = targetClass[&quot;checkServerTrusted&quot;].overloads.length                    for (var i = 0; i &lt; len; i++)&#123;                        targetClass[&quot;checkServerTrusted&quot;].overloads[i].implementation = function()&#123;                                                        console.log(clsName + i + &quot;checkServerTrusted Called!&quot;)                            //return targetClass[&quot;checkServerTrusted&quot;].overloads[i].apply(this,arguments)                                                    &#125;                    &#125;                &#125;            &#125;,            onComplete: function()&#123;                console.log(&quot;Search Classes Completed!&quot;)            &#125;        &#125;)            &#125;)&#125;setImmediate(main)\n\n方式二function main()&#123;    Java.perform(function ()&#123;        function checkIsImplementeInterFace(clsName, interface_)&#123;            try&#123;              var cls = Java.use(clsName)              if(cls.class.isInterface())&#123;                return false              &#125;              if(cls.class != undefined)                if(interface_.class.isAssignableFrom(cls.class))&#123;                  return true                &#125;              return false            &#125;catch(e)&#123;              return false            &#125;          &#125;        var TrustManagerInterface = Java.use(&quot;javax.net.ssl.TrustManager&quot;)        // Java.use(&quot;okhttp3.CertificatePinner&quot;).check.overload(&#x27;java.lang.String&#x27;, &#x27;[Ljava.security.cert.Certificate;&#x27;).implementation = function()&#123;        //     console.log(&quot;CertificatePinner check called!&quot;)        // &#125;        // Java.use(&quot;okhttp3.CertificatePinner&quot;).check.overload(&#x27;java.lang.String&#x27;, &#x27;java.util.List&#x27;).implementation = function()&#123;        //     console.log(&quot;CertificatePinner check called!&quot;)        // &#125;        // Java.enumerateClassLoaders(&#123;        //   onMatch: function(loader)&#123;        //       try&#123;        //           if(loader.findClass(&quot;okhttp3.OkHttpClient$Builder&quot;))&#123;        //             console.log(&quot;Found the really Classloader&quot;)        //             Java.classFactory.loader = loader        //           &#125;        //       &#125;catch(e)&#123;        //       &#125;        //   &#125;,        //   onComplete: function()&#123;        //     console.log(&quot;Search Loaders Completed!&quot;)        //   &#125;        // &#125;)        // Java.use(&quot;okhttp3.OkHttpClient$Builder&quot;).certificatePinner.implementation = function(certificatePinner)&#123;        //   return this.certificatePinner(Java.use(&quot;okhttp3.CertificatePinner&quot;).DEFAULT.value) //CertificatePinner.DEFAULT        // &#125;        Java.enumerateLoadedClasses(&#123;            onMatch: function(clsName,handle)&#123;                if(checkIsImplementeInterFace(clsName,TrustManagerInterface))&#123;                    console.log(clsName)                    var targetClass = Java.use(clsName)                    var len = targetClass[&quot;checkServerTrusted&quot;].overloads.length                    for (var i = 0; i &lt; len; i++)&#123;                      //console.log(targetClass[&quot;checkServerTrusted&quot;].overloads[i].returnType.name)                      if(targetClass[&quot;checkServerTrusted&quot;].overloads[i].returnType.name == &#x27;V&#x27;)&#123;                        targetClass[&quot;checkServerTrusted&quot;].overloads[i].implementation = function()&#123;                          console.log(clsName + i + &quot;checkServerTrusted Called!&quot;)                          //return targetClass[&quot;checkServerTrusted&quot;].overloads[i].apply(this,arguments)                        &#125;                      &#125;else&#123;                        targetClass[&quot;checkServerTrusted&quot;].overloads[i].implementation = function()&#123;                          console.log(clsName + i + &quot;checkServerTrusted Called!&quot;)                          //return targetClass[&quot;checkServerTrusted&quot;].overloads[i].apply(this,arguments)                          return null                        &#125;                      &#125;                    &#125;                &#125;            &#125;,            onComplete: function()&#123;                console.log(&quot;Search Classes Completed!&quot;)            &#125;        &#125;)            &#125;)&#125;setImmediate(main)\n现在可以抓到包，证明请求发出去，那就是证书不对\ndump 证书先关掉vpn，让它正常发请求，并用脚本把证书导出\n方法一把证书密码dump出来，手动解压apk搜索证书导入charles即可\nfunction main()&#123;    Java.perform(function ()&#123;        function print_stack(p) &#123;            console.log(&quot;=====&gt;&quot;, p)            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Exception&quot;).$new()));        &#125;                var StringClass = Java.use(&quot;java.lang.String&quot;);        var KeyStore = Java.use(&quot;java.security.KeyStore&quot;);        KeyStore.load.overload(&#x27;java.security.KeyStore$LoadStoreParameter&#x27;).implementation = function (arg0) &#123;            // print_stack(&quot;KeyStore.load1&quot;);            console.log(&quot;KeyStore.load1:&quot;, arg0);            this.load(arg0);        &#125;;        KeyStore.load.overload(&#x27;java.io.InputStream&#x27;, &#x27;[C&#x27;).implementation = function (arg0, arg1) &#123;            // print_stack(&quot;KeyStore.load2&quot;);            console.log(&quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null);            this.load(arg0, arg1);        &#125;;        console.log(&quot;hook_KeyStore_load...&quot;);    &#125;)&#125;setImmediate(main)\n\n方法二dump出证书到手机，并修改证书密码 \nfunction main()&#123;    Java.perform(function ()&#123;        console.log(&quot;Enter!&quot;)        function storeP12(pri, p7, p12Path, p12Password) &#123;            var X509Certificate = Java.use(&quot;java.security.cert.X509Certificate&quot;)            var p7X509 = Java.cast(p7, X509Certificate);            var chain = Java.array(&quot;java.security.cert.X509Certificate&quot;, [p7X509])            var ks = Java.use(&quot;java.security.KeyStore&quot;).getInstance(&quot;PKCS12&quot;, &quot;BC&quot;);            ks.load(null, null);            ks.setKeyEntry(&quot;client&quot;, pri, Java.use(&#x27;java.lang.String&#x27;).$new(p12Password).toCharArray(), chain);            try &#123;              var out = Java.use(&quot;java.io.FileOutputStream&quot;).$new(p12Path);              ks.store(out, Java.use(&#x27;java.lang.String&#x27;).$new(p12Password).toCharArray())            &#125; catch (exp) &#123;              console.log(exp)            &#125;          &#125;          //在服务器校验客户端的情形下，帮助dump客户端证书，并保存为p12的格式，证书密码为r0ysue          Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getPrivateKey.implementation = function () &#123;            var result = this.getPrivateKey()            var packageName = Java.use(&quot;android.app.ActivityThread&quot;).currentApplication().getApplicationContext().getPackageName();            storeP12(this.getPrivateKey(), this.getCertificate(), &#x27;/sdcard/Download/&#x27; + packageName + &#x27;.p12&#x27;, &#x27;r0ysue&#x27;);            console.log(&quot;dumpClinetCertificate=&gt;&quot; + &#x27;/sdcard/Download/&#x27; + packageName + &#x27;.p12&#x27; + &#x27;   pwd: r0ysue&#x27;);                        return result;          &#125;          Java.use(&quot;java.security.KeyStore$PrivateKeyEntry&quot;).getCertificateChain.implementation = function () &#123;            var result = this.getCertificateChain()            var packageName = Java.use(&quot;android.app.ActivityThread&quot;).currentApplication().getApplicationContext().getPackageName();            storeP12(this.getPrivateKey(), this.getCertificate(), &#x27;/sdcard/Download/&#x27; + packageName + &#x27;.p12&#x27;, &#x27;r0ysue&#x27;);            console.log(&quot;dumpClinetCertificate=&gt;&quot; + &#x27;/sdcard/Download/&#x27; + packageName + &#x27;.p12&#x27; + &#x27;   pwd: r0ysue&#x27;);            return result;          &#125;    &#125;)&#125;setImmediate(main)\n\ncharles导入证书adb pull /sdcard/Download/com.ninemax.ncsearchnew.p12 /root/Desktop/\n再运行绕过本地校验脚本，成功抓包\n混淆的okhhtp3抓包\n通过它的官网知道是https，用的ca机构证书。不需要hook证书校验这一步jadx打开搜索 CertificatePinner\n\n通过查看的CertificatePinner源码，和该app的代码对比，基本一样的逻辑，证书校验不通过就会抛异常\n\n使用frida对其hook，置空\nfunction main()&#123;    Java.perform(function ()&#123;        Java.use(&quot;q.g&quot;).a.implementation = function()&#123;            console.log(&quot;check called!&quot;)        &#125;    &#125;)&#125;setImmediate(main)\ncharles设置443端口\n成功抓包\n\n","tags":["抓包"]},{"title":"抓包进阶之双端校验","url":"/posts/39138/","content":"挂上vpn，打开charles抓包可以看到没网络，但是可以抓到包，怀疑是服务器校验客户端证书了这里推荐一下肉老师的文章 https://www.anquanke.com/post/id/197657引用里面一张图原本服务器校验的是app的证书，但是挂上charles，服务器校验的是charles的证书，一匹配发现不是app的证书，就返回网络失败，所以我们要将app中内置的证书导入到Charles中去。这个操作通常需要完成两项内容：\n\n找到证书文件\n找到证书密码首先找证书文件，直接对apk进行解包，直接过滤搜索后缀名为p12的文件即可，一般常用的命令为tree -NCfhl |grep -i p12，直接打印出p12文件的路径\n\n找证书密码一般解密会调用现成的API，java.security.KeyStore ，直接使用frida打印出来，也可以hook系统文件库，这里直接使用现成的代码，\nfunction hook_KeyStore_load() &#123;    Java.perform(function () &#123;        var StringClass = Java.use(&quot;java.lang.String&quot;);        var KeyStore = Java.use(&quot;java.security.KeyStore&quot;);        KeyStore.load.overload(&#x27;java.security.KeyStore$LoadStoreParameter&#x27;).implementation = function (arg0) &#123;            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));            console.log(&quot;KeyStore.load1:&quot;, arg0);            this.load(arg0);        &#125;;        KeyStore.load.overload(&#x27;java.io.InputStream&#x27;, &#x27;[C&#x27;).implementation = function (arg0, arg1) &#123;            console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));            console.log(&quot;KeyStore.load2:&quot;, arg0, arg1 ? StringClass.$new(arg1) : null);            this.load(arg0, arg1);        &#125;;        console.log(&quot;hook_KeyStore_load...&quot;);    &#125;);&#125;setImmediate(hook_KeyStore_load)\n使用spawn的模式启动，密码一下子就吐出来了把证书导入到charles，并输入刚才的密码再次抓包试试，这次页面跳转了，请求也是正常了\n","tags":["抓包"]},{"title":"抓包进阶之通杀okhttp证书","url":"/posts/2012/","content":"三层检验okhttp在客户端有三种检验证书方法证书验证sslSocketFactory证书锁定certificatePinner域名验证hostmaneVerfier\n\n如何做到通杀？三个检验方法都基于 OkHttpClient.Builder()要先找到 OkHttpClient，由于经过混淆的，无法直接定位\n步骤先把内存中的类的存到数组var classesNames = new Array()   // 存放加载的类// 1.把已经加载内存中的类枚举出来，存到一个数组里function loadClasses()&#123;    Java.perform(function ()&#123;        Java.enumerateLoadedClasses(&#123;            onMatch: function(clsName, handle)&#123;                classesNames.push(clsName);                console.log(clsName)            &#125;,            onComplete: function()&#123;                console.log(&quot;Search Class Completed!&quot;);            &#125;        &#125;)    &#125;)&#125;function main()&#123;    loadClasses()&#125;setImmediate(main)\n\n查找 okhttp3.OkHttpClient类和证书CertificatePinner类function findOkhttpClass()&#123;    Java.perform(function ()&#123;        var Modifier = Java.use(&quot;java.lang.reflect.Modifier&quot;)  // 反射框架，可以提供类的一些属性，例如是不是final，sttic等\t\t// 判断类是否是OkhttpClient        function isOkhttpClient(clsName)&#123;\t\t\t// Okhttp3.OkHttpClient            if(clsName.split(&#x27;.&#x27;).length != 2)&#123;                return false;            &#125;                        try&#123;                var cls = Java.use(clsName)                var interfaces = cls.class.getInterfaces()  // 通过反射获得当前类的一些接口                const count = interfaces.length                //console.log(count)\t\t\t\t// 当前类如果实现的接口小于2，就不是，okhttp实现的接口Cloneable, Call.Factory, WebSocket.Factory                 if(count &lt; 2)&#123;                    return false                &#125;                var flag = false\t\t\t\t// 对实现的接口进行遍历，进行判断                for(var i = 0; i &lt; count; i++)&#123;                    var interface_ = interfaces[i]                    var interface_name = interface_.getName()                                        if(interface_name.indexOf(&quot;Cloneable&quot;) &gt; 0)&#123;                        flag = true                    &#125;else&#123;                        if(interface_name.indexOf(&quot;$&quot;) &lt;= 0)&#123;  // 内部类Call.Factory                            return false                        &#125;                    &#125;                &#125;                if(!flag) return false;                \t\t\t\t// 过滤当前类没有内部类                if(cls.class.getDeclaredClasses().length &lt; 1)&#123;                    return false                &#125;\t\t\t\t// 过滤父类不是Object，OkHttpClient没有继承其他类                if(cls.class.getSuperclass().getName() != &#x27;java.lang.Object&#x27;)&#123;                    return false                &#125;                            &#125;catch(e)&#123;                return false            &#125;            return true;        &#125;        function isCertificatePinner(clsName,prefix)&#123;            // prefix=Okhttp3.\t\t\t// CertificatePinner类            if(!clsName.startsWith(prefix))&#123;                return false            &#125;            if(clsName.indexOf(&quot;$&quot;) &gt; 0)&#123;                return false            &#125;                        if(clsName.split(&#x27;.&#x27;).length != 2)&#123;                return false;            &#125;            var cls = Java.use(clsName)            if(cls.class.isInterface())&#123;                return false            &#125;                        if(cls.class.getInterfaces().length &gt; 0)&#123;                return false            &#125;                     if(cls.class.getDeclaredClasses().length &lt; 1)&#123;                return false            &#125;                        if(cls.class.getSuperclass().getName() != &quot;java.lang.Object&quot;)&#123;                return false            &#125;\t\t\t// 类属性是否有Final            if(!Modifier.isFinal(cls.class.getModifiers()))&#123;                return false            &#125;            var flag = false\t\t\t// 获得所有方法，然后遍历            var methods = cls.class.getDeclaredMethods()            for(var i = 0; i &lt; methods.length; i++)&#123;                var method = methods[i]\t\t\t\t// 过滤方法没有参数的                if(method.getParameterCount() &lt; 1)&#123;                    continue                &#125;\t\t\t\t// 方法的第一个参数是java.security.cert.Certificate                if(method.getParameterTypes()[0].getName() == &quot;java.security.cert.Certificate&quot;)&#123;                    flag = true                    break                &#125;            &#125;            if(!flag) return false            flag = false\t\t\t// 获取类的所有成员变量            var fields = cls.class.getDeclaredFields()\t\t\t// 类包含set集合            for(var k = 0; k &lt; fields.length; k++)&#123;                var field = fields[k];                if(field.getType().getName() == &quot;java.util.Set&quot;)&#123;                    flag = true                    break                &#125;            &#125;            if(!flag) return false            console.log(clsName)            return true        &#125;            for(var i = 0; i &lt; classesNames.length; i++)&#123;\t\t\t// 如果类名是OkhttpClient，就保存为变量            if(isOkhttpClient(classesNames[i]))&#123;                OkhttpClientClassName = classesNames[i]                //console.log(OkhttpClientClassName)                var splits = classesNames[i].split(&#x27;.&#x27;)                var len = splits.length                for(var j = 0; j &lt; len-1; j++)&#123;\t\t\t\t\t// Okhttp3.OkHttpClient                    prefix = prefix + splits[j] + &#x27;.&#x27;  // 当前包名的一个前缀，prefix=Okhttp3.                &#125;            &#125;        &#125;        // 找CertificatePinner类        for(var i = 0; i &lt; classesNames.length; i++)&#123;            if(isCertificatePinner(classesNames[i],prefix))&#123;                CertificatePinnerClassName = classesNames[i]                //console.log(CertificatePinnerClassName)            &#125;        &#125;        console.error(&quot;Found Class: &quot;+classesNames.length)        console.error(&quot;Okhttp&#x27;s package prefix: &quot;+prefix)        console.error(&quot;Find the OkhttpClient: &quot;+OkhttpClientClassName)        console.error(&quot;Find the OkhttpCertificatePinner: &quot;+CertificatePinnerClassName)        if(OkhttpClientClassName == &quot;&quot; || CertificatePinnerClassName == &quot;&quot; || prefix == &quot;&quot;)&#123;            console.error(&quot;Can&#x27;t find the okhttp class&quot;)        &#125;    &#125;)&#125;\n\nattach模式运行\n\n找到之后进行hook找builder内部类\nfunction hook()&#123;    Java.perform(function ()&#123;        var Modifier = Java.use(&quot;java.lang.reflect.Modifier&quot;)        //TrustAllManager，自定义类，hook方法置空，什么都不干        var TrustAllManagerClass = Java.registerClass(&#123;            name: &quot;TrustAllManager&quot;,            implements:[Java.use(&quot;javax.net.ssl.X509TrustManager&quot;)],            methods: &#123;                checkClientTrusted(chain, authType) &#123;                    console.log(&quot;checkClientTrusted Called!!&quot;)                &#125;,                checkServerTrusted(chain, authType) &#123;                    console.log(&quot;checkServerTrusted Called!!&quot;)                &#125;,                getAcceptedIssuers() &#123;                  return [];                &#125;,              &#125;        &#125;)        var trustAllManagerHandle = TrustAllManagerClass.$new()\t\t// 仿造\t\t// SSLContext context = SSLContext.getInstance(&quot;TLS&quot;);        // context.init(null, trustManagers ,new SecureRandom());        // SSLSocketFactory factory = context.getSocketFactory();        var sslContext = Java.use(&quot;javax.net.ssl.SSLContext&quot;).getInstance(&quot;TLS&quot;)        sslContext.init(null,Java.array(&quot;Ljavax.net.ssl.X509TrustManager;&quot;,[trustAllManagerHandle]),null)        var sslSocketFactory = sslContext.getSocketFactory()        //HostnameVerify，自定义类        var MyHostnameVerify = Java.registerClass(&#123;            name: &quot;MyHostnameVerify&quot;,            implements:[Java.use(&quot;javax.net.ssl.HostnameVerifier&quot;)],            methods: &#123;                verify(hostname, session)&#123;                    console.log(hostname)                    return true                &#125;            &#125;        &#125;)        var myHostnameVerifyHandle = MyHostnameVerify.$new()\t\t\t\t// 已经拿到okhttp3.OkHttpClient，拿它的内部类builder        var BuilderClassName = Java.use(OkhttpClientClassName).class.getDeclaredClasses()[0].getName()        var OkhttpClient$Buidler = Java.use(BuilderClassName)\t\t// 通过反射获取builder的所有方法        var methods = OkhttpClient$Buidler.class.getDeclaredMethods()                for(var i = 0; i &lt; methods.length; i++)&#123;            var method = methods[i]\t\t\t// 过滤方法没有参数的，目标方法都有参数\t\t\t// builder.sslSocketFactory(factory, (X509TrustManager) trustManagers[0]);\t\t\t// builder.certificatePinner(cerBuilder.build());\t\t\t// builder.hostnameVerifier(new HostnameVerifier()&#123;&#125;)；            if(method.getParameterCount() &lt; 1)&#123;                continue            &#125;\t\t\t// 第一道校验，第一个参数的类名是javax.net.ssl.SSLSocketFactory就进行hook，参数替换为自定义参数            if(method.getParameterTypes()[0].getName() == &quot;javax.net.ssl.SSLSocketFactory&quot;)&#123;                var sslSocketFacotryMethodName  = method.getName()\t\t\t\t// 获取该方法的重载个数                var len = OkhttpClient$Buidler[sslSocketFacotryMethodName].overloads.length\t\t\t\t// 遍历重载                for(var j = 0; j &lt; len; j++)&#123;                    OkhttpClient$Buidler[sslSocketFacotryMethodName].overloads[j].implementation = function(SSLSocketFactory)&#123;\t\t\t\t\t\t// 把参数替换为自定义的类                        arguments[0] = sslSocketFactory                        return this[sslSocketFacotryMethodName].apply(this,arguments)                    &#125;                &#125;                console.log(sslSocketFacotryMethodName,&quot;Hooked!&quot;)            &#125;\t\t\t// 第三道校验，第一个参数是javax.net.ssl.HostnameVerifier就进行hook，参数替换为自定义参数            if(method.getParameterTypes()[0].getName() == &quot;javax.net.ssl.HostnameVerifier&quot;)&#123;                var hostnameVerifierMethodName = method.getName()                                var len = OkhttpClient$Buidler[hostnameVerifierMethodName].overloads.length                for(var j = 0; j &lt; len; j++)&#123;                    OkhttpClient$Buidler[hostnameVerifierMethodName].overloads[j].implementation = function(hostnameVerifier)&#123;                        arguments[0] = myHostnameVerifyHandle                        return this[hostnameVerifierMethodName].apply(this,arguments)                    &#125;                &#125;                console.log(hostnameVerifierMethodName, &quot;Hooked!&quot;)            &#125;\t\t\t// 第二到校验，参数替换为它默认的，builder.certificatePinner(cerBuilder.build());\t\t\t// 默认public static final CertificatePinner DEFAULT = new Builder().build();            if(method.getParameterTypes()[0].getName() == CertificatePinnerClassName)&#123;                var CertificatePinnerClass = Java.use(CertificatePinnerClassName)                var certificatePinnerMethodName = method.getName()                var len = OkhttpClient$Buidler[certificatePinnerMethodName].overloads.length                for(var j = 0; j &lt; len; j++)&#123;                    OkhttpClient$Buidler[certificatePinnerMethodName].overloads[j].implementation = function()&#123;                        console.log(&quot;certificatePinner add called!&quot;)\t\t\t\t\t\t// 拿到所有的域，遍历                        var fields = CertificatePinnerClass.class.getDeclaredFields()                        for(var k = 0; k &lt; fields.length; k++)&#123;                            var field = fields[k];                            var modifiers = field.getModifiers()\t\t\t\t\t\t\t// public static final CertificatePinner DEFAULT = new Builder().build();                            if(Modifier.isFinal(modifiers) &amp;&amp; Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))&#123;                                arguments[0] = field.get(CertificatePinnerClass.class)                            &#125;                        &#125;                        return this[certificatePinnerMethodName].apply(this,arguments)                    &#125;                &#125;                console.log( method.getName(),&quot;Hooked!&quot;)            &#125;        &#125;        var CertificatePinnerClass = Java.use(CertificatePinnerClassName)        var methods = CertificatePinnerClass.class.getDeclaredMethods()        for (var i = 0; i &lt; methods.length; i++)&#123;            var method = methods[i]            if(method.getReturnType().getName() == &#x27;void&#x27;)&#123;                var methodName = method.getName()                console.log(methodName+&quot; Hooked!&quot;)                var m_len = CertificatePinnerClass[methodName].overloads.length                                for (var j = 0; j &lt; m_len; j++)&#123;                    if(CertificatePinnerClass[methodName].overloads[j].returnType.name == &#x27;V&#x27;)&#123;                        CertificatePinnerClass[methodName].overloads[j].implementation = function()&#123;                            console.log(&quot;certificatePinner check called!&quot;)                        &#125;                       &#125;                &#125;            &#125;        &#125;\t\t    &#125;)&#125;\n运行\n\n使用spwan模式主动加载类名function loadOkhttpClient()&#123;    Java.perform(function ()&#123;        try&#123;            // 把找到的类名替换这里            Java.use(&quot;okhttp3.OkHttpClient&quot;)        &#125;catch(e)&#123;            //console.error(e)        &#125;    &#125;)    &#125;\n测试滴答清单app\n完整代码var classesNames = new Array()  // 存放加载的类var OkhttpClientClassName = &quot;&quot;var CertificatePinnerClassName = &quot;&quot;var prefix = &quot;&quot;function loadOkhttpClient()&#123;    Java.perform(function ()&#123;        try&#123;            Java.use(&quot;q.x&quot;)        &#125;catch(e)&#123;            //console.error(e)        &#125;    &#125;)    &#125;// 1.把已经加载内存中的类枚举出来，存到一个数组里function loadClasses()&#123;    Java.perform(function ()&#123;        Java.enumerateLoadedClasses(&#123;            onMatch: function(clsName, handle)&#123;                classesNames.push(clsName)            &#125;,            onComplete: function()&#123;                console.log(&quot;Search Class Completed!&quot;)            &#125;        &#125;)    &#125;)&#125;function findOkhttpClass()&#123;    Java.perform(function ()&#123;        var Modifier = Java.use(&quot;java.lang.reflect.Modifier&quot;)  // 反射框架，可以提供类的一些属性，例如是不是final，sttic等\t\t// 判断类是否是OkhttpClient        function isOkhttpClient(clsName)&#123;\t\t\t// Okhttp3.OkHttpClient            if(clsName.split(&#x27;.&#x27;).length != 2)&#123;                return false;            &#125;                        try&#123;                var cls = Java.use(clsName)                var interfaces = cls.class.getInterfaces()  // 通过反射获得当前类的一些接口                const count = interfaces.length                //console.log(count)\t\t\t\t// 当前类如果实现的接口小于2，就不是，okhttp实现的接口Cloneable, Call.Factory, WebSocket.Factory                 if(count &lt; 2)&#123;                    return false                &#125;                var flag = false\t\t\t\t// 对实现的接口进行遍历，进行判断                for(var i = 0; i &lt; count; i++)&#123;                    var interface_ = interfaces[i]                    var interface_name = interface_.getName()                                        if(interface_name.indexOf(&quot;Cloneable&quot;) &gt; 0)&#123;                        flag = true                    &#125;else&#123;                        if(interface_name.indexOf(&quot;$&quot;) &lt;= 0)&#123;  // 内部类Call.Factory                            return false                        &#125;                    &#125;                &#125;                if(!flag) return false;                \t\t\t\t// 过滤当前类没有内部类                if(cls.class.getDeclaredClasses().length &lt; 1)&#123;                    return false                &#125;\t\t\t\t// 过滤父类不是Object，OkHttpClient没有继承其他类                if(cls.class.getSuperclass().getName() != &#x27;java.lang.Object&#x27;)&#123;                    return false                &#125;                            &#125;catch(e)&#123;                return false            &#125;            return true;        &#125;        function isCertificatePinner(clsName,prefix)&#123;            // prefix=Okhttp3.\t\t\t// CertificatePinner类            if(!clsName.startsWith(prefix))&#123;                return false            &#125;            if(clsName.indexOf(&quot;$&quot;) &gt; 0)&#123;                return false            &#125;                        if(clsName.split(&#x27;.&#x27;).length != 2)&#123;                return false;            &#125;            var cls = Java.use(clsName)            if(cls.class.isInterface())&#123;                return false            &#125;                        if(cls.class.getInterfaces().length &gt; 0)&#123;                return false            &#125;                     if(cls.class.getDeclaredClasses().length &lt; 1)&#123;                return false            &#125;                        if(cls.class.getSuperclass().getName() != &quot;java.lang.Object&quot;)&#123;                return false            &#125;\t\t\t// 类属性是否有Final            if(!Modifier.isFinal(cls.class.getModifiers()))&#123;                return false            &#125;            var flag = false\t\t\t// 获得所有方法，然后遍历            var methods = cls.class.getDeclaredMethods()            for(var i = 0; i &lt; methods.length; i++)&#123;                var method = methods[i]\t\t\t\t// 过滤方法没有参数的                if(method.getParameterCount() &lt; 1)&#123;                    continue                &#125;\t\t\t\t// 方法的第一个参数是java.security.cert.Certificate                if(method.getParameterTypes()[0].getName() == &quot;java.security.cert.Certificate&quot;)&#123;                    flag = true                    break                &#125;            &#125;            if(!flag) return false            flag = false\t\t\t// 获取类的所有成员变量            var fields = cls.class.getDeclaredFields()\t\t\t// 类包含set集合            for(var k = 0; k &lt; fields.length; k++)&#123;                var field = fields[k];                if(field.getType().getName() == &quot;java.util.Set&quot;)&#123;                    flag = true                    break                &#125;            &#125;            if(!flag) return false            console.log(clsName)            return true        &#125;            for(var i = 0; i &lt; classesNames.length; i++)&#123;\t\t\t// 如果类名是OkhttpClient，就保存为变量            if(isOkhttpClient(classesNames[i]))&#123;                OkhttpClientClassName = classesNames[i]                //console.log(OkhttpClientClassName)                var splits = classesNames[i].split(&#x27;.&#x27;)                var len = splits.length                for(var j = 0; j &lt; len-1; j++)&#123;\t\t\t\t\t// Okhttp3.OkHttpClient                    prefix = prefix + splits[j] + &#x27;.&#x27;  // 当前包名的一个前缀，prefix=Okhttp3.                &#125;            &#125;        &#125;        // 找CertificatePinner类        for(var i = 0; i &lt; classesNames.length; i++)&#123;            if(isCertificatePinner(classesNames[i],prefix))&#123;                CertificatePinnerClassName = classesNames[i]                //console.log(CertificatePinnerClassName)            &#125;        &#125;        console.error(&quot;Found Class: &quot;+classesNames.length)        console.error(&quot;Okhttp&#x27;s package prefix: &quot;+prefix)        console.error(&quot;Find the OkhttpClient: &quot;+OkhttpClientClassName)        console.error(&quot;Find the OkhttpCertificatePinner: &quot;+CertificatePinnerClassName)        if(OkhttpClientClassName == &quot;&quot; || CertificatePinnerClassName == &quot;&quot; || prefix == &quot;&quot;)&#123;            console.error(&quot;Can&#x27;t find the okhttp class&quot;)        &#125;    &#125;)&#125;function hook()&#123;    Java.perform(function ()&#123;        var Modifier = Java.use(&quot;java.lang.reflect.Modifier&quot;)        //TrustAllManager，自定义类，hook方法置空，什么都不干        var TrustAllManagerClass = Java.registerClass(&#123;            name: &quot;TrustAllManager&quot;,            implements:[Java.use(&quot;javax.net.ssl.X509TrustManager&quot;)],            methods: &#123;                checkClientTrusted(chain, authType) &#123;                    console.log(&quot;checkClientTrusted Called!!&quot;)                &#125;,                checkServerTrusted(chain, authType) &#123;                    console.log(&quot;checkServerTrusted Called!!&quot;)                &#125;,                getAcceptedIssuers() &#123;                  return [];                &#125;,              &#125;        &#125;)        var trustAllManagerHandle = TrustAllManagerClass.$new()\t\t// 仿造\t\t// SSLContext context = SSLContext.getInstance(&quot;TLS&quot;);        // context.init(null, trustManagers ,new SecureRandom());        // SSLSocketFactory factory = context.getSocketFactory();        var sslContext = Java.use(&quot;javax.net.ssl.SSLContext&quot;).getInstance(&quot;TLS&quot;)        sslContext.init(null,Java.array(&quot;Ljavax.net.ssl.X509TrustManager;&quot;,[trustAllManagerHandle]),null)        var sslSocketFactory = sslContext.getSocketFactory()        //HostnameVerify，自定义类        var MyHostnameVerify = Java.registerClass(&#123;            name: &quot;MyHostnameVerify&quot;,            implements:[Java.use(&quot;javax.net.ssl.HostnameVerifier&quot;)],            methods: &#123;                verify(hostname, session)&#123;                    console.log(hostname)                    return true                &#125;            &#125;        &#125;)        var myHostnameVerifyHandle = MyHostnameVerify.$new()\t\t\t\t// 已经拿到okhttp3.OkHttpClient，拿它的内部类builder        var BuilderClassName = Java.use(OkhttpClientClassName).class.getDeclaredClasses()[0].getName()        var OkhttpClient$Buidler = Java.use(BuilderClassName)\t\t// 通过反射获取builder的所有方法        var methods = OkhttpClient$Buidler.class.getDeclaredMethods()                for(var i = 0; i &lt; methods.length; i++)&#123;            var method = methods[i]\t\t\t// 过滤方法没有参数的，目标方法都有参数\t\t\t// builder.sslSocketFactory(factory, (X509TrustManager) trustManagers[0]);\t\t\t// builder.certificatePinner(cerBuilder.build());\t\t\t// builder.hostnameVerifier(new HostnameVerifier()&#123;&#125;)；            if(method.getParameterCount() &lt; 1)&#123;                continue            &#125;\t\t\t// 第一道校验，第一个参数的类名是javax.net.ssl.SSLSocketFactory就进行hook，参数替换为自定义参数            if(method.getParameterTypes()[0].getName() == &quot;javax.net.ssl.SSLSocketFactory&quot;)&#123;                var sslSocketFacotryMethodName  = method.getName()\t\t\t\t// 获取该方法的重载个数                var len = OkhttpClient$Buidler[sslSocketFacotryMethodName].overloads.length\t\t\t\t// 遍历重载                for(var j = 0; j &lt; len; j++)&#123;                    OkhttpClient$Buidler[sslSocketFacotryMethodName].overloads[j].implementation = function(SSLSocketFactory)&#123;\t\t\t\t\t\t// 把参数替换为自定义的类                        arguments[0] = sslSocketFactory                        return this[sslSocketFacotryMethodName].apply(this,arguments)                    &#125;                &#125;                console.log(sslSocketFacotryMethodName,&quot;Hooked!&quot;)            &#125;\t\t\t// 第三道校验，第一个参数是javax.net.ssl.HostnameVerifier就进行hook，参数替换为自定义参数            if(method.getParameterTypes()[0].getName() == &quot;javax.net.ssl.HostnameVerifier&quot;)&#123;                var hostnameVerifierMethodName = method.getName()                                var len = OkhttpClient$Buidler[hostnameVerifierMethodName].overloads.length                for(var j = 0; j &lt; len; j++)&#123;                    OkhttpClient$Buidler[hostnameVerifierMethodName].overloads[j].implementation = function(hostnameVerifier)&#123;                        arguments[0] = myHostnameVerifyHandle                        return this[hostnameVerifierMethodName].apply(this,arguments)                    &#125;                &#125;                console.log(hostnameVerifierMethodName, &quot;Hooked!&quot;)            &#125;\t\t\t// 第二到校验，参数替换为它默认的，builder.certificatePinner(cerBuilder.build());\t\t\t// 默认public static final CertificatePinner DEFAULT = new Builder().build();            if(method.getParameterTypes()[0].getName() == CertificatePinnerClassName)&#123;                var CertificatePinnerClass = Java.use(CertificatePinnerClassName)                var certificatePinnerMethodName = method.getName()                var len = OkhttpClient$Buidler[certificatePinnerMethodName].overloads.length                for(var j = 0; j &lt; len; j++)&#123;                    OkhttpClient$Buidler[certificatePinnerMethodName].overloads[j].implementation = function()&#123;                        console.log(&quot;certificatePinner add called!&quot;)\t\t\t\t\t\t// 拿到所有的域，遍历                        var fields = CertificatePinnerClass.class.getDeclaredFields()                        for(var k = 0; k &lt; fields.length; k++)&#123;                            var field = fields[k];                            var modifiers = field.getModifiers()\t\t\t\t\t\t\t// public static final CertificatePinner DEFAULT = new Builder().build();                            if(Modifier.isFinal(modifiers) &amp;&amp; Modifier.isStatic(modifiers) &amp;&amp; Modifier.isPublic(modifiers))&#123;                                arguments[0] = field.get(CertificatePinnerClass.class)                            &#125;                        &#125;                        return this[certificatePinnerMethodName].apply(this,arguments)                    &#125;                &#125;                console.log( method.getName(),&quot;Hooked!&quot;)            &#125;        &#125;        var CertificatePinnerClass = Java.use(CertificatePinnerClassName)        var methods = CertificatePinnerClass.class.getDeclaredMethods()        for (var i = 0; i &lt; methods.length; i++)&#123;            var method = methods[i]            if(method.getReturnType().getName() == &#x27;void&#x27;)&#123;                var methodName = method.getName()                console.log(methodName+&quot; Hooked!&quot;)                var m_len = CertificatePinnerClass[methodName].overloads.length                                for (var j = 0; j &lt; m_len; j++)&#123;                    if(CertificatePinnerClass[methodName].overloads[j].returnType.name == &#x27;V&#x27;)&#123;                        CertificatePinnerClass[methodName].overloads[j].implementation = function()&#123;                            console.log(&quot;certificatePinner check called!&quot;)                        &#125;                       &#125;                &#125;            &#125;        &#125;\t\t    &#125;)&#125;function main()&#123;    loadOkhttpClient()    loadClasses()    findOkhttpClass()    hook()        &#125;setImmediate(main)","tags":["抓包"]},{"title":"某东实时弹幕抓取","url":"/posts/57543/","content":"1.抓包，查找sign对于已经拿到sign只想看弹幕的部分直接跳到4。\n用的抓包工具是HttpCanary，随便进入一间直播间，可以看到弹幕走的是websocket，携带的url参数token来自于下面post返回的结果，经过分析只有st,sign,sv三个参数会变，其余都不变。既然分析完了，那就从sign开始入手。当时我找这个sign找了一会没找出来，由于sign会跟其它参数拼接成url，所以我就搜其它参数wifiBssid，搜出来很明显就在第一个。这里hook这个getReportString方法，把它的调用堆栈打印出来，然后去查看。这里我就直接贴出来了，省得大家浪费时间去找，眼尖的可以看到里面有signature，不就跟我们要的sign很像吗，这里把b方法三个参数hook打印一下，进到signature这个方法，可以看到这只是接口，那就搜索这个类，看它在哪里被实现。被getSignFromJni方法实现了，再深入看一下，可以看到加密过程在so里面。这里就直接hook这个函数打印参数，多调用几次，然后跟抓到的数据做对比，看哪些参数不变。经过我的测试，这些参数不用修改，可以直接拿过来用，而且都是string类型的，也不用做什么类型转换。返回值的st，sign，sv都是组成url需要的参数，而且这里的参数v3是post的body的值。\n2.使用rpc进行调用这里就直接使用rpc进行调用就可以了，根据它的参数照搬就可以了。\nimport fridaimport jsonrpc_sign = &quot;&quot;&quot;rpc.exports = &#123;    getsign: function(function_id, body_string, uuid)&#123;      var sig = &quot;&quot;;      Java.perform(        function()&#123;            //拿到context上下文            var currentApplication = Java.use(&#x27;android.app.ActivityThread&#x27;).currentApplication();            var context = currentApplication.getApplicationContext();            var BitmapkitUtils = Java.use(&#x27;com.jingdong.common.utils.BitmapkitUtils&#x27;);            sig = BitmapkitUtils.getSignFromJni(context, function_id, body_string, uuid, &#x27;android&#x27;, &#x27;9.2.0&#x27;);        &#125;       )       return sig;    &#125;&#125;;&quot;&quot;&quot;def get_sign(function_id, body_string, u):    process = frida.get_remote_device().attach(&#x27;com.jingdong.app.mall&#x27;)    script = process.create_script(rpc_sign)    script.load()    sign = script.exports.getsign(function_id, body_string, u)    return signbody_data = &#123;&quot;appId&quot;:&quot;jd.mall&quot;,&quot;content&quot;:&quot;tbV8seY199tCdw6GllmkWyCNNENuGsgwLByA7svt5HbPXvlI9wQhHMk3dT7f0ldfpq6M0MCiUD+A\\nVrY390Yct0FSub03INUml9n1bS9rZSF3XT0q1kQdehKPO4CccMiEA6NQXYiqYn9wLsDDYEIjmkVA\\nEbXI88CwO0K7uhwemdhQMZrcIFj6jMmyiDNDxSA1OjFw88hR0oSCF0m8ll9o9iU2MVSHDipF5ZDn\\nFR4E+82mwfRYIxamafB+nWG8GuHcKhiQOWGbChTcG3TxcGT053wfcc6uuMD7+L4PcsNRQjM9syFc\\nXR6FBu/sCV/kH/3rT8w/m3zV1c9JpW9lq/7WVzCVvAIj7RNt2zzYFisymCE=&quot;&#125;body_string = json.dumps(body_data, ensure_ascii=False).replace(&quot; &quot;, &quot;&quot;)function_id = &#x27;liveauth&#x27;u = &#x27;-a08d16f38776&#x27;sign = get_sign(function_id, body_string, u)print(sign)\n结果：\nst=1608288325570&amp;sign=bf449b04f88afea4c08e18006127cace&amp;sv=121\n\n3.构造请求拿到认证上面只是拿到了sign，还得拼接url进行请求，这里就不展示了，要的参数基本都有了，其它不变的参数照搬就行，我就直接post请求拿结果了。\n&#123;&#x27;code&#x27;: 0, &#x27;msg&#x27;: &#x27;鉴权成功&#x27;, &#x27;data&#x27;: &#123;&#x27;liveUrl&#x27;: &#x27;wss://live-ws4.jd.com&#x27;, &#x27;token&#x27;: &#x27;amQubWFsbF_muLjlrqJfOTMxMTE0MzY4NDNfMTYwODI3OTE4NzA5NGxTNkViVw==&#x27;&#125;&#125;\n\n4.建立WebSocket保存刚才请求websocket，打开可以看到它请求的参数。\n&#123;  &quot;app&quot;: &quot;com.jingdong.app.mall&quot;,  &quot;host&quot;: &quot;live-ws4.jd.com&quot;,  &quot;remoteIp&quot;: &quot;106.39.169.212&quot;,  &quot;remotePort&quot;: 443,  &quot;sessionId&quot;: &quot;c77ac6e9-019d-4ac9-8611-92f24eb29851&quot;,  &quot;time&quot;: &quot;2020-12-19 23:48:18&quot;,  &quot;url&quot;: &quot;wss://live-ws4.jd.com/?token\\u003damQubWFsbF_muLjlrqJfMjg5NDU0ODc3NDZfMTYwODI3Mjg5ODE0NFdSb0xibw\\u003d\\u003d&quot;&#125;\n\n怎么建立WebSocket连接呢？这里就需要用到python的aiowebsocket库。详细的说明和使用方法请看：https://zhuanlan.zhihu.com/p/82089648代码如下\nimport asyncioimport loggingfrom datetime import datetimefrom aiowebsocket.converses import AioWebSocketimport LiveBarrageimport jsonasync def startup(uri):    async with AioWebSocket(uri) as aws:        converse = aws.manipulator        # 客户端给服务端发送消息        a = &#123;            &quot;aid&quot;: &quot;dongdong&quot;,            &quot;body&quot;: &#123;&quot;ext&quot;:                        &#123;&quot;appid&quot;:&quot;jd.mall&quot;,                        &quot;entrace&quot;:&quot;6&quot;,                        &quot;ver&quot;:&quot;1.1&quot;&#125;,                    &quot;groupid&quot;:&quot;3092724&quot;, # 这个是房间号                    &quot;nickName&quot;:&quot;神秘观众&quot;,                    &quot;type&quot;:&quot;join_live_broadcast&quot;&#125;,            &quot;from&quot;:&#123;&quot;app&quot;:&quot;jd.live&quot;,                    &quot;clientType&quot;:&quot;android&quot;,                    &quot;dvc&quot;:&quot;-a08d16f38776&quot;,                    &quot;pin&quot;:&quot;&quot;&#125;,            &quot;id&quot;:&quot;df09a645-8e9b-4aad-b699-d44753ca8738&quot;,            &quot;type&quot;:&quot;chat_group_message&quot;,            &quot;ver&quot;:&quot;9.3.2&quot;        &#125;        # 把json转换为字符串        body_string = json.dumps(a, ensure_ascii=False).replace(&quot; &quot;, &quot;&quot;)        # print(body_string)        await converse.send(body_string)        while True:            mes = await converse.receive()            # 设置编码            mes = mes.decode(&#x27;utf8&#x27;)            # nickName是用户名，判断nickName可以过滤非弹幕消息            if &#x27;nickName&#x27; in mes:                print(&#x27;&#123;time&#125;-Client receive: &#123;rec&#125;&#x27;                    .format(time=datetime.now().strftime(&#x27;%Y-%m-%d %H:%M:%S&#x27;), rec=mes))if __name__ == &#x27;__main__&#x27;:    token = LiveBarrage.token()  # 这里返回的是post请求后拿到的token    #remote = &#x27;wss://api.bbxapp.vip/v1/ifcontract/realTime&#x27;    print(token)    try:        asyncio.get_event_loop().run_until_complete(startup(token))    except KeyboardInterrupt as exc:        logging.info(&#x27;Quit.&#x27;)\n\n运行结果如下：\n可以看到是实时抓取的，到这里就结束了。\n5.其它接口这个app的接口参数都是一样的，不同的接口由functionId这个参数决定的。\n这里我就把其它的接口名发出来，然后post的参数hook查看一下照搬就可以了。搜索 search商品评价列表 getCommentListWithCard问答 getQuestionList直播带货商品 liveCartDetail弹幕 liveauth\n","tags":["抓包","安卓逆向"]},{"title":"某音web端X-Bogus 逆向分析算法","url":"/posts/16537/","content":"目标：视频评论接口X-Bogus参数接口地址：’aHR0cHM6Ly93d3cuZG91eWluLmNvbS9hd2VtZS92MS93ZWIvY29tbWVudC9saXN0Lw&#x3D;&#x3D;’\n抓包该接口是xhr请求，使用xhr下断点，当url中包含X-Bogus时就断下看调用栈上一层是在webmssdk.es5.js文件里，其实这个文件就是生成参数的，通过查阅知道这就是jsvmp，而且整体上也做了混淆。\n这里使用v_jstools插件进行变量的压缩计算。还原后使用浏览器的 Overrides 替换功能将 webmssdk.es5.js替换掉。往上跟栈也就是跟到上图的堆栈b那里，X-Bogus参数是在this.openArgs[1]里面，直接打一个条件断点在b那this.openArgs[1].indexOf(&quot;X-Bogus&quot;) != -1翻页评论重新触发请求，如图所示，到这里就已经生成了X-Bogus如图所示，$函数这里就已经生成了X-Bogus，this.openArgs[1]就是携带了xb的完整url仔细观察这段代码，有很多三元表达式，当 M 的值为 15 时，就会走到这段逻辑，执行完函数后赋值给K，K 的值生成之后，有一个 O[S] &#x3D; K 的操作。再往上看代码，O初始化的地方O 是一个数组，单步调试的话会发现代码会一直走这个 if-else 的逻辑，几乎每一步都有 O 数组的参与，不断往里面增删改查值，for 循环里面的 j 值，决定着后续 if 语句的走向，这里也就是插桩的关键所在。\n插桩分析大的 for 循环和 if-else 逻辑有两个地方，为了保证最后的日志更加详细完整，在这两个地方都下个日志断点（右键 Add logpoint），断点内容为：“位置 1”, “索引j”, j, “索引A”, A, “值O: “, JSON.stringify(O, function(key, value) {if (value &#x3D;&#x3D; window) {return undefined} return value})“位置 2”, “索引j”, j, “索引A”, A, “值O: “, JSON.stringify(O, function(key, value) {if (value &#x3D;&#x3D; window) {return undefined} return value})\n插桩输出 O 的时候为什么要写这么长一串呢？首先 JSON.stringify() 方法的作用是将 JavaScript 值转换为 JSON 字符串，基础语法是 JSON.stringify(value[, replacer [, space]])，如果不将其转换成 JSON，那么 O 的值，输出可能是这样的：[empty, Array(26), 1, Array(0)]，你看不到 Array 数组里面具体的值，该方法有个可选参数 replacer，如果 replacer 为函数，则 JSON.stringify 将调用该函数，并传入每个成员的键和值，在函数中可以对成员进行处理，最后返回处理后的值，如果此函数返回 undefined，则排除该成员。下好日志断点后，注意前面我们下的 XHR 断点不要取消，然后进行翻页出发请求，控制台就开始打印日志了，如果 XHR 断点取消了，日志就会一直打印直到卡死。日志输出完毕后，右键Save as保存下来到本地进行分析顺便记录下当前已经生成的xb，DFSzswVupV0ANJPItap8URXAIQ5fxb由DFSzswVupV0ANJPItap8URXAIQ5f这28位字符组成的，现在看是怎么来的，打开刚才的日志，在里面搜索，找到第一次出现的地方。可以看到是逐个生成的，在9047行，xb后面的元素是null，到了下一行9048就生了下一个字符f，那么在这两步之间就是f的生成逻辑，这个时候我们看第9047行的日志断点是 位置 2 索引j 16 索引A 716，那么我们回到原网页，在位置2，下一个条件断点（右键 Add conditional breakpoint），当 j&#x3D;&#x3D;16 &amp;&amp; A&#x3D;&#x3D;716 &amp;&amp; O[7] &#x3D;&#x3D; 21 时就断下。之所以要加 O[7] 是因为 索引j 16 索引A 716 的位置有很多，多加个限制条件就可以缩小范围，当然有可能加了多个条件仍然有多个位置都满足，就需要自己筛选了，通过断点断下的时候看看控制台前面输出的日志来判断是不是我们想要的位置。继续翻页，断下之后开始单步跟，来到下图所示的地方：到这里之后，就不要下一步了，再下一步有可能整个语句就执行完毕了，其中的细节你看不到，所以这里我们在控制台挨个输入看看：可以看到实际上的逻辑就是返回指定位置的字符，w 的值就是 O[5]，m 的值就是 O[4]，经过多次调试发现 m 的值是固定的，P 就是 charAt() 方法。我们再看看我们本地的日志，O[5] 的值为 [16]，charAt() 取值出来就是f，逻辑完全正确。现在我们还需要知道这个16是怎么来的，继续往上看，找到16第一次出现的地方，在第9046行，那么我们就要使其在上一步断下，也就是第9045行，如下图所示：第9045行的索引信息为 位置 2 索引j 47 索引A 708，同样的下条件断点观察怎么生成的：可以看到逻辑是 O[5] &amp; O[6]，再把值赋给O[5]，再看我们之前本地的日志O[5] &#x3D; 5809808O[6] &#x3D; 635809808 &amp; 63 &#x3D; 16，逻辑正确，16就是这么来的。接下来又开始找 5809808 和 63 是怎么生成的，先看看63是怎么来的，同样在生成的上一步，也就是第9044行下个条件断点，这行的索引为 位置 2 索引j 72 索引A 704。 可以看到 63 是直接 F[A] 生成的，F 是一个大数组，A 就是索引为 704，F 这个大数组怎么来的先不用管，经过几次测试发现是固定的。5809808后面再说，再逐个找倒数的字符串的生成，记录下来xb &#x3D; “DFSzswVupV0ANJPItap8URXAIQ5f”m &#x3D; “Dkdpgh4ZKsQB80&#x2F;Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe&#x3D;”第28字符串 &#x3D;&#x3D;&gt; f&#x3D;m[16]，16&#x3D;5809808&amp;63，63&#x3D;F[704]第27字符串 &#x3D;&#x3D;&gt; 5&#x3D;m[26]，26&#x3D;1664&gt;&gt;6，6&#x3D;F[646]第26字符串 &#x3D;&#x3D;&gt; Q&#x3D;m[10]，10&#x3D;40960&gt;&gt;12，12&#x3D;F[580]第25字符串 &#x3D;&#x3D;&gt; I&#x3D;m[22]，22&#x3D;5767168&gt;&gt;18，18&#x3D;F[510]第24字符串 &#x3D;&#x3D;&gt; A&#x3D;m[30]，30&#x3D;7701854&amp;63，63&#x3D;F[704]第23字符串 &#x3D;&#x3D;&gt; X&#x3D;m[21]，21&#x3D;1344&gt;&gt;6，6&#x3D;F[646]第22字符串 &#x3D;&#x3D;&gt; R&#x3D;m[24]，24&#x3D;98304&gt;&gt;12，12&#x3D;F[580]第21字符串 &#x3D;&#x3D;&gt; U&#x3D;m[29]，29&#x3D;7602176&gt;&gt;18，18&#x3D;F[510]第20字符串 &#x3D;&#x3D;&gt; 8&#x3D;m[12]，12&#x3D;16232652&amp;63，63&#x3D;F[704]\n把xb &#x3D; DFSz swVu pV0A NJPI tap8 URXA IQ5f，将其看成每四个为一组，从上面的规律可以得到，每4个字符串为一组，每组的字符生成流程都是一样的\n就差大数字是怎么来的，搜本地日志5809808第一次出现的位置，x直接定位到第一次出现的地方第8979行的上一行第8978行，位置 2 索引j 48 索引A 454可以看出大数字是O[2]|O[3]计算而来，那我们本地5809808就是5809664|144\n找到144第一次出现的地方，同样的操作114是由O[4].charCodeAt(O[5])生成，O[4]&#x3D;’\\x02ÿ-%.,2\\x10^\\x8F\\x1AÖ÷°cÛ\\x85^X¦?’，O[5]&#x3D;20经过几次测试知道乱码字符串是跟url有关，生成过程后面说。用我们本地的O[4]试一下“\\u0002ÿ-%.,\\u000F^\\u001AÖ÷°Ìu^X¦”.charCodeAt(20)经过后面8位字符的跟进后，记录了一下规则xb &#x3D; “DFSzswVupV0ANJPItap8URXAIQ5f”m &#x3D; “Dkdpgh4ZKsQB80&#x2F;Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe&#x3D;”\n\n第28字符串f：\t  f&#x3D;m[16]  16&#x3D;5809808&amp;63 63&#x3D;F[704]\t5809808&#x3D;5809664|144\t144&#x3D;”\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(20)\t5809664&#x3D;5767168|42496 42496&#x3D;166&lt;&lt;8\t8&#x3D;F[386]\t166&#x3D;”\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(19)\t5767168&#x3D;88&lt;&lt;16\t16&#x3D;F[320]\t88&#x3D;”\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(18)\n\n第27字符串5：\t5&#x3D;m[26]\t26&#x3D;1664&gt;&gt;6\t6&#x3D;F[646]\t1664&#x3D;5809808&amp;4032\t4032&#x3D;F[638]\n\n第26字符串Q：\tQ&#x3D;m[10]\t10&#x3D;40960&gt;&gt;12\t12&#x3D;F[580]\t40960&#x3D;5809808&amp;258048\t258048&#x3D;F[568]\n\n第25字符串I：\tI&#x3D;m[22]\t22&#x3D;5767168&gt;&gt;18\t18&#x3D;F[510]\t5767168&#x3D;5809808&amp;16515072\t16515072&#x3D;F[498]\n\n第24字符串A:\tA&#x3D;m[30]\t30&#x3D;7701854&amp;63\t63&#x3D;F[704]\t7701854&#x3D;7701760|94\t94&#x3D;”\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(17)\t7701760&#x3D;7667712|34048\t34048&#x3D;133&lt;&lt;8\t8&#x3D;F[386]\t133&#x3D;”\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(16)\t7667712&#x3D;117&lt;&lt;16\t16&#x3D;F[320]\t117&#x3D;”\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(15)\n\n第23字符串X：\tX&#x3D;m[21]\t21&#x3D;1344&gt;&gt;6\t6&#x3D;F[646]\t1344&#x3D;7701854&amp;4032\t4032&#x3D;F[638]\n\n第22字符串R：\tR&#x3D;m[24]\t24&#x3D;98304&gt;&gt;12\t12&#x3D;F[580]\t98304&#x3D;7701854&amp;258048\t258048&#x3D;F[568]\n\n第21字符串U：\tU&#x3D;m[29]\t29&#x3D;7602176&gt;&gt;18\t18&#x3D;F[510]\t7602176&#x3D;7701854&amp;16515072\t16515072&#x3D;F[498]\n\n\n正序整理了一下，大致的流程就是m &#x3D; “Dkdpgh4ZKsQB80&#x2F;Mfvw36XI1R25-WUAlEi7NLboqYTOPuzmFjJnryx9HVGcaStCe&#x3D;”xb &#x3D; “DFSz swVu pV0A NJPI tap8 URXA IQ5f”&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;第6组 URXA &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;“\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(15) &#x3D; 117F[320] &#x3D; 16117 &lt;&lt; 16 &#x3D; 7667712\n“\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(16) &#x3D; 133F[386] &#x3D; 8133 &lt;&lt; 8 &#x3D; 340487667712|34048 &#x3D; 7701760\n“\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(17) &#x3D; 947701760 | 94 &#x3D; 7701854\nF[498] &#x3D; 165150727701854 &amp; 16515072 &#x3D; 7602176F[510] &#x3D; 187602176 &gt;&gt; 18 &#x3D; 29m.charAt(29) &#x3D; ‘U’\nF[568] &#x3D; 2580487701854 &amp; 258048 &#x3D; 98304F[580] &#x3D; 1298304 &gt;&gt; 12 &#x3D; 24m.charAt(24) &#x3D; ‘R’\tF[638] &#x3D; 40327701854 &amp; 4032 &#x3D; 1344F[646] &#x3D; 61344 &gt;&gt; 6 &#x3D; 21m.charAt(21) &#x3D; ‘X’\nF[704] &#x3D; 637701854 &amp; 63 &#x3D; 30m.charAt(30) &#x3D; ‘A’\t&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;第7组 IQ5f &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;“\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(18) &#x3D; 88F[320] &#x3D; 1688 &lt;&lt; 16 &#x3D; 5767168\n“\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(19) &#x3D; 166F[386] &#x3D; 8166 &lt;&lt; 8 &#x3D; 424965767168 | 42496 &#x3D; 5809664\n“\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu^X¦”.charCodeAt(20) &#x3D; 1445809664 | 144 &#x3D; 5809808\nF[498] &#x3D; 165150725809808 &amp; 16515072 &#x3D; 5767168F[510] &#x3D; 185767168 &gt;&gt; 18 &#x3D; 22m.charAt(22) &#x3D; ‘I’\nF[568] &#x3D; 2580485809808 &amp; 258048 &#x3D; 40960F[580] &#x3D; 1240960 &gt;&gt; 12 &#x3D; 10m.charAt(10) &#x3D; ‘Q’\nF[638] &#x3D; 40325809808 &amp; 4032 &#x3D; 1664F[646] &#x3D; 61664 &gt;&gt; 6 &#x3D; 26m.charAt(26) &#x3D; ‘5’\nF[704] &#x3D; 635809808 &amp; 63 &#x3D; 16m.charAt(16) &#x3D; ‘f’\n将流程对比一下就可以发现，每个步骤 F 里面的取值都是一样的，这个可以直接写死，不同之处就在于最开始的 charCodeAt() 操作，也就是返回乱码字符串指定位置字符的 Unicode 编码，第7组依次是 18、19、20，第6组依次是15、16、17，以此类推，第1组刚好是0、1、2，如下图所示：每一组的逻辑都是一样的，依次生成七组字符串，最后拼接成完整的 X-Bogus。\n乱码字符串生成逻辑该样本对应的param_url &#x3D; “device_platform&#x3D;webapp&amp;aid&#x3D;6383&amp;channel&#x3D;channel_pc_web&amp;aweme_id&#x3D;7071984856741186853&amp;cursor&#x3D;0&amp;count&#x3D;20&amp;item_type&#x3D;0&amp;insert_ids&#x3D;&amp;rcFT&#x3D;&amp;pc_client_type&#x3D;1&amp;version_code&#x3D;170400&amp;version_name&#x3D;17.4.0&amp;cookie_enabled&#x3D;true&amp;screen_width&#x3D;2048&amp;screen_height&#x3D;1152&amp;browser_language&#x3D;zh-CN&amp;browser_platform&#x3D;Win32&amp;browser_name&#x3D;Chrome&amp;browser_version&#x3D;110.0.0.0&amp;browser_online&#x3D;true&amp;engine_name&#x3D;Blink&amp;engine_version&#x3D;110.0.0.0&amp;os_name&#x3D;Windows&amp;os_version&#x3D;10&amp;cpu_core_num&#x3D;20&amp;device_memory&#x3D;8&amp;platform&#x3D;PC&amp;downlink&#x3D;3.85&amp;effective_type&#x3D;4g&amp;round_trip_time&#x3D;100&amp;webid&#x3D;7206219799877142077&amp;msToken&#x3D;Z9-0y9elP0-Obz51QiLXg2qpd-dyJHammHH_0hNY48UFC3RxAx8bjxf2Hpmxmm52cmDQVfBP0lf1UwzvAtbOcW6RGQuSY_1W-plCkw-lP-OkNH00Ion2DohnZlsySAc&#x3D;”在进行下一步之前，我们要注意两点：\n\n文章演示有些变量前后不对应，因为每次插桩的值都是会变的，看流程就行了，流程是正确的；\n我们日志输出是经过 JSON.stringify 处理了的，有些步骤是向某个函数传入乱码字符串进行处理，你会发现处理后的结果和日志不一致，这是正常的。\n\n乱码字符串的生成相对来说稍微复杂一点，但思路仍然一样，这里就不一一截图展示了，直接用日志描述一下关键步骤，注意以下日志是正向的步骤，就不逆着推了，建议自己先逆着把流程走一走，再来看这个步骤就看得懂了。\nStep1：首先对 URL 后面的参数，也就是 Query String Parameters 进行两次 MD5、两次转 Uint8Array 处理，最后得到的 Uint8Array 对象在后面的步骤中用得到，步骤如下：位置 1 索引j 4 索引A 134：将 URL 后面的参数进行 MD5 加密得到字符串位置 1 索引j 16 索引A 494：将上一步的字符串转换为 Uint8Array 对象位置 1 索引j 4 索引A 134：将上一步的 Uint8Array 对象进行 MD5 加密，得到字符串位置 1 索引j 16 索引A 504：将上一步的字符串转换为 Uint8Array 对象\n上述步骤中，我们将最终得到的结果命名为 uint8Array，md5字符串转uint8Array，跟进到相应位置把函数抠出来即可\nStep2：生成两个大数，一个是时间戳，我们称之为 fixedString1，另一个调用某个方法生成，我们称之为 fixedString2。fixedString1位置 1 索引j 43 索引A 1032：1677985818608 &#x2F; 1000 &#x3D; 1677985818.608fixedString2位置 1 索引j 16 索引A 1060：P.apply(null, []) &#x3D; 1489154074上述步骤中，P 对应以下方法，缺失的方法自行补齐：\nfunction _0x17dd8c() &#123;    try &#123;        return _0x2fc47d || (_0xeb6638.perf ? -1 : _0x2fc47d = _0x5bc542(3735928559));    &#125; catch (a) &#123;        return -1;    &#125;&#125;function _0x5bc542(a) &#123;    var b, c = document.createElement(&quot;canvas&quot;);    c.width = 48, c.height = 16;    var e = c.getContext(&quot;2d&quot;);    e.font = &quot;14px serif&quot;, e.fillText(&quot;龘ฑภ경&quot;, 2, 12), e.shadowBlur = 2, e.showOffsetX = 1,     e.showColor = &quot;lime&quot;, e.arc(8, 8, 8, 0, 2), e.stroke(), b = c.toDataURL();    for (var d = 0; d &lt; 32; d++) &#123;        a = 65599 * a + b.charCodeAt(a % b.length) &gt;&gt;&gt; 0;    &#125;    return a;&#125;\n\nStep3：先后生成两个数组，我们称之为 array1、array2，array2 就是由 array1 的元素位置变换后得来的，严格来讲，array1 不是一个完整的数组，而是一个个数字，这一点可以在日志中体现出来，为了方便我们就直接将其视为一个数组，两个数组都有19个元素，步骤如下：array1[0] 至 array1[3] 为定值  [64,0.00390625,1,8]array1[4]位置 1 索引j 25 索引A 1172：uint8Array[14] &#x3D; 127array1[5]位置 1 索引j 25 索引A 1196：uint8Array[15] &#x3D; 208\narray1[6]、array1[7] 可以直接写死\narray1[8]、array1[9]  与 ua 有关, 可以直接写死\narray1[10]位置 1 索引j 52 索引A 1316：fixedString1 &gt;&gt; 24 &#x3D; 100位置 1 索引j 47 索引A 1324：100 &amp; 255 &#x3D; 100\narray1[11]位置 1 索引j 52 索引A 1348：fixedString1 &gt;&gt; 16 &#x3D; 25604位置 1 索引j 47 索引A 1356：25604 &amp; 255 &#x3D; 4\narray1[12]位置 1 索引j 52 索引A 1380：fixedString1 &gt;&gt; 8 &#x3D; 6554632位置 1 索引j 47 索引A 1388：6554632 &amp; 255 &#x3D; 8\narray1[13]位置 1 索引j 52 索引A 1412：fixedString1 &gt;&gt; 0 &#x3D; 1677985818位置 1 索引j 47 索引A 1420：1677985818 &amp; 255 &#x3D; 26\narray1[14]位置 1 索引j 52 索引A 1444：fixedString2 &gt;&gt; 24 &#x3D; 88位置 1 索引j 47 索引A 1452 ：88 &amp; 255 &#x3D; 88\narray1[15]位置 1 索引j 52 索引A 1476：fixedString2 &gt;&gt; 16 &#x3D; 22722位置 1 索引j 47 索引A 1484：22722 &amp; 255 &#x3D; 194\narray1[16]位置 1 索引j 52 索引A 1508：fixedString2 &gt;&gt; 8 &#x3D; 5817008位置 1 索引j 47 索引A 1516：5817008 &amp; 255 &#x3D; 176\narray1[17]位置 1 索引j 52 索引A 1540：fixedString2 &gt;&gt; 0 &#x3D; 1489154074位置 1 索引j 47 索引A 1548：1489154074 &amp; 255 &#x3D; 26\narray1[18]前面18个字符全部进行亦或位置 1 索引j 49 索引A 1736：array1.reduce(function(a, b) { return a ^ b; }); &#x3D; 96\narray1 完整值如下位置 1 索引j 16 索引A 1932：array1 &#x3D; [64,0.00390625,1,8,127,208,69,63,35,157,100,4,8,26,88,194,176,26,96]array2 由 array1 元素交换位置而来：array2 &#x3D; [array1[0], array1[2], array1[4], array1[6], array1[8], array1[10], array1[12], array1[14], array1[16], array1[18], array1[1], array1[3], array1[5], array1[7], array1[9], array1[11], array1[13], array1[15], array1[17]]array2 完整值如下array2 &#x3D; [64, 1, 127, 69, 35, 100, 8, 88, 176, 96, 0.00390625, 8, 208, 63, 157, 4, 26, 194, 26]\nStep4：将 Step3 得到的 array2 经过转换得到乱码字符串，步骤如下：位置 1 索引j 16 索引A 1932：_0x398111.apply(null, array2) &#x3D; ‘@\\u0000\\u0001\\bÐE?#d\\u0004\\b\\u001aXÂ°\\u001a&#96;’\n\n\n位置 1 索引j 16 索引A 1986：_0x25788b.apply(null, [‘ÿ’,‘@\\x00\\x01\\bïwE?#\\x9Dd\\x074\\x89XÂ°\\x1Aû’]) &#x3D; ‘-%.,\\u000f^\\u001aÖ÷°Ìu�^X¦’\n\n 位置 1 索引j 16 索引A 2038：_0x94582.apply(null, [2,255,’-%.,\\u000f^\\u001aÖ÷°Ìu�^X¦’]) &#x3D; “\\u0002ÿ-%.,\\u000f^\\u001aÖ÷°Ìu�^X¦”\n\n至此乱码字符串的流程就结束了。以上缺的函数根据相应的索引根据到代码位置抠出来即可\n测试成功，我这里把生成方式封装成api接口\n","tags":["js"]},{"title":"检测vpn抓包","url":"/posts/21585/","content":"这是肉师傅知识星球的一道检测vpn抓包的练习题，当检测到开启vpn就会闪退软件我放在网盘了，需要的自取链接：https://pan.baidu.com/s/1h4QkrLyDlz8Wb1XylzYLWA提取码：jjrh既然已经知道是检测vpn了，通过查询资料以下4个类跟网络相关\n\n通过百度知道java.net.NetworkInterface.getName()是检测vpn的api，用objection来hook查看一下\n\n发现当开关vpn时，会检测到tun0的网卡，可以用来监测是否开启vpn。那用frida来hook修改tun0的返回值看看能不能绕过\n\n还是会闪退，怀疑检测点不止一个NetworkCapabilities 也有检测vpn的用objection hook一下 android.net.ConnectivityManager.getNetworkCapabilities\n\n通过查看文档知道，返回null即可\n\n用frida hook返回为null，还是闪退，用jadx打开查看报错位置\n\n这里返回null的话就无法调用后面的hasTransport方法，直接hook hasTransport修改返回值为false绕过\n\n开启vpn后app不闪退了，成功绕过\n\n完整代码\nfunction main() &#123;    Java.perform(function () &#123;        Java.use(&quot;java.net.NetworkInterface&quot;).getName.implementation = function()&#123;            var string_class = Java.use(&quot;java.lang.String&quot;);            var gname = this.getName();            if(gname == string_class.$new(&quot;tun0&quot;))&#123;                console.log(&quot;find ===&gt; &quot;, gname);                return string_class.$new(&quot;rmnet_data0&quot;)            &#125; else&#123;                console.log(&quot;gname ===&gt; &quot;, gname)            &#125;            return gname;        &#125;        // Java.use(&quot;android.net.ConnectivityManager&quot;).getNetworkCapabilities.implementation = function(v)&#123;        //     console.log(v)        //     var res = this.getNetworkCapabilities(v)        //     console.log(&quot;res ==&gt; &quot;, res)        //     return null;        // &#125;        Java.use(&quot;android.net.NetworkCapabilities&quot;).hasTransport.implementation = function(v)&#123;            console.log(v)            var res = this.hasTransport(v)            console.log(&quot;res ==&gt; &quot;, res)            return false;        &#125;    &#125;)&#125;setImmediate(main);","tags":["抓包"]},{"title":"谷歌Pixel3刷机以及magisk的安装","url":"/posts/36296/","content":"一、刷机1、首先找到对应自己手机的镜像版本，进行下载，https://developers.google.cn/android/images#blueline新建个文件夹shuaji，下载完解压到刷机里面2、下载刷机工具platform-tools.zip，https://developer.android.com/studio/releases/platform-tools?hl=zh-cn，根据操作系统下载，链接需要翻墙才能打开，我也把下载链接放出来，可以直接下载\n\n下载适用于 Windows 的 SDK Platform-Tools\n下载适用于 Mac 的 SDK Platform-Tools\n下载适用于 Linux 的 SDK Platform-Tools\n\n下载完，同样解压到shuaji目录下3、手机关机，关机后 长按住 关键键+音量减键（或者开机界面执行adb reboot bootloader），手机进入bootloader4、winfows运行shuaji目录下flash-all.bat，mac则需要运行flash-all.sh文件，整个过程会自动处理完成，伴随着重启几次。 过了几分钟后，到这里就刷机成功了5.修改手机配置（1）点击English，换成简体中文，然后点击开始，能跳过的则跳过。（2）点击设置，点击关于手机，多次点击版本号，开启开发者模式，在开发者模式开启USB调式。（3）在设置修改手机日期时间为当前日期时间（不弄可能没网）\n二、解锁root下载Magisk，https://github.com/topjohnwu/Magisk/tags，我这下载的是v24.0的1.usb连接电脑后，使用命令 adb install Magisk-v24.0.apk 进行安装。2.解压上面shuaji文件目录下的image-xxxx.zip，把boot.img 通过adb push到手机&#x2F;sdcard&#x2F;download&#x2F;命令：adb push boot.img &#x2F;sdcard&#x2F;download&#x2F;3.手机上如下操作magisk，生成 magisk_patched-24000_xxxxx.img 文件选择刚才上传的boot.img 然后点击开始，接着会在目录下生成带magisk的文件4.把生成的magisk_patched-24000_xxxxx.img 通过 adb pull 到电脑fastboot.exe所在的目录，也就是shuaji目录，命令如下 adb pull &#x2F;sdcard&#x2F;Download&#x2F;magisk_patched-24000_qJQvu.img .5. 执行 adb reboot bootloader 手机进入bootloader6. 执行命令 fastboot flash boot magisk_patched-24000_qJQvu.img 刷magisk fastboot reboot7. 手机点击电源键让手机正常启动，magisk安装成功，root完成\n","tags":["刷机"]},{"title":"某鱼直播软件使用unidbg算法分析","url":"/posts/57348/","content":"\nUnidbg 模拟执行 首先模拟执行，先搭个架子  \npackage com.douyu;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class DouYu extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final VM vm;    private final Module module;    public DouYu()&#123;        emulator = AndroidEmulatorBuilder.for32Bit().build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/demo/douyu/douyu.apk&quot;));        vm.setVerbose(true);        vm.setJni(this);        DalvikModule dm = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/demo/douyu/libmakeurl2.5.0.so&quot;), true);        module = dm.getModule();        dm.callJNI_OnLoad(emulator);    &#125;    public static void main(String[] args) &#123;        DouYu douYu = new DouYu();    &#125;&#125;\n运行结果 报了一个 ”不合法的JNI版本“ 错误，具体出错的原因有很多，一个常见的问题是SO的依赖库缺失。即程 序调用依赖库中某个函数时，因为这个依赖库没加载到Unidbg虚拟内存中，进而发生寻址错误，比如上 图就是 0x1664 地址访问失败。在Unidbg日志的第三行我们看到， libc++_shared.so 加载失败，即库缺失报错。 我们的目标SO依赖了 libc++_shared.so ，这个库是C++的支持库，但不在Unidbg默认支持的SO里。 我们要在apk的lib里把它拷贝出来。在加载so文件前添加这两行，目标so依赖的其他so文件要在其前面加载\nDalvikModule dm_shared = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/demo/douyu/libc++_shared.so&quot;), true);dm_shared.callJNI_OnLoad(emulator);\n再次运行就一切正常了下面就到了今天的主角——native_makeUrl函数，Unidbg中先call它，参数很长，构造的很随意，因为只是学习用途。  \npackage com.douyu;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ArrayObject;import com.github.unidbg.memory.Memory;import java.io.File;import java.util.ArrayList;import java.util.List;public class DouYu extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final VM vm;    private final Module module;    public DouYu()&#123;        emulator = AndroidEmulatorBuilder.for32Bit().build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/demo/douyu/douyu.apk&quot;));        vm.setVerbose(true);        vm.setJni(this);        DalvikModule dm_shared = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/demo/douyu/libc++_shared.so&quot;), true);        dm_shared.callJNI_OnLoad(emulator);        DalvikModule dm = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/demo/douyu/libmakeurl2.5.0.so&quot;), true);        module = dm.getModule();//        emulator.traceCode(module.base, module.base + module.size);        dm.callJNI_OnLoad(emulator);    &#125;    public String getMakeUrl() &#123;        // args list        List&lt;Object&gt; list = new ArrayList&lt;&gt;(10);        // arg1 env        list.add(vm.getJNIEnv());        // arg2 jobject/jclazz 一般用不到，直接填0        list.add(0);        DvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/content/Context&quot;).newObject(null);        list.add(vm.addLocalObject(context));        list.add(vm.addLocalObject(new StringObject(vm, &quot;&quot;)));        StringObject input3_1 = new StringObject(vm, &quot;aid&quot;);        StringObject input3_2 = new StringObject(vm, &quot;client_sys&quot;);        StringObject input3_3 = new StringObject(vm, &quot;time&quot;);        vm.addLocalObject(input3_1);        vm.addLocalObject(input3_2);        vm.addLocalObject(input3_3);        list.add(vm.addLocalObject(new ArrayObject(input3_1, input3_2, input3_3)));        StringObject input4_1 = new StringObject(vm, &quot;android1&quot;);        StringObject input4_2 = new StringObject(vm, &quot;android&quot;);        StringObject input4_3 = new StringObject(vm, &quot;1673232015&quot;);        vm.addLocalObject(input4_1);        vm.addLocalObject(input4_2);        vm.addLocalObject(input4_3);        list.add(vm.addLocalObject(new ArrayObject(input4_1, input4_2, input4_3)));        StringObject input5_1 = new StringObject(vm, &quot;&quot;);        StringObject input5_2 = new StringObject(vm, &quot;&quot;);        StringObject input5_3 = new StringObject(vm, &quot;&quot;);        StringObject input5_4 = new StringObject(vm, &quot;&quot;);        StringObject input5_5 = new StringObject(vm, &quot;&quot;);        StringObject input5_6 = new StringObject(vm, &quot;&quot;);        StringObject input5_7 = new StringObject(vm, &quot;&quot;);        StringObject input5_8 = new StringObject(vm, &quot;&quot;);        StringObject input5_9 = new StringObject(vm, &quot;&quot;);        StringObject input5_10 = new StringObject(vm, &quot;&quot;);        StringObject input5_11 = new StringObject(vm, &quot;&quot;);        StringObject input5_12 = new StringObject(vm, &quot;&quot;);        StringObject input5_13 = new StringObject(vm, &quot;&quot;);        vm.addLocalObject(input5_1);        vm.addLocalObject(input5_2);        vm.addLocalObject(input5_3);        vm.addLocalObject(input5_4);        vm.addLocalObject(input5_5);        vm.addLocalObject(input5_6);        vm.addLocalObject(input5_7);        vm.addLocalObject(input5_8);        vm.addLocalObject(input5_9);        vm.addLocalObject(input5_10);        vm.addLocalObject(input5_11);        vm.addLocalObject(input5_12);        vm.addLocalObject(input5_13);        list.add(vm.addLocalObject(new ArrayObject(input5_1, input5_2, input5_3,input5_4, input5_5, input5_6,input5_7, input5_8, input5_9,input5_10, input5_11, input5_12,input5_13)));        StringObject input6_1 = new StringObject(vm, &quot;&quot;);        StringObject input6_2 = new StringObject(vm, &quot;&quot;);        StringObject input6_3 = new StringObject(vm, &quot;&quot;);        StringObject input6_4 = new StringObject(vm, &quot;&quot;);        StringObject input6_5 = new StringObject(vm, &quot;&quot;);        StringObject input6_6 = new StringObject(vm, &quot;&quot;);        StringObject input6_7 = new StringObject(vm, &quot;&quot;);        StringObject input6_8 = new StringObject(vm, &quot;&quot;);        StringObject input6_9 = new StringObject(vm, &quot;&quot;);        StringObject input6_10 = new StringObject(vm, &quot;&quot;);        vm.addLocalObject(input6_1);        vm.addLocalObject(input6_2);        vm.addLocalObject(input6_3);        vm.addLocalObject(input6_4);        vm.addLocalObject(input6_5);        vm.addLocalObject(input6_6);        vm.addLocalObject(input6_7);        vm.addLocalObject(input6_8);        vm.addLocalObject(input6_9);        vm.addLocalObject(input6_10);        list.add(vm.addLocalObject(new ArrayObject(input6_1, input6_2, input6_3,input6_4, input6_5, input6_6,input6_7, input6_8, input6_9,input6_10)));        list.add(0);        list.add(1);        // 参数准备完成        // call function        Number number = module.callFunction(emulator, 0x2f91, list.toArray());        return vm.getObject(number.intValue()).getValue().toString();    &#125;    public static void main(String[] args) &#123;        DouYu douYu = new DouYu();        String makeUrl = douYu.getMakeUrl();        System.out.println(&quot;result:&quot;+ makeUrl);    &#125;&#125;\n 运行后直接出结果   可以发现，结果由四部分组成，前三个参数是我们 input4 传进去的内容，所以需要分析的只有auth的 来源。 多次运行会发现，auth 的值，恒为 3c179e17e8e9b06d7b18c68555b92220，长度 32 位。  \n算法分析 首先，确认函数执行流的汇编长度，如果行数过多上千万甚至上亿行，就只能放弃。如果几十万行，那就还可以看看。\npublic void traceLength() &#123;    emulator.getBackend().hook_add_new(new CodeHook() &#123;        int count = 0;        @Override        public void hook(Backend backend, long address, int size, Object user) &#123;            count += 1;            System.out.println(count);        &#125;        @Override        public void onAttach(UnHook unHook) &#123;        &#125;        @Override        public void detach() &#123;        &#125;    &#125;, module.base, module.size + module.base, null);&#125;\n运行计数总共九十一万行， 不超过100w行的执行流，要么程序没怎么混淆，要么逻辑不 太复杂。两者任意一个复杂度高一些，都不会只有100w行汇编以内。  使用findcrypt插件再确认一下样本大概使用了哪些加密算法 SO中至少存在 AES&#x2F;BASE64，至于我们的函数中用了什么？这得具体分析，毕竟Findcrypt只是一个静态 的、加密特征匹配插件。 \n\n目标函数可能用了AES&#x2F;Base64，说“可能”是上述算法可能用于SO中其他函数而非目标函数。 \n目标函数可能用了AES和Base64之外的其他加密算法，因为FIndCrypt提供了静态的、有限的分析，很容易遗漏。\n\n使用Unidbg处理算法，一般而言，自下而上分析更省时省力，这得益于Unidbg两方面的能力 \n\n强大方便的内存读写监控 \n无地址随机化\n\n这让我们可以逆流而上，自结果推来源，分析算法和数据块十分轻松。 重新看运行结果图运算结果来自于NewStringUTF，这个JString从哪里来的？     日志提示调用处在0x336f，这个地址实际上是LR（返回地址），所以NewStringUTF函数调用是 0x336f 的上一条 0x336C。   在 0x336C 下断点   回顾一下NewStringUTF 这个JNI方法，数据来源就是参数二字符数组  \njstring NewStringUTF(JNIEnv *env, const char *bytes);\n 数据从地址0x402d20a0开始，我们要监控auth&#x3D;后面的数据，即从0x402d20a0+len(aid&#x3D;android1&amp;client_sys&#x3D;android&amp;time&#x3D;1638452332&amp;auth&#x3D;)开始，数一下auth的32个字节所处的地址，监控对它的写入。  \nemulator.traceWrite(0x401D20D5, 0x401D20D5+0x20);\n 从下往上寻找对内存最晚的操作，可以发现，这32个字节的赋值发生在libc里。一般数据在libc里赋值， 指的是调用了libc中memcpy等库函数做拷贝、转换、比较等处理，而非数据生成的第一现场。   把Unidbg的libc.so拷贝一份出来，扔到IDA里。搜索0x17d3a，看具体是哪个函数。我们发现 是在strcat函数里，即做字符串拼接。  hook strcat 函数，进行追踪  \nchar *strcat(char *dest, const char *src)\n\n\ndest – 指向目标数组，该数组包含了一个 C 字符串，且足够容纳追加后的字符串。 \nsrc – 指向要追加的字符串，该字符串不会覆盖目标字符串。\n\npublic void hookStrCat()&#123;    emulator.attach().addBreakPoint(module.findSymbolByName(&quot;strcat&quot;,            true).getAddress(), new BreakPointCallback() &#123;        @Override        public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;            UnidbgPointer r1 = emulator.getContext().getPointerArg(1);            System.out.println(&quot;strcat:&quot;+ r1);            System.out.println(r1.getString(0));            return true;        &#125;    &#125;);&#125;\n 运行，可以发现结果的四个字段就是strcat 逐步拼接的结果     对来源 0xbffff69b 做traceWrite，千万记得加后缀L。   发现依然来自于libc，这不是好事，说明我们还没到第一现场。    从IDA跳到地址 0x176dc，看到是在_memcpy_base函数里\nvoid __fastcall _memcpy_base(int a1, char *a2, unsigned int a3, int a4, int a5,int a6)\n 它应该是memcpy函数内部的子函数，我们Hook一下memcpy，其原型如下  \nvoid *memcpy(void *str1, const void *str2, size_t n)\n\n\nstr1 – 指向用于存储复制内容的目标数组，类型强制转换为 void* 指针。 \nstr2 – 指向要复制的数据源，类型强制转换为 void* 指针。 \nn – 要被复制的字节数。\n\n 我们打印str2，长度为n  \npublic void hookMemcpy()&#123;    emulator.attach().addBreakPoint(module.findSymbolByName(&quot;memcpy&quot;,            true).getAddress(), new BreakPointCallback() &#123;        @Override        public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;            UnidbgPointer r1 = emulator.getContext().getPointerArg(1);            int length = emulator.getContext().getIntArg(2);            System.out.println(&quot;memcpy&quot;);            Inspector.inspect(r1.getByteArray(0, length), r1.toString());            return true;        &#125;    &#125;);&#125;\n 运行发现，程序逻辑上逐两个字节进行拷贝    140处调用。看的头疼，所以我尝试性的搜索了下3c179e17e8e9b06d7b18c68555b92220，期待某次 memcpy可以看到它，那么我们就能找到它的产生之处了。     打印memcpy的str2时，我采用了Unidbg的Inspect API，它会在 打印内存块时，顺带打印数据的MD5值，这个设计主要是为了比较两个内存块是否全然等值，但这里却 帮到了我们。  \n0000: 61 69 64 3D 61 6E 64 72 6F 69 64 31 26 63 6C 69    aid=android1&amp;cli0010: 65 6E 74 5F 73 79 73 3D 61 6E 64 72 6F 69 64 26    ent_sys=android&amp;0020: 74 69 6D 65 3D 31 36 37 33 32 33 32 30 31 35 76    time=1673232015v0030: 71 34 37 48 64 39 4A 55 67 66 44 43 79 74 43       q47Hd9JUgfDCytC\nvq47Hd9JUgfDCytC 这十个字节是未知的，其余三个字段是传进来的，我们结合上面的MD5会产生一种 明悟，这不就是加盐MD5吗？传进来的参数拼接后加上”vq47Hd9JUgfDCytC“，MD5后传出去。 那么现在问题就变成了，vq47Hd9JUgfDCytC是哪里来的？   对0xbffff500L 做traceWrite  \n ida打开libmakeurl.so，看一下来源0x8a88，十六个字节都来自这里  \n 前面我们用过Findcrypt，有看到RijnDael_AES_LONG_inv_45FC4，它自动将0x8a9e所位于的函数中，一个数组标记为AES的S逆盒。这告诉我们，十六字节的生成处是AES的运算逻辑。换而言之，这十六字节大概率是AES加密或解密的输出。  可是，样本使用了Ollvm，比如0x8a9e这一行，就是Ollvm中的指令替换。 我们先不要陷入函数的细节里，因为如果是标准AES，那根本不用 分析加密程序的内部，自然也就不用考虑这些混淆了。   0x8a88 位于 sub_8228 函数内，Hook sub_8228，顺利断下   观察两个参数  \nint __fastcall sub_8228(unsigned __int64 a1, _QWORD *a2)\n 参数2像是buffer，存放加密结果。blr用于在函数返回处下断点，然后c继续跑，在函数运行结束后再次 查看参数2指向的内存。  \n可以发现确实是我们要分析的十六个字节。至于参数1是什么意思，硬看似乎看不出来。 因此可以判断，sub_8228生成了我们要分析的十六个字节，而且它像AES的执行逻辑。 AES 加密还是解密？什么工作模式？明文是什么？Key是什么？一概不知。我们得到sub_8228上层去看看。 重新运行程序，bt 打印调用栈  跳到 0x08ba7 看一下\nint __fastcall sub_8B3C(const char *a1, int a2, int a3)&#123;  signed int i; // r0  int v7; // r1  int v8; // r1  signed int v10; // [sp+4h] [bp-144h]  signed int v11; // [sp+Ch] [bp-13Ch]  char v12[280]; // [sp+10h] [bp-138h] BYREF  int v13; // [sp+128h] [bp-20h]  v10 = (strlen(a1) + 15) &gt;&gt; 4;  sub_72BC(v12, a2, 128);  for ( i = 0; ; i = v11 + 1 )  &#123;    v7 = 1590846758;    while ( 1 )    &#123;      v8 = v7 &amp; 0x7FFFFFFF;      if ( v8 != 1590846758 )        break;      v11 = i;      v7 = 131555431;      if ( i &lt; v10 )        v7 = 1574041125;    &#125;    if ( v8 == 131555431 )      break;    if ( v8 != 1574041125 )    &#123;      while ( 1 )        ;    &#125;    sub_8228(v12, a3 + 16 * v11, &amp;a1[16 * v11]);  &#125;  return _stack_chk_guard - v13;&#125;\n 首先我们知道，sub_8228是AES的具体运算程序，刚才Hook确认了这一点。而密钥编排一般发生在具 体运算前面，即早于sub_8228。整个函数体内，就只有sub_72BC 一个函数了，那也可能在sub_8B3C外层。更重要的线索是它的参数3，128。AES 存在128&#x2F;192&#x2F;256 三种密钥的规格，这里就是在指定AES的规格，并生成对应的轮密钥。 char v12[280]; v12是一个较大的数组，用于存放生成轮密钥的结果。那么可以大胆猜测sub_8B3C的a2就是十六字节长的AES-128密钥。进而参数1就是 十六字节的输入。  对 sub_8B3C 进行断点查看参数  密钥是30292827262524232221000000000000，暂时不知道是加密还是解密，结果是 767134374864394a5567664443797443（vq47Hd9JUgfDCytC）看看加密过程对的上吗 因为aes会对明文进行填充，它会自动按照PKCS7约定，再次填充一个分组的长度，输出也是两个分组的结果。  这里结果a7488462036f15054005472d6f487c67才是对的，后面是填充后的分组加密而来的可以不用管跟我们上面的 sub_8B3C 的参数一是一致的，说明 vq47Hd9JUgfDCytC 是由明文a7488462036f15054005472d6f487c67，密钥30292827262524232221000000000000解密而来的\n我们这里做一个讨论，如何从一个小的线索点，分析出AES的全貌。以 sub_72BC(v12, a2, 128); 为例，我们猜测它是密钥编排函数，那么如何快速验证呢？ 我Hook 入参时a2指向的十六字节，以及函数结束后v13指向的176字节（因为是AES-128，所以轮密钥 是4*44）。  \npublic void hook72bc()&#123;    emulator.attach().addBreakPoint(module.base + 0x72bc, new BreakPointCallback() &#123;        UnidbgPointer v12;        @Override        public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;            RegisterContext registerContext = emulator.getContext();            UnidbgPointer a2 = registerContext.getPointerArg(1);            v12 = registerContext.getPointerArg(0);            Inspector.inspect(a2.getByteArray(0, 0x10), &quot;key &quot; + a2.toString());            // 函数结束对v12hook查看            emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() &#123;                @Override                public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                    Inspector.inspect(v12.getByteArray(0, 176), &quot;Round Key &quot;+v12.toString());                    return false;                &#125;            &#125;);            return true;        &#125;    &#125;);&#125;\n&gt;-----------------------------------------------------------------------------&lt;[17:01:35 327]key unidbg@0xbffff3d8, md5=037ff8eefc91404afaed9fa22e282e3f, hex=30292827262524232221000000000000size: 160000: 30 29 28 27 26 25 24 23 22 21 00 00 00 00 00 00    0)(&#x27;&amp;%$#&quot;!......^-----------------------------------------------------------------------------^&gt;-----------------------------------------------------------------------------&lt;[17:01:35 336]Round Key unidbg@0xbffff290, md5=159aaceb29acbcbd8d87b091ce103546, hex=0a00000098f2ffbf30292827262524232221000000000000524a4b44746f6f67564e6f67564e6f677fe2cef50b8da1925dc3cef50b8da19226d081de2d5d204c709eeeb97b134f2b535470ff7e0950b30e97be0a7584f1211cf58d6262fcddd16c6b63db19ef92fae3baa0b681467d67ed2d1ebcf4c28c4686defa090798876eeab599d21e771594f387d87bf41f5f151eaac6c700ddd35329e13518ddfe6a0dc354accac3897f99b833db3665cdb13bsize: 1760000: 0A 00 00 00 98 F2 FF BF 30 29 28 27 26 25 24 23    ........0)(&#x27;&amp;%$#0010: 22 21 00 00 00 00 00 00 52 4A 4B 44 74 6F 6F 67    &quot;!......RJKDtoog0020: 56 4E 6F 67 56 4E 6F 67 7F E2 CE F5 0B 8D A1 92    VNogVNog........0030: 5D C3 CE F5 0B 8D A1 92 26 D0 81 DE 2D 5D 20 4C    ].......&amp;...-] L0040: 70 9E EE B9 7B 13 4F 2B 53 54 70 FF 7E 09 50 B3    p...&#123;.O+STp.~.P.0050: 0E 97 BE 0A 75 84 F1 21 1C F5 8D 62 62 FC DD D1    ....u..!...bb...0060: 6C 6B 63 DB 19 EF 92 FA E3 BA A0 B6 81 46 7D 67    lkc..........F&#125;g0070: ED 2D 1E BC F4 C2 8C 46 86 DE FA 09 07 98 87 6E    .-.....F.......n0080: EA B5 99 D2 1E 77 15 94 F3 87 D8 7B F4 1F 5F 15    .....w.....&#123;.._.0090: 1E AA C6 C7 00 DD D3 53 29 E1 35 18 DD FE 6A 0D    .......S).5...j.00A0: C3 54 AC CA C3 89 7F 99 B8 33 DB 36 65 CD B1 3B    .T.......3.6e..;^-----------------------------------------------------------------------------^\n\n RoundKey 的结果像是一个结构体，两个int组成，第一个是0x0000000a，即代表了AES-128的十轮运 算，第二个是指针，值为0xbffff298，是v12往后偏移八个字节。   我们不妨修改一下hook72bc，看一下0xbffff298具体打印什么  \npublic void hook72bc()&#123;    emulator.attach().addBreakPoint(module.base + 0x72bc, new BreakPointCallback() &#123;        UnidbgPointer v12;        @Override        public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;            RegisterContext registerContext = emulator.getContext();            UnidbgPointer a2 = registerContext.getPointerArg(1);            v12 = registerContext.getPointerArg(0);            Inspector.inspect(a2.getByteArray(0, 0x10), &quot;key &quot; + a2.toString());            // 函数结束对v12hook查看            emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() &#123;                @Override                public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                    //Inspector.inspect(v12.getByteArray(0, 176), &quot;Round Key &quot;+v12.toString());                    Inspector.inspect(v12.getByteArray(8, 176), &quot;Round Key &quot;+v12.toString());                    return true;                &#125;            &#125;);            return true;        &#125;    &#125;);&#125;\n 结果如下  \n[17:20:19 949]key unidbg@0xbffff3d8, md5=037ff8eefc91404afaed9fa22e282e3f, hex=30292827262524232221000000000000size: 160000: 30 29 28 27 26 25 24 23 22 21 00 00 00 00 00 00    0)(&#x27;&amp;%$#&quot;!......^-----------------------------------------------------------------------------^&gt;-----------------------------------------------------------------------------&lt;[17:20:19 957]Round Key unidbg@0xbffff290, md5=1a32868f8f948e426e209b5995588178, hex=30292827262524232221000000000000524a4b44746f6f67564e6f67564e6f677fe2cef50b8da1925dc3cef50b8da19226d081de2d5d204c709eeeb97b134f2b535470ff7e0950b30e97be0a7584f1211cf58d6262fcddd16c6b63db19ef92fae3baa0b681467d67ed2d1ebcf4c28c4686defa090798876eeab599d21e771594f387d87bf41f5f151eaac6c700ddd35329e13518ddfe6a0dc354accac3897f99b833db3665cdb13ba6991df165106268size: 1760000: 30 29 28 27 26 25 24 23 22 21 00 00 00 00 00 00    0)(&#x27;&amp;%$#&quot;!......0010: 52 4A 4B 44 74 6F 6F 67 56 4E 6F 67 56 4E 6F 67    RJKDtoogVNogVNog0020: 7F E2 CE F5 0B 8D A1 92 5D C3 CE F5 0B 8D A1 92    ........].......0030: 26 D0 81 DE 2D 5D 20 4C 70 9E EE B9 7B 13 4F 2B    &amp;...-] Lp...&#123;.O+0040: 53 54 70 FF 7E 09 50 B3 0E 97 BE 0A 75 84 F1 21    STp.~.P.....u..!0050: 1C F5 8D 62 62 FC DD D1 6C 6B 63 DB 19 EF 92 FA    ...bb...lkc.....0060: E3 BA A0 B6 81 46 7D 67 ED 2D 1E BC F4 C2 8C 46    .....F&#125;g.-.....F0070: 86 DE FA 09 07 98 87 6E EA B5 99 D2 1E 77 15 94    .......n.....w..0080: F3 87 D8 7B F4 1F 5F 15 1E AA C6 C7 00 DD D3 53    ...&#123;.._........S0090: 29 E1 35 18 DD FE 6A 0D C3 54 AC CA C3 89 7F 99    ).5...j..T......00A0: B8 33 DB 36 65 CD B1 3B A6 99 1D F1 65 10 62 68    .3.6e..;....e.bh^-----------------------------------------------------------------------------^\n\n 首先我们就可以确定，这就是密钥编排的结果，这是我们根据AES-128的编排性质推断出来的。 \n\n轮密钥的前十六个字节就是主密钥，完全符合 \n十六个字节后面的编排规则，以行为单位看的话，前四个字节较为复杂，后十二字节只是简单异 或。如下验证\n\n密钥 30 29 28 27 26 25 24 23 22 21 00 00 00 00 00 00按照密钥的编排 4个字节一组W0 30 29 28 27W1 26 25 24 23W2 22 21 00 00W3 00 00 00 00根据结果我们也可以看出W4 &#x3D; 52 4A 4B 44W5 &#x3D; 74 6F 6F 67验证可以得到 W4 xor W1 &#x3D; W5\nC:\\Users\\zsk&gt;pythonPython 3.8.10 (tags/v3.8.10:3d8993a, May  3 2021, 11:48:03) [MSC v.1928 64 bit (AMD64)] on win32Type &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; hex(0x524A4B44^0x26252423)&#x27;0x746f6f67&#x27;\n 确实符合编排的规律。  因此可以认定 72bc 就是密钥编排函数，并确定了密钥。怎么仅从这个线索，推出输入呢？\n\n如果是加密，那么对K0做traceRead可以定位到算法的输入，对K10做traceRead，其运算结果就是算法 的输出。\n如果是解密，那么对K0做traceRead可以定位算法的输出，对K10做traceRead，其运算结果就是算法的 输入。\n\n换个情况，如果只知道算法的输入，该怎么确认密钥呢？\n\n如果是加密，那么对算法的输入做traceRead，可以定位到K0，在AES-128上意味着主密钥；\n如果是CBC 模式，那么定位到IV。 如果是解密，那么对算法的输入做traceRead，可以定位到K10，使用stark 逆推主密钥。\n\n再换个情况，如果只知道算法的输出，该怎么确认其他要素？\n\n如果是加密过程，对算法的输出做traceWrite，运算的双方中有一方是K10。 \n如果是解密过程，对算法的输出做traceWrite，运算的双方中有一方是K0。\n\n下面考虑Key和密文哪里来的 在sub_8B3C打断点，查看堆栈，发现都位于 sub_A298  \nint __fastcall sub_A298(void *a1)&#123;    int v1; // r9    int v3; // r11    int i; // r0    int v6; // [sp+0h] [bp-78h]    int v7; // [sp+4h] [bp-74h]    _QWORD v8[2]; // [sp+8h] [bp-70h] BYREF    char v9[20]; // [sp+18h] [bp-60h] BYREF    _QWORD v10[2]; // [sp+30h] [bp-48h] BYREF    char v11[20]; // [sp+40h] [bp-38h] BYREF    int v12; // [sp+58h] [bp-20h]    v3 = 0;    v10[0] = unk_45688;    v10[1] = unk_45690;    strcpy(v11, &quot;                &quot;);    v8[0] = unk_45CF0;    v8[1] = unk_45CF8;    strcpy(v9, &quot;                &quot;);    memset(a1, 0, 0x100u);    for ( i = 1282341844; ; i = 1282341844 )        &#123;            while ( i != 967467364 )                &#123;                    if ( i == 1282341844 )                    &#123;                        v6 = v3;                        i = 1618205161;                        if ( v3 &lt; 32 )                            i = -1314423687;                        if ( i &lt;= 967467363 )                            goto LABEL_15;                    &#125;                    else                    &#123;                        v1 = 0;                        LABEL_14:                        i = 967467364;                    &#125;                &#125;            v7 = v1;            i = -688078044;            if ( v1 &lt; 32 )                i = -1194610101;            LABEL_15:            if ( i != -1314423687 )                break;            *((_BYTE *)v8 + v6) = (*((_BYTE *)v8 + v6) &amp; 0x8E | ~*((_BYTE *)v8 + v6) &amp; 0x71) ^ 0x51;            v3 = v6 + 1;        &#125;    if ( i == -1194610101 )    &#123;        *((_BYTE *)v10 + v7) = (~*((_BYTE *)v10 + v7) &amp; 0xE9 | *((_BYTE *)v10 + v7) &amp; 0x16) ^ 0xC9;        v1 = v7 + 1;        goto LABEL_14;    &#125;    sub_8B3C((const char *)v10, (int)v8, (int)a1);    return _stack_chk_guard - v12;&#125;\n\n 其中v10 ， 前八个字节来自0x45688，后八个字节来自0x45690。因为这两个八字节是紧连着的，所以可 以一并看。  \n.rodata:00045688 87                            unk_45688 DCB 0x87                      ; DATA XREF: sub_A298+E↑o.rodata:00045688                                                                       ; sub_A298+18↑o.rodata:00045688                                                                       ; .text:off_A424↑o.rodata:00045689 68                            DCB 0x68 ; h.rodata:0004568A A4                            DCB 0xA4.rodata:0004568B 42                            DCB 0x42 ; B.rodata:0004568C 23                            DCB 0x23 ; #.rodata:0004568D 4F                            DCB 0x4F ; O.rodata:0004568E 35                            DCB 0x35 ; 5.rodata:0004568F 25                            DCB 0x25 ; %.rodata:00045690 60                            unk_45690 DCB 0x60 ; `.rodata:00045691 25                            DCB 0x25 ; %.rodata:00045692 67                            DCB 0x67 ; g.rodata:00045693 0D                            DCB  0xD.rodata:00045694 4F                            DCB 0x4F ; O.rodata:00045695 68                            DCB 0x68 ; h.rodata:00045696 5C                            DCB 0x5C ; \\.rodata:00045697 47                            DCB 0x47 ; G\n\n 在逐字节经过如下处理后成为我们的密文  \n*((_BYTE *)v10 + v7) = (~*((_BYTE *)v10 + v7) &amp; 0xE9 | *((_BYTE *)v10 + v7) &amp; 0x16) ^ 0xC9;\n 而密钥也一样，前八个字节来自0x45CF0，后八个字节来自0x45CF8。\n.rodata:00045CF0 10                            unk_45CF0 DCB 0x10                      ; DATA XREF: sub_A298+24↑o.rodata:00045CF0                                                                       ; sub_A298+2C↑o.rodata:00045CF0                                                                       ; .text:off_A428↑o.rodata:00045CF0                                                                       ; sub_A430+50↑o.rodata:00045CF0                                                                       ; sub_A430+5E↑o.rodata:00045CF0                                                                       ; .text:off_A5D0↑o.rodata:00045CF0                                                                       ; sub_A5D8+4E↑o.rodata:00045CF0                                                                       ; sub_A5D8+5C↑o.rodata:00045CF0                                                                       ; .text:off_A770↑o.rodata:00045CF0                                                                       ; sub_A778+4E↑o.rodata:00045CF0                                                                       ; sub_A778+5C↑o.rodata:00045CF0                                                                       ; .text:off_A910↑o.rodata:00045CF0                                                                       ; sub_A918+50↑o.rodata:00045CF0                                                                       ; sub_A918+5E↑o.rodata:00045CF0                                                                       ; .text:off_AAA4↑o ....rodata:00045CF1 09                            DCB    9.rodata:00045CF2 08                            DCB    8.rodata:00045CF3 07                            DCB    7.rodata:00045CF4 06                            DCB    6.rodata:00045CF5 05                            DCB    5.rodata:00045CF6 04                            DCB    4.rodata:00045CF7 03                            DCB    3.rodata:00045CF8 02                            unk_45CF8 DCB    2.rodata:00045CF9 01                            DCB    1.rodata:00045CFA 20                            DCB 0x20.rodata:00045CFB 20                            DCB 0x20.rodata:00045CFC 20                            DCB 0x20.rodata:00045CFD 20                            DCB 0x20.rodata:00045CFE 20                            DCB 0x20.rodata:00045CFF 20                            DCB 0x20\n 它经过了如下逐字节的处理  \n*((_BYTE *)v8 + v6) = (*((_BYTE *)v8 + v6) &amp; 0x8E | ~*((_BYTE *)v8 + v6) &amp; 0x71) ^ 0x51;\n 看起来有些云里雾里的，这是Ollvm中指令替换的功劳。   真正功能上而言，只是SO中硬编码的两串十六进制字节，在异或0x20后，就成为了密文和Key，在运行 时AES解密出明文，作为MD5的盐。   我们以Key为例，它的完整流程如下（下面均为十六进制字节）   首先，Key是 30 29 28 27 26 25 24 23 22 21 00 00 00 00 00 00，开发者不希望硬编码在SO里，所以先 将它异或0x20，在SO中硬编码即 10 09 08 07 06 05 04 03 02 01 20 20 20 20 20 20。   然后在使用时，将这么一串异或0x20，因为异或两次等于自身，所以Key重新变成30 29 28 27 26 25 24 23 22 21 00 00 00 00 00 00，正常参与运算。  \n 那么下面这两种运算，其功能都等价于单字节异或0x20，怎么变成这个样子了呢？  \n*((_BYTE *)v10 + v7) = (~*((_BYTE *)v10 + v7) &amp; 0xE9 | *((_BYTE *)v10 + v7) &amp; 0x16) ^ 0xC9;*((_BYTE *)v8 + v6) = (*((_BYTE *)v8 + v6) &amp; 0x8E | ~*((_BYTE *)v8 + v6) &amp; 0x71) ^ 0x51;\n 这就是指令替换的目的，将简单的加减乘除、异或、与等运算，替换成等价但更复杂的指令序列。  演示一下这个过程 S &#x3D; A ^ B 异或0不影响结果 S &#x3D; A ^ B ^ 0 0可以展开成C ^ C S &#x3D; A ^ B ^ C ^ C 做一下简单的分配 S &#x3D; (A^C)^(B^C) 两数异或时可以等价替换如下，可以自行验证。   \na ^ b =&gt; (~a &amp; b) | (a &amp; ~b) \n那么\nS = (~A &amp; C) | (A &amp; ~C) ^ (~B &amp; C) | (B &amp; ~C)\n  \n 回到 S = A ^ B，假设A 就是我们的待处理数据，B是0x20，即将数据和0x20异或，我们再选择C为0xE9 \n \nS = (~A &amp; 0xE9) | (A &amp; ~0xE9) ^ (~0x20 &amp; 0xE9) | (0x20 &amp; ~0xE9)\n  0xE9 在取反后即 0x16，而异或的另外一方，因为不存在未知数，编译器会直接优化计算出结果  \n \nS = (~A &amp; 0xE9) | (A &amp; 0xE9) ^ 0xC9\n   A 代入 *((_BYTE *)v10 + v7) 不就是 \n*((_BYTE *)v10 + v7) = (~*((_BYTE *)v10 + v7) &amp; 0xE9) | (*((_BYTE *)v10 + v7) &amp; 0xE9) ^ 0xC9\nA 代入 *((_BYTE *)v8 + v6) ，C 为0x71时，就是 另一个式子。 本质上，两者都是逐字节与0x20异或。  \n完整代码package com.douyu;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Emulator;import com.github.unidbg.Module;import com.github.unidbg.arm.backend.Backend;import com.github.unidbg.arm.backend.CodeHook;import com.github.unidbg.arm.backend.UnHook;import com.github.unidbg.arm.context.RegisterContext;import com.github.unidbg.debugger.BreakPointCallback;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.*;import com.github.unidbg.linux.android.dvm.array.ArrayObject;import com.github.unidbg.memory.Memory;import com.github.unidbg.pointer.UnidbgPointer;import com.github.unidbg.utils.Inspector;import java.io.File;import java.util.ArrayList;import java.util.List;public class DouYu extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final VM vm;    private final Module module;    public DouYu()&#123;        emulator = AndroidEmulatorBuilder.for32Bit().build();        Memory memory = emulator.getMemory();        memory.setLibraryResolver(new AndroidResolver(23));        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/demo/douyu/douyu.apk&quot;));        vm.setVerbose(true);        vm.setJni(this);        DalvikModule dm_shared = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/demo/douyu/libc++_shared.so&quot;), true);        dm_shared.callJNI_OnLoad(emulator);        DalvikModule dm = vm.loadLibrary(new File(&quot;unidbg-android/src/test/resources/demo/douyu/libmakeurl2.5.0.so&quot;), true);        module = dm.getModule();        dm.callJNI_OnLoad(emulator);        // NewStringUTF断点        //emulator.attach().addBreakPoint(module.base + 0x336c);        // 监控地址写入, auth的32个字节所处的地址， 401d20a0 + len(aid=android1&amp;client_sys=android&amp;time=1638452332&amp;auth=)        //emulator.traceWrite(0x401D20D5, 0x401D20D5+0x20);        // 监控strcat函数，看结果是在哪里写入的        //emulator.traceWrite(0xbffff69bL, 0xbffff69bL+0x20);        // 对 vq47Hd9JUgfDCytC 做traceWrite        //emulator.traceWrite(0xbffff500L, 0xbffff69bL+0x20);        // 对 vq47Hd9JUgfDCytC 出现的位置函数 sub_8228(unsigned __int64 a1, _QWORD *a2) 进行断点        //emulator.attach().addBreakPoint(module.base + 0x8228);        // 对调用生成 vq47Hd9JUgfDCytC 函数的上一级断点        emulator.attach().addBreakPoint(module.base + 0x8B3C);    &#125;    public String getMakeUrl() &#123;        // args list        List&lt;Object&gt; list = new ArrayList&lt;&gt;(10);        // arg1 env        list.add(vm.getJNIEnv());        // arg2 jobject/jclazz 一般用不到，直接填0        list.add(0);        DvmObject&lt;?&gt; context = vm.resolveClass(&quot;android/content/Context&quot;).newObject(null);        list.add(vm.addLocalObject(context));        list.add(vm.addLocalObject(new StringObject(vm, &quot;&quot;)));        StringObject input3_1 = new StringObject(vm, &quot;aid&quot;);        StringObject input3_2 = new StringObject(vm, &quot;client_sys&quot;);        StringObject input3_3 = new StringObject(vm, &quot;time&quot;);        vm.addLocalObject(input3_1);        vm.addLocalObject(input3_2);        vm.addLocalObject(input3_3);        list.add(vm.addLocalObject(new ArrayObject(input3_1, input3_2, input3_3)));        StringObject input4_1 = new StringObject(vm, &quot;android1&quot;);        StringObject input4_2 = new StringObject(vm, &quot;android&quot;);        StringObject input4_3 = new StringObject(vm, &quot;1673232015&quot;);        vm.addLocalObject(input4_1);        vm.addLocalObject(input4_2);        vm.addLocalObject(input4_3);        list.add(vm.addLocalObject(new ArrayObject(input4_1, input4_2, input4_3)));        StringObject input5_1 = new StringObject(vm, &quot;&quot;);        StringObject input5_2 = new StringObject(vm, &quot;&quot;);        StringObject input5_3 = new StringObject(vm, &quot;&quot;);        StringObject input5_4 = new StringObject(vm, &quot;&quot;);        StringObject input5_5 = new StringObject(vm, &quot;&quot;);        StringObject input5_6 = new StringObject(vm, &quot;&quot;);        StringObject input5_7 = new StringObject(vm, &quot;&quot;);        StringObject input5_8 = new StringObject(vm, &quot;&quot;);        StringObject input5_9 = new StringObject(vm, &quot;&quot;);        StringObject input5_10 = new StringObject(vm, &quot;&quot;);        StringObject input5_11 = new StringObject(vm, &quot;&quot;);        StringObject input5_12 = new StringObject(vm, &quot;&quot;);        StringObject input5_13 = new StringObject(vm, &quot;&quot;);        vm.addLocalObject(input5_1);        vm.addLocalObject(input5_2);        vm.addLocalObject(input5_3);        vm.addLocalObject(input5_4);        vm.addLocalObject(input5_5);        vm.addLocalObject(input5_6);        vm.addLocalObject(input5_7);        vm.addLocalObject(input5_8);        vm.addLocalObject(input5_9);        vm.addLocalObject(input5_10);        vm.addLocalObject(input5_11);        vm.addLocalObject(input5_12);        vm.addLocalObject(input5_13);        list.add(vm.addLocalObject(new ArrayObject(input5_1, input5_2, input5_3,input5_4, input5_5, input5_6,input5_7, input5_8, input5_9,input5_10, input5_11, input5_12,input5_13)));        StringObject input6_1 = new StringObject(vm, &quot;&quot;);        StringObject input6_2 = new StringObject(vm, &quot;&quot;);        StringObject input6_3 = new StringObject(vm, &quot;&quot;);        StringObject input6_4 = new StringObject(vm, &quot;&quot;);        StringObject input6_5 = new StringObject(vm, &quot;&quot;);        StringObject input6_6 = new StringObject(vm, &quot;&quot;);        StringObject input6_7 = new StringObject(vm, &quot;&quot;);        StringObject input6_8 = new StringObject(vm, &quot;&quot;);        StringObject input6_9 = new StringObject(vm, &quot;&quot;);        StringObject input6_10 = new StringObject(vm, &quot;&quot;);        vm.addLocalObject(input6_1);        vm.addLocalObject(input6_2);        vm.addLocalObject(input6_3);        vm.addLocalObject(input6_4);        vm.addLocalObject(input6_5);        vm.addLocalObject(input6_6);        vm.addLocalObject(input6_7);        vm.addLocalObject(input6_8);        vm.addLocalObject(input6_9);        vm.addLocalObject(input6_10);        list.add(vm.addLocalObject(new ArrayObject(input6_1, input6_2, input6_3,input6_4, input6_5, input6_6,input6_7, input6_8, input6_9,input6_10)));        list.add(0);        list.add(1);        // 参数准备完成        // call function        Number number = module.callFunction(emulator, 0x2f91, list.toArray());        return vm.getObject(number.intValue()).getValue().toString();    &#125;    public void traceLength() &#123;        emulator.getBackend().hook_add_new(new CodeHook() &#123;            int count = 0;            @Override            public void hook(Backend backend, long address, int size, Object user) &#123;                count += 1;                System.out.println(count);            &#125;            @Override            public void onAttach(UnHook unHook) &#123;            &#125;            @Override            public void detach() &#123;            &#125;        &#125;, module.base, module.size + module.base, null);    &#125;    public void hookStrCat()&#123;        emulator.attach().addBreakPoint(module.findSymbolByName(&quot;strcat&quot;,                true).getAddress(), new BreakPointCallback() &#123;            @Override            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                UnidbgPointer r1 = emulator.getContext().getPointerArg(1);                System.out.println(&quot;strcat:&quot;+ r1);                System.out.println(r1.getString(0));                return true;            &#125;        &#125;);    &#125;    public void hookMemcpy()&#123;        emulator.attach().addBreakPoint(module.findSymbolByName(&quot;memcpy&quot;, true).getAddress(), new BreakPointCallback() &#123;            @Override            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                UnidbgPointer r1 = emulator.getContext().getPointerArg(1);                int length = emulator.getContext().getIntArg(2);                System.out.println(&quot;memcpy&quot;);                Inspector.inspect(r1.getByteArray(0, length), r1.toString());                return true;            &#125;        &#125;);    &#125;    public void hook72bc()&#123;        emulator.attach().addBreakPoint(module.base + 0x72bc, new BreakPointCallback() &#123;            UnidbgPointer v12;            @Override            public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                RegisterContext registerContext = emulator.getContext();                UnidbgPointer a2 = registerContext.getPointerArg(1);                v12 = registerContext.getPointerArg(0);                Inspector.inspect(a2.getByteArray(0, 0x10), &quot;key &quot; + a2.toString());                // 函数结束对v12hook查看                emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() &#123;                    @Override                    public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                        //Inspector.inspect(v12.getByteArray(0, 176), &quot;Round Key &quot;+v12.toString());                        Inspector.inspect(v12.getByteArray(8, 176), &quot;Round Key &quot;+v12.toString());                        return true;                    &#125;                &#125;);                return true;            &#125;        &#125;);    &#125;    public static void main(String[] args) &#123;        DouYu douYu = new DouYu();        //douYu.traceLength();        //douYu.hookStrCat();        //douYu.hookMemcpy();        //douYu.hook72bc();        String makeUrl = douYu.getMakeUrl();        System.out.println(&quot;result:&quot;+ makeUrl);    &#125;&#125;\n\n\n","tags":["安卓逆向","Unidbg"]},{"title":"修改源码定制ART","url":"/posts/17659/","content":"ART定制方案比较\n源码修改编译，定制rom 优点：开发简单，可以直接访问ART中的海量的丰富api 缺点：较笨重，首先需要一台性能足够强大的pc，其次，每次修改完代码都需要重新编译，刷机，测试。\n基于frida，xposed等hook框架定制 优点：轻量，快捷，不需要性能强大的pc，也无需经历耗时的编译和刷机测试阶段，往往只需要重启app即可 缺点：往往无法直接复用ART源码中已有的api，只能后使用有限的api\n将修改源码定制rom和frida等hook框架相结合，比如FART和frida相结合，脱壳功能更强大。 优点：结合了frida的轻量，快捷以及修改源码的简单。\n\n工具使用：    1. 可以使用AndroidStudio导入aosp源码，对framework层相关的java类进行源码阅读和修改定制    2. 可以使用clion等ide利用aosp编译过程中生成的Cmakelists文件，导入ART部分的源码进行阅读和修改定制。\n针对ART进行定制时，对于整个AOSP源码，Java层代码只关心Framework、libcore，因此没有必要全部作为源码导入以下教程用的机型是pixel xl，源码是android 8.1\n第一种：源码修改编译，定制rom编译生成AndroidStudio项目配置文件并导入源码\n编译生成idegen.jar在AOSP源码目录下输入以下命令，生成idegen.jarsource build/envsetup.shlunch aosp_marlin-userdebugmmm development/tools/idegen/\n生成android.ipr和android.iml执行idegen.sh脚本，生成即可development/tools/idegen/idegen.sh\n运行完毕上面的命令之后，就在根目录生成了2个文件：android.ipr和android.iml\n排除不必要的模块，提高加载速度打开android.iml，找到excludeFolder属性，我们可以看到默认有一些模块是被排除了，不会被导入的。但实际上，整个AOSP代码中，我们只关心framework模块和libcore模块，因此可以根据自己的需求去掉其它所有模块，只保留framework和libcore，比如将exclude修改为如下内容：&lt;excludeFolder url=&quot;file://$MODULE_DIR$/art&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/bionic&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/bootable&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/build&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/cts&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/dalvik&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/developers&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/development&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/device&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/docs&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/external&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/hardware&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/kernel&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/libcore&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/libnativehelper&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/out&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/pdk&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/platform_testing&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/prebuilts&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/sdk&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/system&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/test&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/toolchain&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/tools&quot; /&gt;&lt;excludeFolder url=&quot;file://$MODULE_DIR$/.repo&quot; /&gt;\n这样修改之后，打开速度会快很多。接下来使用AndroidStudio直接打开android.ipr文件。 &gt; File-Open…，找到android.ipr即可。导入完成之后，就能看到整个AOSP源码了：橘红色的是在上一步exclude排除掉的模块。剩余配置参考以下文章：https://juejin.cn/post/6969508324618272782https://blog.csdn.net/yanbober/article/details/48846331\n\nClion导入ART\n编译生成cmakelists文件打开以下两个开关，CMakeLists.txt就会根据编译环境自动生成source build/envsetup.shlunch aosp_marlin-userdebugexport SOONG_GEN_CMAKEFILES=1export SOONG_GEN_CMAKEFILES_DEBUG=1\n下面开始编译make -j8\n生成的相关项目的cmakelists文件存放在out目录，不如我们需要导入ART的源码部分对应的路径为：out&#x2F;development&#x2F;ide&#x2F;clion&#x2F;art，可以看到下面还有很多模块，我们选择使用arm32或者arm64的runtime模块即可，对应的cmakelists文件在out&#x2F;development&#x2F;ide&#x2F;clion&#x2F;art&#x2F;runtime&#x2F;libart-arm-android&#x2F;CMakeLists.txt以及out&#x2F;development&#x2F;ide&#x2F;clion&#x2F;art&#x2F;runtime&#x2F;libart-arm64-android&#x2F;CMakeLists.txt然后修改根目录为源码的根目录 Tools &gt; CMake &gt; Change Project Root:\n\nAPP运行过程中so加载流程源码分析接下来对so的加载流程进行分析，加载so有两种方式System.loadLibrary(“so文件名”);System.load(“so文件相对路径”);loadLibrary通过loader.findLibrary(libraryName)函数找到库文件的绝对路径，后续跟load一样调用doLoad(String name, ClassLoader loader)，最后去调用art下的nativeLoad native函数&#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;java&#x2F;java&#x2F;lang&#x2F;Runtime.java\nprivate String doLoad(String name, ClassLoader loader) &#123;    String librarySearchPath = null;    if (loader != null &amp;&amp; loader instanceof BaseDexClassLoader) &#123;        BaseDexClassLoader dexClassLoader = (BaseDexClassLoader) loader;        librarySearchPath = dexClassLoader.getLdLibraryPath();    &#125;    java.lang.System.logE(&quot;Runtime doLoad -&gt; &quot; + name + &quot;, classLoader -&gt; &quot; + loader.toString());    synchronized (this) &#123;        return nativeLoad(name, loader, librarySearchPath);    &#125;&#125;\n\n也就是说doLoad和nativeLoad是所有加载so文件都会调用的函数，那可以在这个函数下添加log信息，这样就可以在Java下监控所有的so\njava.lang.System.logE(&quot;Runtime doLoad -&gt; &quot; + name + &quot;, classLoader -&gt; &quot; + loader.toString());\n\n通过查找源码知道nativeLoad是在xref: &#x2F;libcore&#x2F;ojluni&#x2F;src&#x2F;main&#x2F;native&#x2F;Runtime.c下\nJNIEXPORT jstring JNICALLRuntime_nativeLoad(JNIEnv* env, jclass ignored, jstring javaFilename,                   jobject javaLoader, jstring javaLibrarySearchPath)&#123;    return JVM_NativeLoad(env, javaFilename, javaLoader, javaLibrarySearchPath);&#125;\n然后通过调用链找到 nativeLoad -&gt;Runtime_nativeLoad(Runtime.c) -&gt; JVM_NativeLoad(Openjdk_Jvm.cc) -&gt; LoadNativeLibrary(java_vm_ext.cc)最后是LoadNativeLibrary函数，查看函数流程，在函数刚进来的时候添加日志\nLOG(ERROR) &lt;&lt; &quot;[java_vm_ext.cc]JavaVMExt::LoadNativeLibrary -&gt; &quot; &lt;&lt; path.c_str();\n在加载本地库的前后添加日志\n//addLOG(ERROR) &lt;&lt; &quot;[java_vm_ext.cc]before call LoadNativeLibrary -&gt; &quot; &lt;&lt; path_str;void* handle = android::OpenNativeLibrary(env,                                        runtime_-&gt;GetTargetSdkVersion(),                                        path_str,                                        class_loader,                                        library_path,                                        &amp;needs_native_bridge,                                        error_msg); //addLOG(ERROR) &lt;&lt; &quot;[java_vm_ext.cc]after call LoadNativeLibrary -&gt; &quot; &lt;&lt; path_str;\n接下来判断是否有JNI_OnLoad，没有则结束函数，有就加载JNI_OnLoad，在加载JNI_OnLoad前后添加日志\nbool was_successful = false;void* sym = library-&gt;FindSymbol(&quot;JNI_OnLoad&quot;, nullptr);if (sym == nullptr) &#123;    VLOG(jni) &lt;&lt; &quot;[No JNI_OnLoad found in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;;    was_successful = true;&#125; else &#123;    // Call JNI_OnLoad.  We have to override the current class    // loader, which will always be &quot;null&quot; since the stuff at the    // top of the stack is around Runtime.loadLibrary().  (See    // the comments in the JNI FindClass function.)    ScopedLocalRef&lt;jobject&gt; old_class_loader(env, env-&gt;NewLocalRef(self-&gt;GetClassLoaderOverride()));    self-&gt;SetClassLoaderOverride(class_loader);    VLOG(jni) &lt;&lt; &quot;[Calling JNI_OnLoad in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;;    typedef int (*JNI_OnLoadFn)(JavaVM*, void*);    JNI_OnLoadFn jni_on_load = reinterpret_cast&lt;JNI_OnLoadFn&gt;(sym);    //add    LOG(ERROR) &lt;&lt; &quot;[java_vm_ext.cc]before call &quot; &lt;&lt; path_str &lt;&lt; &quot;.JNI_Onload&quot;;    int version = (*jni_on_load)(this, nullptr);    //add    LOG(ERROR) &lt;&lt; &quot;[java_vm_ext.cc]after call &quot; &lt;&lt; path_str &lt;&lt; &quot;.JNI_Onload&quot; &lt;&lt; &quot;, returm: &quot; &lt;&lt; version;    if (runtime_-&gt;GetTargetSdkVersion() != 0 &amp;&amp; runtime_-&gt;GetTargetSdkVersion() &lt;= 21) &#123;        // Make sure that sigchain owns SIGSEGV.        EnsureFrontOfChain(SIGSEGV);    &#125;    self-&gt;SetClassLoaderOverride(old_class_loader.get());    if (version == JNI_ERR) &#123;        StringAppendF(error_msg, &quot;JNI_ERR returned from JNI_OnLoad in \\&quot;%s\\&quot;&quot;, path.c_str());    &#125; else if (JavaVMExt::IsBadJniVersion(version)) &#123;        StringAppendF(error_msg, &quot;Bad JNI version returned from JNI_OnLoad in \\&quot;%s\\&quot;: %d&quot;,                      path.c_str(), version);        // It&#x27;s unwise to call dlclose() here, but we can mark it        // as bad and ensure that future load attempts will fail.        // We don&#x27;t know how far JNI_OnLoad got, so there could        // be some partially-initialized stuff accessible through        // newly-registered native method calls.  We could try to        // unregister them, but that doesn&#x27;t seem worthwhile.    &#125; else &#123;        was_successful = true;    &#125;    VLOG(jni) &lt;&lt; &quot;[Returned &quot; &lt;&lt; (was_successful ? &quot;successfully&quot; : &quot;failure&quot;)    &lt;&lt; &quot; from JNI_OnLoad in \\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;]&quot;;&#125;\n到这里也能看出来so中的JNI_Onload的函数名必须要c的形式进行编译，还要导出的原因就是这里它需要去查找符号名重新编译，刷入手机运行有加壳的app，查看log\n第二种：基于frida，xposed等hook框架定制要实现对加载so监控的话，可以结合流程当中的api进行hook来监控so的加载流程，在hook中选择的api层级越底层越好，如果只通过System.load, loadLibrary进行监控的话，可能会遗漏掉通过runtime进行加载的so。上面分析到加载so底层的api是libnativeloader.so下的OpenNativeLibrary和libart.so下的LoadNativeLibrary可以使用frida进行hook，在hook前可以先把libnativeloader.so和libart.so脱出来用ida查看导出表OpenNativeLibrary和LoadNativeLibrary的导出符号&#x2F;system&#x2F;lib&#x2F;libart.so或者&#x2F;system&#x2F;lib64&#x2F;libart.so&#x2F;system&#x2F;lib&#x2F;libnativeloader.so或者&#x2F;system&#x2F;lib64&#x2F;libnativeloader.soOpenNativeLibrary的导出符号：_ZN7android17OpenNativeLibraryEP7_JNIEnviPKcP8_jobjectP8_jstringPbPNSt3__112basic_stringIcNS9_11char_traitsIcEENS9_9allocatorIcEEEE\n使用frida进行hook下面就监控OpenNativeLibrary\n// libart.so// bool JavaVMExt::LoadNativeLibrary(JNIEnv* env,//     const std::string&amp; path,//     jobject class_loader,//     jstring library_path,//     std::string* error_msg) // libnativeloader.so// void* handle = android::OpenNativeLibrary(env,//     runtime_-&gt;GetTargetSdkVersion(),//     path_str,//     class_loader,//     library_path,//     &amp;needs_native_bridge,//     error_msg);function tracesoload()&#123;    console.log(Process.arch);    var libnativeloaderModule = Process.getModuleByName(&quot;libnativeloader.so&quot;);    // OpenNativeLibrary    var OpenNativeLibraryAddr = libnativeloaderModule.getExportByName(&quot;_ZN7android17OpenNativeLibraryEP7_JNIEnviPKcP8_jobjectP8_jstringPbPNSt3__112basic_stringIcNS9_11char_traitsIcEENS9_9allocatorIcEEEE&quot;);    Interceptor.attach(OpenNativeLibraryAddr, &#123;        onEnter: function(args)&#123;            this.sopath = ptr(args[2]).readUtf8String();            console.log(&quot;go into OpenNativeLibrary -&gt; &quot; + this.sopath);        &#125;, onLeave: function(retval) &#123;            console.log(&quot;leave OpenNativeLibrary -&gt; &quot; + this.sopath, &quot;, return: &quot; + retval);        &#125;    &#125;)&#125;function main()&#123;    tracesoload();&#125;setImmediate(main);\n输出打印\n[AOSP on msm8996::com.iCitySuzhou.suzhou001]-&gt; arm64go into OpenNativeLibrary -&gt; /data/app/com.iCitySuzhou.suzhou001--s3SCRYsyaFmNLfEq3Pj3g==/lib/arm64/libshell-super.com.iCitySuzhou.suzhou001.soleave OpenNativeLibrary -&gt; /data/app/com.iCitySuzhou.suzhou001--s3SCRYsyaFmNLfEq3Pj3g==/lib/arm64/libshell-super.com.iCitySuzhou.suzhou001.sogo into OpenNativeLibrary -&gt; /data/app/com.iCitySuzhou.suzhou001--s3SCRYsyaFmNLfEq3Pj3g==/lib/arm64/libjcore230.soleave OpenNativeLibrary -&gt; /data/app/com.iCitySuzhou.suzhou001--s3SCRYsyaFmNLfEq3Pj3g==/lib/arm64/libjcore230.sogo into OpenNativeLibrary -&gt; /system/app/webview/webview.apk!/lib/arm64-v8a/libwebviewchromium.soleave OpenNativeLibrary -&gt; /system/app/webview/webview.apk!/lib/arm64-v8a/libwebviewchromium.sogo into OpenNativeLibrary -&gt; /system/lib64/libwebviewchromium_plat_support.soleave OpenNativeLibrary -&gt; /system/lib64/libwebviewchromium_plat_support.so\n加载so后还会对这个so进行查找是否含有 JNI_OnLoadvoid* sym &#x3D; library-&gt;FindSymbol(“JNI_OnLoad”, nullptr);\nvoid* FindSymbol(const std::string&amp; symbol_name, const char* shorty = nullptr)    REQUIRES(!Locks::mutator_lock_) &#123;    return NeedsNativeBridge()        ? FindSymbolWithNativeBridge(symbol_name.c_str(), shorty)        : FindSymbolWithoutNativeBridge(symbol_name.c_str());&#125;// NeedsNativeBridge()判断如果设备的架构与应用的架构不同返回true，所以这里是走FindSymbolWithoutNativeBridge()\nvoid* FindSymbolWithoutNativeBridge(const std::string&amp; symbol_name)    REQUIRES(!Locks::mutator_lock_) &#123;    CHECK(!NeedsNativeBridge());    return dlsym(handle_, symbol_name.c_str());&#125;\nvoid* dlsym(void* handle, const char* _Nonnull symbol);\n这里对dlsym进行监控的话，就可以监视接下来对 JNI_OnLoad 的查询的过程dlsym位于libc.so，也使用freida进行hook\nfunction tracesoload()&#123;    console.log(Process.arch);    var libnativeloaderModule = Process.getModuleByName(&quot;libnativeloader.so&quot;);    // OpenNativeLibrary    var OpenNativeLibraryAddr = libnativeloaderModule.getExportByName(&quot;_ZN7android17OpenNativeLibraryEP7_JNIEnviPKcP8_jobjectP8_jstringPbPNSt3__112basic_stringIcNS9_11char_traitsIcEENS9_9allocatorIcEEEE&quot;);    Interceptor.attach(OpenNativeLibraryAddr, &#123;        onEnter: function(args)&#123;            this.sopath = ptr(args[2]).readUtf8String();            console.log(&quot;go into OpenNativeLibrary -&gt; &quot; + this.sopath);        &#125;, onLeave: function(retval) &#123;            console.log(&quot;leave OpenNativeLibrary -&gt; &quot; + this.sopath, &quot;, return: &quot; + retval);        &#125;    &#125;)    var dlsymAddr = Module.findExportByName(&quot;libc.so&quot;, &quot;dlsym&quot;);    Interceptor.attach(dlsymAddr, &#123;        onEnter: function(args)&#123;            this.handle = args[0];            this.symbol = ptr(args[1]).readUtf8String();        &#125;, onLeave: function(retval)&#123;            console.log(&quot;leave dlsym: handle: &quot; + this.handle + &quot;, symbol: &quot; + this.symbol, &quot;, return: &quot; + retval);        &#125;    &#125;)&#125;function main()&#123;    tracesoload();&#125;setImmediate(main);\n已经看到查找JNI_OnLoad的流程\nleave OpenNativeLibrary -&gt; /data/app/com.iCitySuzhou.suzhou001--s3SCRYsyaFmNLfEq3Pj3g==/lib/arm64/libshell-super.com.iCitySuzhou.suzhou001.so , return: 0x49668d9309b699edleave dlsym: handle: 0x49668d9309b699ed, symbol: JNI_OnLoad , return: 0x730a123a5cleave dlsym: handle: 0xde2d62226fd8b40d, symbol: InitEsxProfile , return: 0x7314e10620go into OpenNativeLibrary -&gt; /data/app/com.iCitySuzhou.suzhou001--s3SCRYsyaFmNLfEq3Pj3g==/lib/arm64/libjcore230.soleave OpenNativeLibrary -&gt; /data/app/com.iCitySuzhou.suzhou001--s3SCRYsyaFmNLfEq3Pj3g==/lib/arm64/libjcore230.so , return: 0x513c62ce705a71c5leave dlsym: handle: 0x513c62ce705a71c5, symbol: JNI_OnLoad , return: 0x7308e5c5bcleave OpenNativeLibrary -&gt; /system/lib64/libwebviewchromium_plat_support.so , return: 0xef0d55dae65a7f63leave dlsym: handle: 0xef0d55dae65a7f63, symbol: JNI_OnLoad , return: 0x731ca1e740leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_base_library_1loader_LibraryLoader_nativeLibraryLoaded , return: 0x730ce0dc34leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_base_library_1loader_LibraryLoader_nativeGetVersionNumber , return: 0x730ce0dee0leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_base_TraceEvent_nativeRegisterEnabledObserver , return: 0x730ce10300leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_base_PathService_nativeOverride , return: 0x730ce0ed00leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_android_1webview_AwContentsStatics_nativeGetProductVersion , return: 0x730cdca980leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_android_1webview_AwGLFunctor_nativeGetAwDrawGLFunction , return: 0x730cdcc4e4leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_android_1webview_AwContents_nativeSetAwDrawSWFunctionTable , return: 0x730cdbfcc4leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_android_1webview_AwContents_nativeSetAwDrawGLFunctionTable , return: 0x730cdb714cleave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_android_1webview_AwContentsStatics_nativeSetCheckClearTextPermitted , return: 0x730cdcaad4leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_base_CommandLine_nativeHasSwitch , return: 0x730ce08b70leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_android_1webview_AwContentsStatics_nativeSetSafeBrowsingEnabledByManifest , return: 0x730cdcaa24leave dlsym: handle: 0xe5b5bf72a8b510e7, symbol: Java_org_chromium_base_CommandLine_nativeAppendSwitch , return: 0x730ce08cd8......\n第三种：定制rom和frida等hook框架相结合在art中一些关键地方可以预留api给frida hook, 以下面跟踪jni函数绑定为例。\nART定制跟中jni函数绑定在上面的日志看到很多symbol的值类似静态注册的JNI函数jni函数的绑定：每一个java层函数在native层都对应一个ArtMethod对象，jni函数在执行前必须完成对jni函数所在类的加载和初始化、以及该jni函数的ArtMethod对象当中属性和so中具体函数地址的绑定\n\n静态注册的jni函数\n动态注册的jni函数\n\n静态注册的jni函数通过源码追踪jni注册流程，首先当一个类中的 JNI 函数被调用的时候，ART 会首先确保该类已经被加载和初始化。这一过程通常通过 class_linker.cc 文件中的 ClassLinker::LoadClass 方法完成。在加载过程中，类的属性和成员函数也会被加载和初始化，这一步由 LoadClassMembers 方法处理。\n// 加载类void ClassLinker::LoadClass(Thread* self,                            const DexFile&amp; dex_file,                            const DexFile::ClassDef&amp; dex_class_def,                            Handle&lt;mirror::Class&gt; klass) &#123;  const uint8_t* class_data = dex_file.GetClassData(dex_class_def);  if (class_data == nullptr) &#123;    return;  // no fields or methods - for example a marker interface  &#125;  LoadClassMembers(self, dex_file, class_data, klass);&#125;// 加载类成员和函数void ClassLinker::LoadClassMembers(Thread* self,                                   const DexFile&amp; dex_file,                                   const uint8_t* class_data,                                   Handle&lt;mirror::Class&gt; klass) &#123;  &#123;    // .....部分代码省略.....    // TODO These should really use the iterators.    for (size_t i = 0; it.HasNextDirectMethod(); i++, it.Next()) &#123;      ArtMethod* method = klass-&gt;GetDirectMethodUnchecked(i, image_pointer_size_);      // 加载函数      LoadMethod(dex_file, it, klass, method);      // 将方法与其实现的代码进行链接      LinkCode(this, method, oat_class_ptr, class_def_method_index);      uint32_t it_method_index = it.GetMemberIndex();      if (last_dex_method_index == it_method_index) &#123;        // duplicate case        method-&gt;SetMethodIndex(last_class_def_method_index);      &#125; else &#123;        method-&gt;SetMethodIndex(class_def_method_index);        last_dex_method_index = it_method_index;        last_class_def_method_index = class_def_method_index;      &#125;      class_def_method_index++;    &#125;    // .........  &#125;&#125;// 方法与其实际实现的代码进行链接static void LinkCode(ClassLinker* class_linker,                     ArtMethod* method,                     const OatFile::OatClass* oat_class,                     uint32_t class_def_method_index) REQUIRES_SHARED(Locks::mutator_lock_) &#123;  ......  // 检查一个方法是否具有 native 属性，返回true则该方法是一个JNI函数  if (method-&gt;IsNative()) &#123;    // Unregistering restores the dlsym lookup stub.    // 解除方法的本地链接, 该方法在调用时不再直接执行本地代码，而是通过解释器来处理    method-&gt;UnregisterNative();    if (enter_interpreter || quick_code == nullptr) &#123;      // We have a native method here without code. Then it should have either the generic JNI      // trampoline as entrypoint (non-static), or the resolution trampoline (static).      // TODO: this doesn&#x27;t handle all the cases where trampolines may be installed.      const void* entry_point = method-&gt;GetEntryPointFromQuickCompiledCode();      DCHECK(class_linker-&gt;IsQuickGenericJniStub(entry_point) ||             class_linker-&gt;IsQuickResolutionStub(entry_point));    &#125;  &#125;&#125;// 解除方法的本地链接void ArtMethod::UnregisterNative() &#123;  CHECK(IsNative() &amp;&amp; !IsFastNative()) &lt;&lt; PrettyMethod();  // restore stub to lookup native pointer via dlsym  SetEntryPointFromJni(GetJniDlsymLookupStub());&#125;// 用于设置 JNI 方法的入口点void SetEntryPointFromJni(const void* entrypoint) &#123;    DCHECK(IsNative());    SetEntryPointFromJniPtrSize(entrypoint, kRuntimePointerSize);&#125;// 在需要 JNI 方法解析时，可以方便地获取特定的查找函数指针static inline const void* GetJniDlsymLookupStub() &#123;  return reinterpret_cast&lt;const void*&gt;(art_jni_dlsym_lookup_stub);&#125;\n不管是静态注册还是动态注册的jni函数， 当函数所在的类被加载进到 LinkCode 的时候，会进行函数第一次的地址绑定，当这个函数是静态注册的话，在第一次的时候会去调用dlsym查找符号进行绑定，当第二次调用的时候，由于入口的已经被绑定到真正的地址，就不在执行查找的过程，直接发起调用。实际上 art_jni_dlsym_lookup_stub 是汇编代码，通过源码查找 art_jni_dlsym_lookup_stubxref: &#x2F;art&#x2F;runtime&#x2F;arch&#x2F;arm&#x2F;jni_entrypoints_arm.S\n#include &quot;asm_support_arm.S&quot;    .extern artFindNativeMethodENTRY art_jni_dlsym_lookup_stub    push   &#123;r0, r1, r2, r3, lr&#125;           @ spill regs    .cfi_adjust_cfa_offset 20    .cfi_rel_offset r0, 0    .cfi_rel_offset r1, 4    .cfi_rel_offset r2, 8    .cfi_rel_offset r3, 12    .cfi_rel_offset lr, 16    sub    sp, #12                        @ pad stack pointer to align frame    .cfi_adjust_cfa_offset 12    blx    artFindNativeMethod    mov    r12, r0                        @ save result in r12    add    sp, #12                        @ restore stack pointer    .cfi_adjust_cfa_offset -12    cbz    r0, 1f                         @ is method code null?    pop    &#123;r0, r1, r2, r3, lr&#125;           @ restore regs    .cfi_adjust_cfa_offset -20    .cfi_restore r0    .cfi_restore r1    .cfi_restore r2    .cfi_restore r3    .cfi_restore lr    bx     r12                            @ if non-null, tail call to method&#x27;s code\n无论静态注册还是动态注册，当类加载完就被绑定到art_jni_dlsym_lookup_stub这个桥函数中，会执行这段汇编调用artFindNativeMethod去so查符号地址\n// Used by the JNI dlsym stub to find the native method to invoke if none is registered.#if defined(__arm__) || defined(__aarch64__)extern &quot;C&quot; const void* artFindNativeMethod() &#123;  Thread* self = Thread::Current();#elseextern &quot;C&quot; const void* artFindNativeMethod(Thread* self) &#123;  DCHECK_EQ(self, Thread::Current());#endif  Locks::mutator_lock_-&gt;AssertNotHeld(self);  // We come here as Native.  ScopedObjectAccess soa(self);  ArtMethod* method = self-&gt;GetCurrentMethod(nullptr);  DCHECK(method != nullptr);  // Lookup symbol address for method, on failure we&#x27;ll return null with an exception set,  // otherwise we return the address of the method we found.  // FindCodeForNativeMethod 查找函数地址  void* native_code = soa.Vm()-&gt;FindCodeForNativeMethod(method);  if (native_code == nullptr) &#123;    self-&gt;AssertPendingException();    return nullptr;  &#125;  // Register so that future calls don&#x27;t come here  return method-&gt;RegisterNative(native_code, false);&#125;void* JavaVMExt::FindCodeForNativeMethod(ArtMethod* m) &#123;   ......  Thread* const self = Thread::Current();  void* native_method = libraries_-&gt;FindNativeMethod(self, m, detail);   ......  return native_method;&#125;void* FindNativeMethodInternal(Thread* self,                                 void* declaring_class_loader_allocator,                                 const char* shorty,                                 const std::string&amp; jni_short_name,                                 const std::string&amp; jni_long_name)      REQUIRES(!Locks::jni_libraries_lock_)      REQUIRES(!Locks::mutator_lock_) &#123;    MutexLock mu(self, *Locks::jni_libraries_lock_);    // 遍历加载的so去查找函数    for (const auto&amp; lib : libraries_) &#123;      SharedLibrary* const library = lib.second;      // Use the allocator address for class loader equality to avoid unnecessary weak root decode.      if (library-&gt;GetClassLoaderAllocator() != declaring_class_loader_allocator) &#123;        // We only search libraries loaded by the appropriate ClassLoader.        continue;      &#125;      // Try the short name then the long name...      const char* arg_shorty = library-&gt;NeedsNativeBridge() ? shorty : nullptr;      void* fn = library-&gt;FindSymbol(jni_short_name, arg_shorty);      if (fn == nullptr) &#123;        fn = library-&gt;FindSymbol(jni_long_name, arg_shorty);      &#125;      if (fn != nullptr) &#123;        VLOG(jni) &lt;&lt; &quot;[Found native code for &quot; &lt;&lt; jni_long_name                  &lt;&lt; &quot; in \\&quot;&quot; &lt;&lt; library-&gt;GetPath() &lt;&lt; &quot;\\&quot;]&quot;;        return fn;      &#125;    &#125;    return nullptr;&#125;  void* FindSymbol(const std::string&amp; symbol_name, const char* shorty = nullptr)      REQUIRES(!Locks::mutator_lock_) &#123;    return NeedsNativeBridge()        ? FindSymbolWithNativeBridge(symbol_name.c_str(), shorty)        : FindSymbolWithoutNativeBridge(symbol_name.c_str());  &#125;  void* FindSymbolWithoutNativeBridge(const std::string&amp; symbol_name)      REQUIRES(!Locks::mutator_lock_) &#123;    CHECK(!NeedsNativeBridge());    return dlsym(handle_, symbol_name.c_str());  &#125;\njni_short_name：是本地方法的短名，它的格式通常是 Java_&lt;类的完全限定名&gt;&lt;方法名&gt;，其中类名和方法名中的每个字符（除了字母和数字）都被替换为 。  例如： Java_com_example_MyClass_myMethodjni_long_name：是本地方法的长名，它的格式通常是 Java&lt;类的完全限定名&gt;&lt;方法名&gt;__&lt;参数签名&gt;，其中参数签名部分用 _ 分隔每个参数类型的描述符。  例如： Java_com_example_MyClass_myMethod__ILjava_lang_String_2 通过FindCodeForNativeMethod找到的函数地址后，会调用 RegisterNative 才把它的地址绑定到artmethod里面，method-&gt;RegisterNative(native_code, false);回到上面的汇编代码\nblx    artFindNativeMethodmov    r12, r0bx     r12          \n经过artFindNativeMethod查到绑定后的artmethod地址返回接下来就可以对上面的一些流程添加log打印，在artFindNativeMethod下可以监控静态注册jni函数绑定的流程\n#if defined(__arm__) || defined(__aarch64__)extern &quot;C&quot; const void* artFindNativeMethod() &#123;  Thread* self = Thread::Current();#elseextern &quot;C&quot; const void* artFindNativeMethod(Thread* self) &#123;  DCHECK_EQ(self, Thread::Current());#endif  Locks::mutator_lock_-&gt;AssertNotHeld(self);  // We come here as Native.  ScopedObjectAccess soa(self);  ArtMethod* method = self-&gt;GetCurrentMethod(nullptr);  DCHECK(method != nullptr);  // Lookup symbol address for method, on failure we&#x27;ll return null with an exception set,  // otherwise we return the address of the method we found.  void* native_code = soa.Vm()-&gt;FindCodeForNativeMethod(method);  if (native_code == nullptr) &#123;    self-&gt;AssertPendingException();    return nullptr;  &#125; else &#123;    //add    std::stringstream oss;    oss &lt;&lt; &quot;[artFindNativeMethod]StaticRegisterJniMethod-&gt;&quot; &lt;&lt; method-&gt;PrettyMethod() &lt;&lt; &quot;, add: &quot; &lt;&lt; native_code;    const char *content = oss.str().c_str();    if (strstr(content, &quot;zsklog&quot;) != nullptr) &#123;      LOG(ERROR) &lt;&lt; content;    &#125;    //add  &#125;  // Register so that future calls don&#x27;t come here  return method-&gt;RegisterNative(native_code, false);&#125;\n上面添加了标识 strstr(content, “zsklog”) 用来让frida可以控制日志打印开关\n动态注册的jni函数动态注册的jni函数都是通过 RegisterNatives 去注册绑定地址，定位到源码的位置\nstatic jint RegisterNatives(JNIEnv* env,                            jclass java_class,                            const JNINativeMethod* methods,                            jint method_count) &#123;  ......  CHECK_NON_NULL_ARGUMENT_FN_NAME(&quot;RegisterNatives&quot;, methods, JNI_ERR);  for (jint i = 0; i &lt; method_count; ++i) &#123;    const char* name = methods[i].name;    const char* sig = methods[i].signature;    const void* fnPtr = methods[i].fnPtr;    bool is_fast = false;    ......    const void* final_function_ptr = m-&gt;RegisterNative(fnPtr, is_fast);    UNUSED(final_function_ptr);  &#125;  return JNI_OK;&#125;\n遍历methods，最后跟静态注册jni函数的流程一样去调用 RegisterNative ，静态注册的log已经添加，那在 RegisterNative 里添加log不就能跟踪到动态注册的函数，\nconst void* ArtMethod::RegisterNative(const void* native_method, bool is_fast) &#123;  CHECK(IsNative()) &lt;&lt; PrettyMethod();  CHECK(!IsFastNative()) &lt;&lt; PrettyMethod();  CHECK(native_method != nullptr) &lt;&lt; PrettyMethod();  if (is_fast) &#123;    AddAccessFlags(kAccFastNative);  &#125;  void* new_native_method = nullptr;  Runtime::Current()-&gt;GetRuntimeCallbacks()-&gt;RegisterNativeMethod(this,                                                                  native_method,                                                                  /*out*/&amp;new_native_method);  //add  std::stringstream oss;  oss &lt;&lt; &quot;[ArtMethod::RegisterNative]JniMethod-&gt;&quot; &lt;&lt; this-&gt;PrettyMethod() &lt;&lt; &quot;, add: &quot; &lt;&lt; native_method;  const char *content = oss.str().c_str();  if (strstr(content, &quot;zsklog&quot;) != nullptr) &#123;    LOG(ERROR) &lt;&lt; content;  &#125;  //add  SetEntryPointFromJni(new_native_method);  return new_native_method;&#125;\njni函数的绑定分类总结\n静态函数的jni函数：有两次绑定，第一次是在类加载时，会绑定到ART中的“桥函数”(art_jni_dlsym_lookup_stub) ，第二次绑定是在该jni函数第一次被真正调用时，ART 会通过桥函数查找该函数在本地库中的实际地址，并进行绑定。后续调用将直接使用该地址，避免重复查找。 LoadClass -&gt; LoadClassMembers -&gt; SetEntryPointFromJni(GetJniDlsymLookupStub() -&gt;art_jni_dlsym_lookup_stub -&gt; artFindNativeMethod -&gt; FindCodeForNativeMethod(method)\n动态注册的jni函数：也是有两次绑定，只不过和静态注册的jni函数的第二次绑定不同之处在于是由开发人员编写的代码主动调用RegeisterNatives进行绑定，而不是由ART“帮助”完成绑定。重新编写后刷入，frida代码function traceJniRegiseter()&#123;    var libc_module = Process.getModuleByName(&quot;libc.so&quot;);    var strstr = libc_module.getExportByName(&quot;strstr&quot;);    Interceptor.attach(strstr, &#123;        onEnter: function(args) &#123;            this.thread_id = Process.getCurrentThreadId();            this.arg0 = ptr(args[0]).readUtf8String();            this.arg1 = ptr(args[1]).readUtf8String();        &#125;, onLeave: function(retval) &#123;            if (this.arg1 == &quot;zsklog&quot;) &#123;                console.log(&quot;[&quot; + this.thread_id + &quot;]&quot; + &quot;go into OpenNativeLibrary -&gt; &quot; + this.arg0);                retval.replace(0x100);            &#125;        &#125;    &#125;)&#125;function tracesoload()&#123;    console.log(Process.arch);    var libnativeloaderModule = Process.getModuleByName(&quot;libnativeloader.so&quot;);    // OpenNativeLibrary    var OpenNativeLibraryAddr = libnativeloaderModule.getExportByName(&quot;_ZN7android17OpenNativeLibraryEP7_JNIEnviPKcP8_jobjectP8_jstringPbPNSt3__112basic_stringIcNS9_11char_traitsIcEENS9_9allocatorIcEEEE&quot;);    Interceptor.attach(OpenNativeLibraryAddr, &#123;        onEnter: function(args)&#123;            this.sopath = ptr(args[2]).readUtf8String();            this.thread_id = Process.getCurrentThreadId();            console.log(&quot;[&quot; + this.thread_id + &quot;]&quot; + &quot;go into OpenNativeLibrary -&gt; &quot; + this.sopath);        &#125;, onLeave: function(retval) &#123;            console.log(&quot;[&quot; + this.thread_id + &quot;]&quot; + &quot;leave OpenNativeLibrary -&gt; &quot; + this.sopath, &quot;, return: &quot; + retval);        &#125;    &#125;)    var dlsymAddr = Module.findExportByName(&quot;libc.so&quot;, &quot;dlsym&quot;);    Interceptor.attach(dlsymAddr, &#123;        onEnter: function(args)&#123;            this.handle = args[0];            this.symbol = ptr(args[1]).readUtf8String();            this.thread_id = Process.getCurrentThreadId();        &#125;, onLeave: function(retval)&#123;            console.log(&quot;[&quot; + this.thread_id + &quot;]&quot; + &quot;leave dlsym: handle: &quot; + this.handle + &quot;, symbol: &quot; + this.symbol, &quot;, return: &quot; + retval);        &#125;    &#125;)&#125;function main()&#123;    tracesoload();    traceJniRegiseter();&#125;setImmediate(main);\narm64[8007]leave dlsym: handle: 0x2adcc85529763b0b, symbol: oatdata , return: 0x7d1659d000[8007]leave dlsym: handle: 0x2adcc85529763b0b, symbol: oatlastword , return: 0x7d1659e224[8007]leave dlsym: handle: 0x2adcc85529763b0b, symbol: oatbss , return: 0x7d1659f000[8007]leave dlsym: handle: 0x2adcc85529763b0b, symbol: oatbsslastword , return: 0x7d165a2acc[8007]leave dlsym: handle: 0x2adcc85529763b0b, symbol: oatbssmethods , return: 0x0[8007]leave dlsym: handle: 0x2adcc85529763b0b, symbol: oatbssroots , return: 0x0[8007]go into OpenNativeLibrary -&gt; /data/app/com.iCitySuzhou.suzhou001-IqFG3pwpI6PxX176DYv1tw==/lib/arm64/libshell-super.com.iCitySuzhou.suzhou001.so[8007]leave dlsym: handle: 0xa5c5ee03e19145b9, symbol: mmap , return: 0x7db163acd4[8007]leave dlsym: handle: 0xa5c5ee03e19145b9, symbol: write , return: 0x7db163b4cc[8007]leave dlsym: handle: 0xa5c5ee03e19145b9, symbol: close , return: 0x7db15ed138[8007]leave dlsym: handle: 0xa5c5ee03e19145b9, symbol: fdatasync , return: 0x7db163a8b4[8007]leave OpenNativeLibrary -&gt; /data/app/com.iCitySuzhou.suzhou001-IqFG3pwpI6PxX176DYv1tw==/lib/arm64/libshell-super.com.iCitySuzhou.suzhou001.so , return: 0x5cd2a12d5c2fc103[8007]leave dlsym: handle: 0x5cd2a12d5c2fc103, symbol: JNI_OnLoad , return: 0x7d160c6a5c[8007]go into OpenNativeLibrary -&gt; [ArtMethod::RegisterNative]JniMethod-&gt;void com.wrapper.proxyapplication.WrapperProxyApplication.Ooo0ooO0oO(), add: 0x7d160c8418[8007]go into OpenNativeLibrary -&gt; [ArtMethod::RegisterNative]JniMethod-&gt;int com.wrapper.proxyapplication.CustomerClassLoader.ShowLogs(java.lang.String, int), add: 0x7d160c648c......\n\n","tags":["脱壳"]},{"title":"SM4国密算法原理及分析","url":"/posts/61783/","content":"\n明文：31323334353637383930616263646566（16个字节）KEY：31323334353637383930616263646566（16个字节）\n加密方式ecb模式：它将明文消息分成固定长度的块,然后独立地对每个块进行加密。将所有密文块连接起来,形成最终的密文。cbc模式：通过将前一个密文块与当前明文块异或后再加密来增强安全性。第一组与iv异或加密后的值参与第二组异或。将所有密文块连接起来,形成最终的密文。\n密钥编排固定参数CK\nSM4_CK = [    0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,    0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,    0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,    0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,    0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,    0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,    0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,    0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279]\nS盒\nSM4_BOX = [    0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c,    0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86,    0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed,    0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa,    0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c,    0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb,    0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25,    0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52,    0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38,    0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34,    0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82,    0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45,    0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf,    0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1,    0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89,    0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84,    0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39,    0x48,]\n对密钥进行四字节分割\nMK0: 31323334MK1: 35363738MK2: 39306162MK3: 63646566\n分别与FK进行异或\nSM4_FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc]\n异或结果k\nk0: 928389F2k1: 639C0468k2: 5E4DF0F5k3: D11447BA\n密钥编排共32轮 生成 4 * 32 个字节的数组第一轮 当 i &#x3D; 0 时box_in &#x3D; k1 ^ k2^ k3^ SM4_CK[i]即 box_in &#x3D; 0x639C0468 ^ 0x5E4DF0F5 ^ 0xD11447BA ^ 0x70E15 &#x3D; 0xECC2BD32将 box_in 0xECC2BD32 拆分成四个单字节进行S盒的替换box_out &#x3D; SM4_BOX[0xEC] SM4_BOX[0xC2] SM4_BOX[0xBD] SM4_BOX[0x32] 即 box_out &#x3D; C5 AF 6C 1C得到轮密钥key_r[i] &#x3D; k0 ^ box_out ^ box_out左移13位 ^ box_out左移23位即 key_r[0] &#x3D; 0x928389F2 ^ 0xC5AF6C1C ^ 0xED8398B5 ^ 0xE62D7B6 &#x3D; 0xB4CDAAED最后将k1赋值k0，k2赋值k1，k3赋值k2，key_r[i]赋值k3即 k0 &#x3D; k1 &#x3D; 0x639C0468    k1 &#x3D; k2 &#x3D; 0x5E4DF0F5    k2 &#x3D; k3 &#x3D; 0xD11447BA    k3 &#x3D; key_r[0] &#x3D; 0xB4CDAAED\n循环得到32个key_r\nkey_r = [&#x27;0xB4CDAAED&#x27;, &#x27;0x393A0943&#x27;, &#x27;0x5419A218&#x27;, &#x27;0x430FEB9A&#x27;, &#x27;0xB7B64328&#x27;, &#x27;0x89FD60C4&#x27;, &#x27;0x80FED71C&#x27;, &#x27;0x78CC97DB&#x27;, &#x27;0x541BB50E&#x27;, &#x27;0x9E47804C&#x27;, &#x27;0xE4558316&#x27;, &#x27;0xAF89E123&#x27;, &#x27;0xDA4E6F12&#x27;, &#x27;0x1A123F42&#x27;, &#x27;0x163D31AC&#x27;, &#x27;0x41782FDF&#x27;, &#x27;0xAD1F9760&#x27;, &#x27;0x22F3ED65&#x27;, &#x27;0xD6A523CF&#x27;, &#x27;0x5D5258D6&#x27;, &#x27;0x6964712A&#x27;, &#x27;0x81C9EA81&#x27;, &#x27;0xC78DF2DB&#x27;, &#x27;0xCDFB8685&#x27;, &#x27;0x4860C851&#x27;, &#x27;0xC6EEAC9F&#x27;, &#x27;0xEB2F69F3&#x27;, &#x27;0x679AB10F&#x27;, &#x27;0x8383A684&#x27;, &#x27;0xE38ED125&#x27;, &#x27;0x894B0AEA&#x27;, &#x27;0x68C6DFA8&#x27;]\n 密钥编排代码逻辑  SM4_FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc]# CKSM4_CK = [    0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,    0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,    0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,    0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,    0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,    0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,    0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,    0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279]# S盒SM4_BOX = [    0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c,    0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86,    0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed,    0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa,    0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c,    0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb,    0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25,    0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52,    0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38,    0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34,    0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82,    0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45,    0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf,    0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1,    0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89,    0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84,    0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39,    0x48,]class SM4(object):    def __init__(self):        self.key_r = [0] * 32    # 拼接四个单字节    @staticmethod    def get_uint32_be(key_data):        return (key_data[0] &lt;&lt; 24) | (key_data[1] &lt;&lt; 16) | (key_data[2] &lt;&lt; 8) | (key_data[3])    # 将四个字节拆分    @staticmethod    def put_uint32_be(src):        return [(src &gt;&gt; 24) &amp; 0xFF, (src &gt;&gt; 16) &amp; 0xFF, (src &gt;&gt; 8) &amp; 0xFF, src &amp; 0xFF]    # 循环左移    @staticmethod    def rotl(x, n):        return ((x &lt;&lt; n) &amp; 0xffffffff) | ((x &gt;&gt; (32 - n)) &amp; 0xffffffff)    def _round_key(self, ka):        b = [0, 0, 0, 0]        a = self.put_uint32_be(ka)        b[0] = SM4_BOX[a[0]]        b[1] = SM4_BOX[a[1]]        b[2] = SM4_BOX[a[2]]        b[3] = SM4_BOX[a[3]]        box_out = self.get_uint32_be(b[0:4])        rk = box_out ^ (self.rotl(box_out, 13)) ^ (self.rotl(box_out, 23))        return rk    def key_generate(self, key):        key = self.bytes_to_list(key)        k = [0, 0, 0, 0]        k0 = self.get_uint32_be(key[0:4])        k1 = self.get_uint32_be(key[4:8])        k2 = self.get_uint32_be(key[8:12])        k3 = self.get_uint32_be(key[12:16])        k[0] = k0 ^ SM4_FK[0]        k[1] = k1 ^ SM4_FK[1]        k[2] = k2 ^ SM4_FK[2]        k[3] = k3 ^ SM4_FK[3]        for i in range(32):            box_in = k[1] ^ k[2] ^ k[3] ^ SM4_CK[i]            self.key_r[i] = k[0] ^ self._round_key(box_in)            k[0] = k[1]            k[1] = k[2]            k[2] = k[3]            k[3] = self.key_r[i]\n明文处理明文不满16字节及16字节倍数，需要填充至16字节的倍数，如果已经是16字节倍数则填充一组16字节两种填充规则：\n\nPKCS7: 在明文末尾添加填充字节,填充字节的值等于填充的字节数。例如明文是 31323334353637383930 长度为10字节，则在末尾添加6个值为0x06的字节，填充值16字节。\nZERO: 在明文末尾添加填充0x0,填充字节的值等于填充的字节数。例如明文是 31323334353637383930 长度为10字节，则在末尾添加6个值为0x00的字节，填充值16字节。\n\n填充如果明文大于16字节，需要分组处理，每16字节一组对明文 31323334353637383930616263646566 进行四字节分割\nx0: 31323334x1: 35363738x2: 39306162x3: 63646566\n明文处理共32轮  最终的 x3 x2 x1 x0 组成16字节密文第一轮 当 i &#x3D; 0 时box_input &#x3D; x1 ^ x2 ^ x3 ^ key_r[i]即 box_input &#x3D; 0x35363738 ^ 0x39306162 ^ 0x63646566 ^ 0xB4CDAAED &#x3D; 0xDBAF99D1将 box_input 0xDBAF99D1 拆分成四个单字节进行S盒的替换box_out &#x3D; SM4_BOX[0xDB] SM4_BOX[0xAF] SM4_BOX[0x99] SM4_BOX[0xD1] 即 box_out &#x3D; 12 6F 93 C1box_out 循环左移与明文异或temp &#x3D; x0 ^ box_out ^ box_out左移2位 ^ box_out左移10位 ^ box_out左移18位 ^ box_out左移24位即 temp &#x3D; 0x31323334 ^ 0x126F93C1 ^ 0x49BE4F04 ^ 0xBE4F0449 ^ 0x4F0449BE ^ 0xC1126F93 &#x3D; 0x5ABACD95最后将x1赋值x0，x2赋值x1，x3赋值x2，temp赋值x3即 x0 &#x3D; x1 &#x3D; 0x35363738    x1 &#x3D; x2 &#x3D; 0x39306162    x2 &#x3D; x3 &#x3D; 0x63646566    x3 &#x3D; temp &#x3D; 0x5ABACD95循环得到32轮后结果x0 &#x3D; 0x6E15AEA9x1 &#x3D; 0x1B3702C5x2 &#x3D; 0xE3A63336x3 &#x3D; 0x071F23E0最终结果 x3 x2 x1 x0output &#x3D; x3 x2 x1 x0即 out_put &#x3D; 071F23E0 E3A63336 1B3702C5 6E15AEA9加密逻辑\nPKCS7 = 0ZERO = 1class SM4(object):    def __init__(self, padding_mode=PKCS7):        self.key_r = [0] * 32        self.padding_mode = padding_mode    # 拼接四个单字节    @staticmethod    def get_uint32_be(key_data):        return (key_data[0] &lt;&lt; 24) | (key_data[1] &lt;&lt; 16) | (key_data[2] &lt;&lt; 8) | (key_data[3])    # 将四个字节拆分    @staticmethod    def put_uint32_be(src):        return [(src &gt;&gt; 24) &amp; 0xFF, (src &gt;&gt; 16) &amp; 0xFF, (src &gt;&gt; 8) &amp; 0xFF, src &amp; 0xFF]    # 循环左移    @staticmethod    def rotl(x, n):        return ((x &lt;&lt; n) &amp; 0xffffffff) | ((x &gt;&gt; (32 - n)) &amp; 0xffffffff)    # 将列表转换为bytes    @staticmethod    def list_to_bytes(data):        return b&#x27;&#x27;.join([bytes((i,)) for i in data])    # 将bytes转换为列表    @staticmethod    def bytes_to_list(data):        return [i for i in data]    # 明文填充    @staticmethod    def pkcs7_padding(data, block=16):        return data + [(16 - len(data) % block) for _ in range(16 - len(data) % block)]    @staticmethod    def zero_padding(data, block=16):        return data + [0 for _ in range(16 - len(data) % block)]    def one_round(self, in_put):        in_put = self.bytes_to_list(in_put)        x0 = self.get_uint32_be(in_put[0:4])        x1 = self.get_uint32_be(in_put[4:8])        x2 = self.get_uint32_be(in_put[8:12])        x3 = self.get_uint32_be(in_put[12:16])        for i in range(32):            box_input = x1 ^ x2 ^ x3 ^ self.key_r[i]            a = self.put_uint32_be(box_input)            b = [0, 0, 0, 0]            b[0] = SM4_BOX[a[0]]            b[1] = SM4_BOX[a[1]]            b[2] = SM4_BOX[a[2]]            b[3] = SM4_BOX[a[3]]            box_out = self.get_uint32_be(b[0:4])            temp = x0 ^ box_out ^ self.rotl(box_out, 2) ^ self.rotl(box_out, 10) ^ self.rotl(box_out, 18) ^ self.rotl(box_out, 24)            x0, x1, x2, x3 = x1, x2, x3, temp        return self.put_uint32_be(x3) + self.put_uint32_be(x2) + self.put_uint32_be(x1) + self.put_uint32_be(x0)    def encrypt_ecb(self, input_data):        input_data = self.bytes_to_list(input_data)        if self.padding_mode == PKCS7:            input_data = self.pkcs7_padding(input_data)        elif self.padding_mode == ZERO:            input_data = self.zero_padding(input_data)        length = len(input_data)        i = 0        output_data = []        while length &gt; 0:            output_data += self.one_round(input_data[i:i + 16])            i += 16            length -= 16        return self.list_to_bytes(output_data)\n\nSM4 CBC模式上面实现的是ecb模式，cbc模式会在分组加密的时候与iv异或，异或后的结果替换明文参与加密。且每组加密完的结果会做为下一轮的iv参与异或。\n明文：31323334353637383930616263646566（16个字节）KEY：31323334353637383930616263646566（16个字节）IV：   1234567890abcdef1234567890abcdef（16个字节）明文和IV每个字节分别异或后拼接明文: 0x31 0x32 0x33 0x34 0x35 0x36 0x37 0x38 0x39 0x30 0x61 0x62 0x63 0x64 0x65 0x66IV:    0x12 0x34 0x56 0x78 0x90 0xab 0xcd 0xef 0x12 0x34 0x56 0x78 0x90 0xab 0xcd 0xef结果: 23 06 65 4c a5 9d fa d7 2b 04 37 1a f3 cf a8 89异或后的结果当成“明文”参与加密，其他流程跟ecb模式一样\n代码逻辑\ndef encrypt_cbc(self, iv, input_data):    input_data = self.bytes_to_list(input_data)    iv = self.bytes_to_list(iv)    if self.padding_mode == PKCS7:        input_data = self.pkcs7_padding(input_data)    elif self.padding_mode == ZERO:        input_data = self.zero_padding(input_data)    length = len(input_data)    i = 0    output_data = []    tmp_input = [0] * 16    while length &gt; 0:        tmp_input[0:16] = self.xor(input_data[i:i + 16], iv[0:16])        output_data += self.one_round(tmp_input[0:16])        iv = copy.deepcopy(output_data[i:i + 16])        i += 16        length -= 16    return self.list_to_bytes(output_data)\n完整代码import copySM4_FK = [0xa3b1bac6, 0x56aa3350, 0x677d9197, 0xb27022dc]# CKSM4_CK = [    0x00070e15, 0x1c232a31, 0x383f464d, 0x545b6269,    0x70777e85, 0x8c939aa1, 0xa8afb6bd, 0xc4cbd2d9,    0xe0e7eef5, 0xfc030a11, 0x181f262d, 0x343b4249,    0x50575e65, 0x6c737a81, 0x888f969d, 0xa4abb2b9,    0xc0c7ced5, 0xdce3eaf1, 0xf8ff060d, 0x141b2229,    0x30373e45, 0x4c535a61, 0x686f767d, 0x848b9299,    0xa0a7aeb5, 0xbcc3cad1, 0xd8dfe6ed, 0xf4fb0209,    0x10171e25, 0x2c333a41, 0x484f565d, 0x646b7279]# S盒SM4_BOX = [    0xd6, 0x90, 0xe9, 0xfe, 0xcc, 0xe1, 0x3d, 0xb7, 0x16, 0xb6, 0x14, 0xc2, 0x28, 0xfb, 0x2c,    0x05, 0x2b, 0x67, 0x9a, 0x76, 0x2a, 0xbe, 0x04, 0xc3, 0xaa, 0x44, 0x13, 0x26, 0x49, 0x86,    0x06, 0x99, 0x9c, 0x42, 0x50, 0xf4, 0x91, 0xef, 0x98, 0x7a, 0x33, 0x54, 0x0b, 0x43, 0xed,    0xcf, 0xac, 0x62, 0xe4, 0xb3, 0x1c, 0xa9, 0xc9, 0x08, 0xe8, 0x95, 0x80, 0xdf, 0x94, 0xfa,    0x75, 0x8f, 0x3f, 0xa6, 0x47, 0x07, 0xa7, 0xfc, 0xf3, 0x73, 0x17, 0xba, 0x83, 0x59, 0x3c,    0x19, 0xe6, 0x85, 0x4f, 0xa8, 0x68, 0x6b, 0x81, 0xb2, 0x71, 0x64, 0xda, 0x8b, 0xf8, 0xeb,    0x0f, 0x4b, 0x70, 0x56, 0x9d, 0x35, 0x1e, 0x24, 0x0e, 0x5e, 0x63, 0x58, 0xd1, 0xa2, 0x25,    0x22, 0x7c, 0x3b, 0x01, 0x21, 0x78, 0x87, 0xd4, 0x00, 0x46, 0x57, 0x9f, 0xd3, 0x27, 0x52,    0x4c, 0x36, 0x02, 0xe7, 0xa0, 0xc4, 0xc8, 0x9e, 0xea, 0xbf, 0x8a, 0xd2, 0x40, 0xc7, 0x38,    0xb5, 0xa3, 0xf7, 0xf2, 0xce, 0xf9, 0x61, 0x15, 0xa1, 0xe0, 0xae, 0x5d, 0xa4, 0x9b, 0x34,    0x1a, 0x55, 0xad, 0x93, 0x32, 0x30, 0xf5, 0x8c, 0xb1, 0xe3, 0x1d, 0xf6, 0xe2, 0x2e, 0x82,    0x66, 0xca, 0x60, 0xc0, 0x29, 0x23, 0xab, 0x0d, 0x53, 0x4e, 0x6f, 0xd5, 0xdb, 0x37, 0x45,    0xde, 0xfd, 0x8e, 0x2f, 0x03, 0xff, 0x6a, 0x72, 0x6d, 0x6c, 0x5b, 0x51, 0x8d, 0x1b, 0xaf,    0x92, 0xbb, 0xdd, 0xbc, 0x7f, 0x11, 0xd9, 0x5c, 0x41, 0x1f, 0x10, 0x5a, 0xd8, 0x0a, 0xc1,    0x31, 0x88, 0xa5, 0xcd, 0x7b, 0xbd, 0x2d, 0x74, 0xd0, 0x12, 0xb8, 0xe5, 0xb4, 0xb0, 0x89,    0x69, 0x97, 0x4a, 0x0c, 0x96, 0x77, 0x7e, 0x65, 0xb9, 0xf1, 0x09, 0xc5, 0x6e, 0xc6, 0x84,    0x18, 0xf0, 0x7d, 0xec, 0x3a, 0xdc, 0x4d, 0x20, 0x79, 0xee, 0x5f, 0x3e, 0xd7, 0xcb, 0x39,    0x48,]PKCS7 = 0ZERO = 1class SM4(object):    def __init__(self, padding_mode=PKCS7):        self.key_r = [0] * 32        self.padding_mode = padding_mode    # 拼接四个单字节    @staticmethod    def get_uint32_be(key_data):        return (key_data[0] &lt;&lt; 24) | (key_data[1] &lt;&lt; 16) | (key_data[2] &lt;&lt; 8) | (key_data[3])    # 将四个字节拆分    @staticmethod    def put_uint32_be(src):        return [(src &gt;&gt; 24) &amp; 0xFF, (src &gt;&gt; 16) &amp; 0xFF, (src &gt;&gt; 8) &amp; 0xFF, src &amp; 0xFF]    # 循环左移    @staticmethod    def rotl(x, n):        return ((x &lt;&lt; n) &amp; 0xffffffff) | ((x &gt;&gt; (32 - n)) &amp; 0xffffffff)    # 将列表转换为bytes    @staticmethod    def list_to_bytes(data):        return b&#x27;&#x27;.join([bytes((i,)) for i in data])    # 将bytes转换为列表    @staticmethod    def bytes_to_list(data):        return [i for i in data]    # 明文填充    @staticmethod    def pkcs7_padding(data, block=16):        return data + [(16 - len(data) % block) for _ in range(16 - len(data) % block)]    @staticmethod    def zero_padding(data, block=16):        return data + [0 for _ in range(16 - len(data) % block)]    @staticmethod    def xor(a, b):        return list(map(lambda x, y: x ^ y, a, b))    def _round_key(self, ka):        b = [0, 0, 0, 0]        a = self.put_uint32_be(ka)        b[0] = SM4_BOX[a[0]]        b[1] = SM4_BOX[a[1]]        b[2] = SM4_BOX[a[2]]        b[3] = SM4_BOX[a[3]]        box_out = self.get_uint32_be(b[0:4])        rk = box_out ^ (self.rotl(box_out, 13)) ^ (self.rotl(box_out, 23))        return rk    def key_generate(self, key):        key = self.bytes_to_list(key)        k = [0, 0, 0, 0]        k0 = self.get_uint32_be(key[0:4])        k1 = self.get_uint32_be(key[4:8])        k2 = self.get_uint32_be(key[8:12])        k3 = self.get_uint32_be(key[12:16])        k[0] = k0 ^ SM4_FK[0]        k[1] = k1 ^ SM4_FK[1]        k[2] = k2 ^ SM4_FK[2]        k[3] = k3 ^ SM4_FK[3]        for i in range(32):            box_in = k[1] ^ k[2] ^ k[3] ^ SM4_CK[i]            self.key_r[i] = k[0] ^ self._round_key(box_in)            k[0] = k[1]            k[1] = k[2]            k[2] = k[3]            k[3] = self.key_r[i]    def one_round(self, in_put):        in_put = self.bytes_to_list(in_put)        x0 = self.get_uint32_be(in_put[0:4])        x1 = self.get_uint32_be(in_put[4:8])        x2 = self.get_uint32_be(in_put[8:12])        x3 = self.get_uint32_be(in_put[12:16])        for i in range(32):            box_input = x1 ^ x2 ^ x3 ^ self.key_r[i]            a = self.put_uint32_be(box_input)            b = [0, 0, 0, 0]            b[0] = SM4_BOX[a[0]]            b[1] = SM4_BOX[a[1]]            b[2] = SM4_BOX[a[2]]            b[3] = SM4_BOX[a[3]]            box_out = self.get_uint32_be(b[0:4])            temp = x0 ^ box_out ^ self.rotl(box_out, 2) ^ self.rotl(box_out, 10) ^ self.rotl(box_out, 18) ^ self.rotl(box_out, 24)            x0, x1, x2, x3 = x1, x2, x3, temp        return self.put_uint32_be(x3) + self.put_uint32_be(x2) + self.put_uint32_be(x1) + self.put_uint32_be(x0)    def encrypt_ecb(self, input_data):        input_data = self.bytes_to_list(input_data)        if self.padding_mode == PKCS7:            input_data = self.pkcs7_padding(input_data)        elif self.padding_mode == ZERO:            input_data = self.zero_padding(input_data)        length = len(input_data)        i = 0        output_data = []        while length &gt; 0:            output_data += self.one_round(input_data[i:i + 16])            i += 16            length -= 16        return self.list_to_bytes(output_data)    def encrypt_cbc(self, iv, input_data):        input_data = self.bytes_to_list(input_data)        iv = self.bytes_to_list(iv)        if self.padding_mode == PKCS7:            input_data = self.pkcs7_padding(input_data)        elif self.padding_mode == ZERO:            input_data = self.zero_padding(input_data)        length = len(input_data)        i = 0        output_data = []        tmp_input = [0] * 16        while length &gt; 0:            tmp_input[0:16] = self.xor(input_data[i:i + 16], iv[0:16])            output_data += self.one_round(tmp_input[0:16])            iv = copy.deepcopy(output_data[i:i + 16])            i += 16            length -= 16        return self.list_to_bytes(output_data)if __name__ == &#x27;__main__&#x27;:    # 16进制密钥和初始化向量    key_hex = &#x27;31323334353637383930616263646566&#x27;    iv_hex = &#x27;1234567890abcdef1234567890abcdef&#x27;    # 16进制明文    data_hex = &#x27;31323334353637383930616263646566&#x27;    # 转换为bytes类型    key_b = bytes.fromhex(key_hex)    iv_b = bytes.fromhex(iv_hex)    data_b = bytes.fromhex(data_hex)    cipher = SM4(PKCS7)    cipher.key_generate(key_b)    ecb_result = cipher.encrypt_ecb(data_b)    print(&quot;ecb_result: &quot;, ecb_result.hex())    cbc_result = cipher.encrypt_cbc(iv_b, data_b)    print(&quot;cbc_result: &quot;, cbc_result.hex())","tags":["算法"]},{"title":"iOS逆向系列(一) 环境配置","url":"/posts/12801/","content":"前期准备有mac设备可以直接下载checker1n，下载链接：https://checkra.in/下载后安装打开如果提示身份不明的开发者（如下图），则在 设置-隐私与安全性 进行设置\n\n打开后点击 Options，记得先连接手机\n\n勾选第一个和第三个，然后点 Back 返回\n\n点击 Start，再点击Next，这时候手机就自动进入恢复模式\n\n等待结束就会到这一步\n\n意思就是，1.先点击Start，2. 点击Start后要按住提示的按键，即侧边键，比如我的是iphone6就是同时按住电源键和home键（机型不同按键稍有差距），同时按住看着那个4秒倒计时完放开电源键，一直按住home键10秒，直到3.上面的倒计时结束放开，然后就会有进度条跑代码开机，显示All Done为成功\n\n越狱成功的话，打开手机桌面上的checkra1n，安装cydia记可成功的越狱。注意：手机重启的话越狱会失效，需要重新越狱。\nwin可以使用u盘越狱，教程：https://mp.weixin.qq.com/s/oTm4xlO1b-v3f4y3x_koUA工具下载链接：链接：https://pan.baidu.com/s/1_Rw810In2L9eR0Xsc2WEDA提取码：4511\n越狱后root密码 alpine，输入 passwd 命令后按照提示连续两次输入新密码即可越狱后下载的几个插件&#x2F;工具Vi IMprovedhtopFilza File ManageApple File ConduitAppSync Unified (需要添加软件源 cydia.angelxwind.net)MTerminalnanoOpenSSH\nfrida安装，选择16.0.19，deb后缀的，推到ios上使用命令安装 dpkg -i frida_xxxxxx.deb安装成功可以在cydia看到\n\nios脱壳脱壳脚本 https://github.com/AloneMonkey/frida-ios-dump拉取下来后安装README里的要求，下载requirements.txt里的库，端口转发 iproxy 2222 22，ssh链接端口2222，ssh root@127.0.0.1 -p 2222加壳软件：高考蜂背（爱思助手下载）使用方式：dump.py xxx -uroot -P123456\n不行就多试几次结束后会得到ipa安装包，使用 7z x xxx.ipa进行解压找到最大可执行文件\n可以使用ida打开，ida64 Gkfb\n通过命令行获取设备信息，类似adb安装地址：https://libimobiledevice.org/#get-started遇到安装失败，更新一下 apt-get update使用命令查看 https://github.com/libimobiledevice/libimobiledevice\napt install ideviceinstallerhttps://github.com/libimobiledevice/ideviceinstaller其他功能可以查看他的其他项目\n","tags":["iOS"]},{"title":"iOS逆向系列(二) 反调试与绕过案例实战","url":"/posts/51299/","content":"项目地址：https://github.com/cherubstar/iOSEnvDetection根据项目使用Xcode构建app安装到手机上iPhone：iPhone se2(越狱)，iOS 14.4.1\nFrida检测端口检测上来先用objection搜索有没有frida相关的类，可以看到其中FridaDetection比较符合，对其hook\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking search classes fridaEnvDetection.FridaDetectionViewModel_TtGC7SwiftUIP10$1a5ddeda09BoxVTableVGVS_11StateObjectC12EnvDetection23FridaDetectionViewModel_P10$1a5d8f8983Box__TtGC7SwiftUIP10$1a5ddeda09BoxVTableGVS_P10$1a5db422825ObservedObjectPropertyBoxC12EnvDetection23FridaDetectionViewModel__FridaDetectionFound 4 classescom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking list class_methods FridaDetection- checkListeningPort27042Found 1 methods\n只有 checkListeningPort27042 一个函数，hook查看调用栈返回值\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking watch method &quot;*[FridaDetection checkListeningPort27042]&quot; --dump-args --dump-backtrace --dump-return(agent) Found selector at 0x102034000 as -[FridaDetection checkListeningPort27042](agent) Registering job 246950. Type: watch-method for: *[FridaDetection checkListeningPort27042]com.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # (agent) [246950] Called: *[FridaDetection checkListeningPort27042] 0 arguments(Kind: instance) (Super: NSObject)(agent) [246950] *[FridaDetection checkListeningPort27042] Backtrace:        0x102051240 EnvDetection!FridaDetectionViewModel.checkListeningPort27042()        0x1020865d4 EnvDetection!closure #2 in closure #1 in closure #1 in FridaDetectionView.body.getter        0x1a56f0e30 SwiftUI!partial apply for implicit closure #2 in implicit closure #1 in WrappedButtonStyle.Body.body.getter        0x1a5a07f28 SwiftUI!closure #1 in PressableGestureCallbacks.dispatch(phase:state:)        0x1a5771b98 SwiftUI!thunk for @escaping @callee_guaranteed () -&gt; ()        0x1a5771bc0 SwiftUI!thunk for @escaping @callee_guaranteed () -&gt; (@out ())        0x1a5771b98 SwiftUI!thunk for @escaping @callee_guaranteed () -&gt; ()        0x1a5760764 SwiftUI!static Update.end()        0x1a57b2e6c SwiftUI!EventBindingManager.send(_:)        0x1a5c3fe50 SwiftUI!specialized EventBindingBridge.send(_:source:)        0x1a5c3df28 SwiftUI!UIKitGestureRecognizer.send(touches:event:phase:)        0x1a5c3ebe0 SwiftUI!@objc UIKitGestureRecognizer.touchesBegan(_:with:)        0x1a11cad2c UIKitCore!-[UIGestureRecognizer _componentsEnded:withEvent:]        0x1a171325c UIKitCore!-[UITouchesEvent _sendEventToGestureRecognizer:]        0x1a11c0bd4 UIKitCore!__47-[UIGestureEnvironment _updateForEvent:window:]_block_invoke        0x1a11c08b4 UIKitCore!-[UIGestureEnvironment _updateForEvent:window:](agent) [246950] Return Value: 0x1\n返回了0x1，那是不是把函数返回值改为0x0，就不会被检测到\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking set return_value &quot;*[FridaDetection checkListeningPort27042]&quot; 0x0\n再点击检测则过掉了frida代码\nfunction main()&#123;    Interceptor.attach(ObjC.classes[&quot;FridaDetection&quot;][&quot;- checkListeningPort27042&quot;].implementation, &#123;        onEnter: function(args)&#123;        &#125;, onLeave: function(ret)&#123;            console.log(&quot;ret =&gt;&quot;, ret);            ret.replace(new NativePointer(0x0))        &#125;    &#125;)&#125;setImmediate(main)\n文件检测既然是文件检测，那肯定涉及到文件的读取，查资料把文件操作相关的类都用objection查找一遍，最终得到是 NSFileManager 类，进行hook\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking watch class NSFileManager\n手机Frida文件检测刷新一下\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # (agent) [703964] Called: [NSFileManager defaultManager] (Kind: class) (Super: NSObject)(agent) [703964] Called: [NSFileManager _registerForUbiquityAccountChangeNotifications] (Kind: instance) (Super: NSObject)(agent) [703964] Called: [NSFileManager defaultManager] (Kind: class) (Super: NSObject)(agent) [703964] Called: [NSFileManager _registerForUbiquityAccountChangeNotifications] (Kind: instance) (Super: NSObject)(agent) [703964] Called: [NSFileManager defaultManager] (Kind: class) (Super: NSObject)(agent) [703964] Called: [NSFileManager _registerForUbiquityAccountChangeNotifications] (Kind: instance) (Super: NSObject)\n对这两个函数进行hook查看调用栈返回值\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking watch method &quot;*[NSFileManager _registerForUbiquityAccountChangeNotifications]&quot; --dump-args --dump-backtrace --dump-return(agent) Found selector at 0x19feee6b0 as -[NSFileManager _registerForUbiquityAccountChangeNotifications](agent) Registering job 536962. Type: watch-method for: *[NSFileManager _registerForUbiquityAccountChangeNotifications]com.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking watch method &quot;*[NSFileManager defaultManager]&quot; --dump-args --dump-backtrace --dump-return(agent) Found selector at 0x19feec534 as +[NSFileManager defaultManager](agent) Registering job 371228. Type: watch-method for: *[NSFileManager defaultManager]com.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # (agent) [371228] Called: *[NSFileManager defaultManager] 0 arguments(Kind: class) (Super: NSObject)(agent) [371228] *[NSFileManager defaultManager] Backtrace:        0x1a000f3d4 Foundation!standardDefaultCenter        0x1a199dc5c UIKitCore!-[UITextEffectsWindow updateForOrientation:forceResetTransform:]        0x1a199e2f0 UIKitCore!+[UITextEffectsWindow _sharedTextEffectsWindowforWindowScene:allowHosted:matchesStatusBarOrientationOnAccess:shouldCreateIfNecessary:]        0x1a199e3fc UIKitCore!+[UITextEffectsWindow sharedTextEffectsWindowForWindowScene:]        0x1a10c640c UIKitCore!-[UIInputResponderController containerWindow]        0x1a10c651c UIKitCore!-[UIInputResponderController containerRootController]        0x1a149a1a8 UIKitCore!-[UIPeripheralHost(UIKitInternal) _isTransitioning]        0x1a0fa219c UIKitCore!-[_UINavigationInteractiveTransition _gestureRecognizer:shouldReceiveEvent:]        0x1a11cfd54 UIKitCore!-[UIGestureRecognizer _delegateShouldReceiveEvent:]        0x1a11cf3f4 UIKitCore!-[UIGestureRecognizer _shouldReceiveTouch:forEvent:recognizerView:]        0x1a171234c UIKitCore!__72-[UITouchesEvent _addGestureRecognizersForView:toTouch:forContinuation:]_block_invoke        0x1a1711cf8 UIKitCore!__62-[UITouchesEvent _collectGestureRecognizersForView:withBlock:]_block_invoke        0x1a1711784 UIKitCore!-[UITouchesEvent _collectGestureRecognizersForView:withBlock:]        0x1a17121b8 UIKitCore!-[UITouchesEvent _addGestureRecognizersForView:toTouch:forContinuation:]        0x1a1712074 UIKitCore!-[UITouchesEvent _addGestureRecognizersForView:toTouch:]        0x1a1712690 UIKitCore!-[UITouchesEvent _addTouch:forDelayedDelivery:](agent) [371228] Return Value: 0x283a77540(agent) [536962] Called: *[NSFileManager _registerForUbiquityAccountChangeNotifications] 0 arguments(Kind: instance) (Super: NSObject)(agent) [536962] *[NSFileManager _registerForUbiquityAccountChangeNotifications] Backtrace:        0x1a000f3e0 Foundation!standardDefaultCenter        0x1a199dc5c UIKitCore!-[UITextEffectsWindow updateForOrientation:forceResetTransform:]        0x1a199e2f0 UIKitCore!+[UITextEffectsWindow _sharedTextEffectsWindowforWindowScene:allowHosted:matchesStatusBarOrientationOnAccess:shouldCreateIfNecessary:]        0x1a199e3fc UIKitCore!+[UITextEffectsWindow sharedTextEffectsWindowForWindowScene:]        0x1a10c640c UIKitCore!-[UIInputResponderController containerWindow]        0x1a10c651c UIKitCore!-[UIInputResponderController containerRootController]        0x1a149a1a8 UIKitCore!-[UIPeripheralHost(UIKitInternal) _isTransitioning]        0x1a0fa219c UIKitCore!-[_UINavigationInteractiveTransition _gestureRecognizer:shouldReceiveEvent:]        0x1a11cfd54 UIKitCore!-[UIGestureRecognizer _delegateShouldReceiveEvent:]        0x1a11cf3f4 UIKitCore!-[UIGestureRecognizer _shouldReceiveTouch:forEvent:recognizerView:]        0x1a171234c UIKitCore!__72-[UITouchesEvent _addGestureRecognizersForView:toTouch:forContinuation:]_block_invoke        0x1a1711cf8 UIKitCore!__62-[UITouchesEvent _collectGestureRecognizersForView:withBlock:]_block_invoke        0x1a1711784 UIKitCore!-[UITouchesEvent _collectGestureRecognizersForView:withBlock:]        0x1a17121b8 UIKitCore!-[UITouchesEvent _addGestureRecognizersForView:toTouch:forContinuation:]        0x1a1712074 UIKitCore!-[UITouchesEvent _addGestureRecognizersForView:toTouch:]        0x1a1712690 UIKitCore!-[UITouchesEvent _addTouch:forDelayedDelivery:]\n看了调用栈都是跟系统相关的，底层会去调用libc下的open函数，frida hook open函数\nfunction hook_libc_open()&#123;    var openAddr = Module.findExportByName(null, &quot;open&quot;);    Interceptor.attach(openAddr, &#123;        onEnter: function(args) &#123;            console.log(&quot;path =&gt;&quot;, args[0].readCString());            console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n\\t&quot;))        &#125;, onLeave: function(retval)&#123;            console.log(retval)        &#125;    &#125;)&#125;\n[iOS Device::EnvDetection ]-&gt; path =&gt; /usr/lib/frida/frida-server0x100486284 EnvDetection!-[FileAndFolderPathDetection checkPathByOpen:]        0x1004d8978 EnvDetection!CommonUtils.checkPath(path:)        0x1004af724 EnvDetection!closure #1 in closure #1 in closure #1 in FridaFileDetectionView.body.getter        0x1a5c0a280 SwiftUI!HStack.init(alignment:spacing:content:)        0x1004af280 EnvDetection!closure #1 in closure #1 in FridaFileDetectionView.body.getter        0x1a5b0ee74 SwiftUI!ForEachChild.updateValue()        0x1a562d7fc SwiftUI!partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;(_:)        0x1c8168a50 AttributeGraph!AG::Graph::UpdateStack::update()        0x1c8168e84 AttributeGraph!AG::Graph::update_attribute(AG::data::ptr&lt;AG::Node&gt;, bool)        0x1c8172088 AttributeGraph!AG::Subgraph::update(unsigned int)        0x1a5c80cdc SwiftUI!GraphHost.runTransaction()        0x1a5c83e1c SwiftUI!GraphHost.runTransaction(_:)        0x1a5c827a8 SwiftUI!GraphHost.flushTransactions()        0x1a5c83db4 SwiftUI!closure #1 in closure #1 in GraphHost.asyncTransaction&lt;A&gt;(_:mutation:style:)        0x1a5752168 SwiftUI!partial apply for closure #1 in ViewGraphDelegate.updateGraph&lt;A&gt;(body:)        0x1a5bd5e9c SwiftUI!closure #1 in ViewRendererHost.updateViewGraph&lt;A&gt;(body:)0xffffffffffffffff\n这里调用了open的只有 &#x2F;usr&#x2F;lib&#x2F;frida&#x2F;frida-server 未发现的文件，看它的调用栈上一级[FileAndFolderPathDetection checkPathByOpen:] 很像是检测路径的，objection hook一下\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking watch class FileAndFolderPathDetection(agent) Watching method: - checkPathByNSFileManager:(agent) Watching method: - checkPathByAccess:(agent) Watching method: - checkPathByStat:(agent) Watching method: - checkPathByLstat:(agent) Watching method: - checkPathByStatfs:(agent) Watching method: - checkPathByOpen:(agent) Watching method: - checkPathByFopen:(agent) Registering job 393195. Type: watch-class-methods for: FileAndFolderPathDetectioncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # (agent) [393195] Called: [FileAndFolderPathDetection checkPathByNSFileManager:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByAccess:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByNSFileManager:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByAccess:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByStat:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByLstat:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByStatfs:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByOpen:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByFopen:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByNSFileManager:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByNSFileManager:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByNSFileManager:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByNSFileManager:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByNSFileManager:] (Kind: instance) (Super: NSObject)(agent) [393195] Called: [FileAndFolderPathDetection checkPathByNSFileManager:] (Kind: instance) (Super: NSObject)\n这里使用frida对FileAndFolderPathDetection的所有函数进行hook，打印一下参数返回值\nfunction print_arguments(args) &#123;    var n = 100;    var last_arg = &#x27;&#x27;;    for (var i = 2; i &lt; n; ++i) &#123;        var arg = (new ObjC.Object(args[i])).toString();        if (arg == &#x27;nil&#x27; || arg == last_arg) &#123;            break;        &#125;        last_arg = arg;        return &#x27; args&#x27; + (i-2) + &#x27;: &#x27; + (new ObjC.Object(args[i])).toString()    &#125;&#125;function IosTraceClass(targetClass) &#123;    console.log(&quot;Entering ios hooking =&gt; &quot; + targetClass)    if (ObjC.classes.hasOwnProperty(targetClass)) &#123;        var methods = ObjC.classes[targetClass].$ownMethods;        methods.forEach(function (method) &#123;            console.log(&quot;hooking &quot; + method);            try &#123;                Interceptor.attach(ObjC.classes[targetClass][method].implementation, &#123;                    onEnter: function (args) &#123;                        this.output = &quot;&quot;                        this.output = this.output.concat(&quot;[*] Detected call to: &quot; + targetClass + &quot; -&gt; &quot; + method)                        this.output = this.output.concat(&quot;\\r\\n&quot;)                        this.output = this.output.concat(print_arguments(args))                    &#125;, onLeave: function (ret) &#123;                        this.output = this.output.concat(&quot;\\r\\nios return value =&gt; &quot;, ret, &quot;\\r\\n&quot;)                        console.log(this.output)                        // ret.replace(new NativePointer(0x0)); // 修改返回值                    &#125;                &#125;)            &#125; catch (error) &#123;                console.log(&quot;ios hooking failed error is =&gt; &quot;, error)            &#125;        &#125;)    &#125;&#125;function traceClass(targetClass) &#123;    if (ObjC.available) &#123;        IosTraceClass(targetClass)    &#125;&#125;function main() &#123;    traceClass(&quot;FileAndFolderPathDetection&quot;)&#125;\n[iOS Device::EnvDetection ]-&gt; [*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByNSFileManager: args0: /usr/sbin/frida-serverios return value =&gt; 0x0[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByAccess: args0: /usr/sbin/frida-serverios return value =&gt; 0x1 [*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByNSFileManager: args0: /usr/lib/frida/frida-serverios return value =&gt; 0x0[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByAccess: args0: /usr/lib/frida/frida-serverios return value =&gt; 0x0[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByStat: args0: /usr/lib/frida/frida-serverios return value =&gt; 0x0[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByLstat: args0: /usr/lib/frida/frida-serverios return value =&gt; 0x0[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByStatfs: args0: /usr/lib/frida/frida-serverios return value =&gt; 0x0[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByOpen: args0: /usr/lib/frida/frida-serverios return value =&gt; 0x0[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByFopen: args0: /usr/lib/frida/frida-serverios return value =&gt; 0x0[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByNSFileManager: args0: /usr/lib/frida/frida-agent.dylibios return value =&gt; 0x1[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByNSFileManager: args0: /Library/LaunchDaemons/re.frida.server.plistios return value =&gt; 0x1[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByNSFileManager: args0: /Library/dpkg/info/re.frida.server.extrainst_ios return value =&gt; 0x1[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByNSFileManager: args0: /Library/dpkg/info/re.frida.server.listios return value =&gt; 0x1[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByNSFileManager: args0: /Library/dpkg/info/re.frida.server.prermios return value =&gt; 0x1[*] Detected call to: FileAndFolderPathDetection -&gt; - checkPathByNSFileManager: args0: /Library/dpkg/info/re.frida.server.md5sumsios return value =&gt; 0x1\n跟上面的图对照可以发现返回值是0x1的就是检测到的，所以修改所有函数的返回值为0x0，上面代码30行去掉注释，再次运行就全过掉了。\n越狱检测其中文件&#x2F;目录检测，插件APP检测也都是同上面frida文件检测，也是同样过掉了。\n代理检测代理APP检测我设备下载还打开了Shadowrocket，不知道为什么代理APP检测测出来。也是objection查找类试了好几个关键词 proxy，network出来很多个类，既然它APP检测有Shadowrocket，直接ida打开搜索字符串下载app压缩包：https://github.com/cherubstar/iOSEnvDetection/releases/download/1.3/EnvDetection.app.zip解压后用ida打开EnvDetection菜单View-&gt;Open subviews-&gt;Strings 查找Shadowrocket会找到 Shadowrocket.app，按x查找引用，跳到引用的地方\n__text:0000000100005618 A2 03 00 B0 42 20 0E 91       ADRL            X2, cfstr_HttpcatcherApp ; &quot;HttpCatcher.app&quot;__text:0000000100005620 E8 03 00 91                   MOV             X8, SP__text:0000000100005624 E8 57 00 F9                   STR             X8, [SP,#0x1E0+var_138]__text:0000000100005628 A9 03 00 B0 29 A1 0E 91       ADRL            X9, cfstr_KitsunebiApp  ; &quot;Kitsunebi.app&quot;__text:0000000100005630 09 01 00 F9                   STR             X9, [X8,#0x1E0+var_1E0]__text:0000000100005634 A9 03 00 B0 29 21 0F 91       ADRL            X9, cfstr_PotatsoApp    ; &quot;Potatso.app&quot;__text:000000010000563C 09 05 00 F9                   STR             X9, [X8,#0x1E0+var_1D8]__text:0000000100005640 A9 03 00 B0 29 A1 0F 91       ADRL            X9, cfstr_QuantumultApp ; &quot;Quantumult.app&quot;__text:0000000100005648 09 09 00 F9                   STR             X9, [X8,#0x1E0+var_1D0]__text:000000010000564C A9 03 00 B0 29 21 10 91       ADRL            X9, cfstr_QuantumultXApp ; &quot;Quantumult X.app&quot;__text:0000000100005654 09 0D 00 F9                   STR             X9, [X8,#0x1E0+var_1C8]__text:0000000100005658 A9 03 00 B0 29 A1 10 91       ADRL            X9, cfstr_ShadowrocketAp ; &quot;Shadowrocket.app&quot;__text:0000000100005660 09 11 00 F9                   STR             X9, [X8,#0x1E0+var_1C0]__text:0000000100005664 A9 03 00 B0 29 21 11 91       ADRL            X9, cfstr_SurgeIosApp   ; &quot;Surge-iOS.app&quot;__text:000000010000566C 09 15 00 F9                   STR             X9, [X8,#0x1E0+var_1B8]__text:0000000100005670 A9 03 00 B0 29 A1 11 91       ADRL            X9, cfstr_ThorApp       ; &quot;Thor.app&quot;\n按tab跳到代码页面，发现函数名是 -[AgentDetection checkAgentAppIsInstalled](AgentDetection *self, SEL a2)，使用objection hook\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking watch method &quot;-[AgentDetection checkAgentAppIsInstalled]&quot; --dump-args --dump-backtrace --dump-return(agent) Found selector at 0x1026b8f34 as -[AgentDetection checkAgentAppIsInstalled](agent) Registering job 473143. Type: watch-method for: -[AgentDetection checkAgentAppIsInstalled]com.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # (agent) [473143] Called: -[AgentDetection checkAgentAppIsInstalled] 0 arguments(Kind: instance) (Super: NSObject)(agent) [473143] -[AgentDetection checkAgentAppIsInstalled] Backtrace:        0x1026da35c EnvDetection!AgentDetectionViewModel.isInstalled()        0x10270d8ac EnvDetection!closure #1 in AgentApplicationDetectionView.body.getter        0x197e23a60 SwiftUI!List&lt;&gt;.init(content:)        0x10270d3c0 EnvDetection!AgentApplicationDetectionView.body.getter        0x10270ef98 EnvDetection!protocol witness for View.body.getter in conformance AgentApplicationDetectionView        0x197b35b8c SwiftUI!partial apply for closure #1 in ViewBodyAccessor.updateBody(of:changed:)        0x197e8e248 SwiftUI!closure #1 in BodyAccessor.setBody(_:)        0x197b2f328 SwiftUI!ViewBodyAccessor.updateBody(of:changed:)        0x197e8e6d4 SwiftUI!DynamicBody.updateValue()        0x197b557fc SwiftUI!partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;(_:)        0x1ba690a50 AttributeGraph!AG::Graph::UpdateStack::update()        0x1ba690e84 AttributeGraph!AG::Graph::update_attribute(AG::data::ptr&lt;AG::Node&gt;, bool)        0x1ba696588 AttributeGraph!AG::Graph::input_value_ref_slow(AG::data::ptr&lt;AG::Node&gt;, AG::AttributeID, unsigned int, AGSwiftMetadata const*, bool*, long)        0x1ba6a85bc AttributeGraph!AGGraphGetValue        0x197fa11c4 SwiftUI!EnvironmentReadingChild.updateValue()        0x197b557fc SwiftUI!partial apply for implicit closure #2 in implicit closure #1 in closure #1 in closure #1 in Attribute.init&lt;A&gt;(_:)(agent) [473143] Return Value: 0x281954120\n没啥有用的信息，在ida的伪代码找到了调用 AppInfo的listInstalledApps\nv26 = (id)objc_alloc_init(&amp;OBJC_CLASS___AppInfo);v5 = objc_msgSend(v26, &quot;listInstalledApps&quot;);\n直接函数列表过滤查看listInstalledApps的实现，查看代码找到，对其hook\nv2 = -[AppInfo fetchApps](self, &quot;fetchApps&quot;);\nfunction hook_fetchApps()&#123;    Interceptor.attach(ObjC.classes[&quot;AppInfo&quot;][&quot;- fetchApps&quot;].implementation, &#123;        onEnter: function(args)&#123;            console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n\\t&quot;))        &#125;, onLeave: function(ret)&#123;            console.log(&quot;ret value is =&gt; &quot;,ret, &quot;=&gt;&quot;, ObjC.Object(ret), &quot;=&gt;&quot;, ObjC.Object(ret).$className);            // var emptyNSArray = Objc.classes.NSArray[&#x27;new&#x27;]();            // ret.replace(emptyNSArray);        &#125;    &#125;)&#125;\n调用栈里找到了 -[AgentDetection checkAgentAppIsInstalled]，这个返回值是NSArray，返回一份不包含任何关键app的NSArray给它即可。为了通用，直接创建一个空的NSArray返回给fetchApps，Objc.classes.NSArray‘new’，去掉7，8行注释即可\n常规代理检测用objection看一下AgentDetection函数\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # ios hooking list class_methods AgentDetection- checkAgentAppIsInstalled- checkProxyStatusByCFNetworkCopySystemProxySettings- getCFNetworkCopySystemProxySettingsDetails- setConnectionProxyDictionary\n看输出的函数名后面3个检测代理的，其中常规代理检测会调用checkProxyStatusByCFNetworkCopySystemProxySettings，直接hook\ncom.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # (agent) [237829] Called: *[AgentDetection checkProxyStatusByCFNetworkCopySystemProxySettings] 0 arguments(Kind: instance) (Super: NSObject)(agent) [237829] Return Value: 0x0// 开启代理后com.zsk.EnvDetection on (iPhone: 14.4.1) [usb] # (agent) [237829] Called: *[AgentDetection checkProxyStatusByCFNetworkCopySystemProxySettings] 0 arguments(Kind: instance) (Super: NSObject)(agent) [237829] Return Value: 0x1\n则直接修改其返回值为0x0即可\nfunction hook_checkSystemProxy()&#123;    Interceptor.attach(ObjC.classes[&quot;AgentDetection&quot;][&quot;- checkProxyStatusByCFNetworkCopySystemProxySettings&quot;].implementation, &#123;        onEnter: function(args)&#123;        &#125;, onLeave: function(ret)&#123;            ret.replace(new NativePointer(0x0))        &#125;    &#125;)&#125;\n设置代理检测变量如果使用WiFi 代理抓包，会发现请求发不出去，charles也抓不到任何包如果使用vpn代理的话，以Shadowrocket为例，Shadowrocket 的作用是代理转发，vpn代理是处于网络层的，可以抓到更多的数据包，也可以过掉代理检测。一般抓包也推荐使用vpn代理\n调试检测常规反调试函数\nptrace用的是ptrace来检测，一个进程同时只能被另外一个进程调试，所以这里开了ptrace后，其它调试工具xcode，lldb就没法对其进行调试没打开ptrace是可以调试上的打开后调试则报错了ptrace 是系统函数，那直接hook\nint ptrace(int _request, pid _pid, caddr_t _addr, int _data);\nfunction hook_ptrace()&#123;    var ptraceAddr = Module.findExportByName(null, &#x27;ptrace&#x27;);    Interceptor.replace(ptraceAddr, new NativeCallback(function(i1, i2, i3, i4)&#123;        console.log(&quot;ptrace flag is =&gt; &quot;, i1);       &#125;, &#x27;void&#x27;, [&#x27;int&#x27;, &#x27;int&#x27;, &#x27;int&#x27;, &#x27;int&#x27;]))&#125;\n不让ptrace函数执行就行了，直接置空不做任何操作再次打开ptrace用xcode附加调试则没有报错现象了\nptrace+svc在 iOS 反动态调试中,常用 svc #0x80 汇编指令来实现对 ptrace 和 syscall 系统调用的直接调用。通过这种方式,可以规避标准库提供的 ptrace() 函数,直接触发系统调用,增加反调试的难度,使得 lldb 无法正常附加到 app 进程。svc #0x80 指令等同于 syscall() 函数在 C 语言中的使用,都是直接触发系统调用,而不会走标准库函数的包装。当开启ptrace+svc后上面的hook函数没触发，查看它的源码也可以看到\n- (void)ori_ptrace &#123;    ptrace(PT_DENY_ATTACH, 0, 0, 0);&#125;// 等价于- (void)svc_ptrace &#123;#ifdef __arm64__    __asm__(&quot;mov X0, #31\\n&quot;            &quot;mov X1, #0\\n&quot;            &quot;mov X2, #0\\n&quot;            &quot;mov X3, #0\\n&quot;            &quot;mov w16, #26\\n&quot;            &quot;svc #0x80&quot;);#endif&#125;\n也可以用直接ida打开搜索 SVC搜索结果跟进查看\n__text:0000000100006028                               ; void __cdecl -[DebugDetection svc_ptrace](DebugDetection *self, SEL)__text:0000000100006028                               __DebugDetection_svc_ptrace_            ; DATA XREF: __objc_methlist:0000000100067FEC↓o__text:0000000100006028__text:0000000100006028                               var_10= -0x10__text:0000000100006028                               var_8= -8__text:0000000100006028__text:0000000100006028 FF 43 00 D1                   SUB             SP, SP, #0x10__text:000000010000602C E0 07 00 F9                   STR             X0, [SP,#0x10+var_8]__text:0000000100006030 E1 03 00 F9                   STR             X1, [SP,#0x10+var_10]__text:0000000100006034 E0 03 80 D2                   MOV             X0, #0x1F__text:0000000100006038 01 00 80 D2                   MOV             X1, #0__text:000000010000603C 02 00 80 D2                   MOV             X2, #0__text:0000000100006040 03 00 80 D2                   MOV             X3, #0__text:0000000100006044 50 03 80 52                   MOV             W16, #0x1A__text:0000000100006048 01 10 00 D4                   SVC             0x80__text:000000010000604C FF 43 00 91                   ADD             SP, SP, #0x10__text:0000000100006050 C0 03 5F D6                   RET\n汇编指令跟源码差不多方式一可以使用patch的方式，修改 svc #0x80，在IDA View-A界面中选中svc那一行，点击工具栏Edit–&gt;Patch program–&gt;Change Bytes，弹出修改框，将01 10 00 D4修改为nop的byte码 1F 20 03 D5(如何知道nop的byte码，寻找一个nop，change byte就可以了)将patch修改保存到程序里去，点击工具栏Edit–&gt;Patch program–&gt;Apply patches to input file然后重签名打包安装就可以了方式二直接用frida对 -[DebugDetection svc_ptrace]这个函数置空不执行，这是ObjC的函数，写法跟上面的不一样\nfunction hook_svc_ptrace()&#123;    const DebugDetection = ObjC.classes.DebugDetection;    const svc_ptrace = DebugDetection[&#x27;- svc_ptrace&#x27;]    const oldImpl = svc_ptrace.implementation;    svc_ptrace.implementation = ObjC.implement(svc_ptrace, (handle, selector) =&gt; &#123;        console.log(handle, selector);        // oldImpl(handle, selector);  // 旧函数运行    &#125;)&#125;\n只要不执行原函数就行了到这里其实都是要找函数位置去hook返回值或者置空达到的反调试效果，那当代码混淆以及代码膨，使得想要快速定位svc 0x80调用并将其patch掉就变得难以实现。可以查看大佬的文章：https://bbs.kanxue.com/thread-273796.htm\nptrace+xor通过ida查找到对应函数\nvoid __cdecl -[DebugDetection xor_ptrace](DebugDetection *self, SEL a2)&#123;  char v2; // w8  void *__handle; // [xsp+10h] [xbp-30h]  void *v4; // [xsp+18h] [xbp-28h]  _BYTE *i; // [xsp+20h] [xbp-20h]  _DWORD __symbol[2]; // [xsp+28h] [xbp-18h] BYREF  SEL v7; // [xsp+30h] [xbp-10h]  DebugDetection *v8; // [xsp+38h] [xbp-8h]  v8 = self;  v7 = a2;  __symbol[0] = 268633345;  *(_DWORD *)((char *)__symbol + 3) = 1897140752;  for ( i = __symbol; ; ++i )  &#123;    v2 = *i ^ 0x71;    *i = v2;    if ( !v2 )      break;  &#125;  __handle = dlopen(0LL, 10);  v4 = dlsym(__handle, (const char *)__symbol);  ((void (__fastcall *)(__int64, _QWORD, _QWORD))v4)(31LL, 0LL, 0LL);  dlclose(__handle);&#125;\n这里使用了 dlsym() 函数从动态链接库中查找 ptrace 函数的符号地址，进行调用，用上面的hook就可以了查看了它的源码\n- (void)xor_ptrace &#123;    //A 异或 B 等到 C,C 再异或 A 得到 B,隐藏 ptrace    unsigned char str[] = &#123;        (&#x27;q&#x27; ^ &#x27;p&#x27;),        (&#x27;q&#x27; ^ &#x27;t&#x27;),        (&#x27;q&#x27; ^ &#x27;r&#x27;),        (&#x27;q&#x27; ^ &#x27;a&#x27;),        (&#x27;q&#x27; ^ &#x27;c&#x27;),        (&#x27;q&#x27; ^ &#x27;e&#x27;),        (&#x27;q&#x27; ^ &#x27;\\0&#x27;)    &#125;;    unsigned char *p = str;    while (((*p) ^= &#x27;q&#x27;) != &#x27;\\0&#x27;)        p++;    int (*ptrace_ptr)(int _request, pid_t _pid, caddr_t _addr, int _data);    void *handle = dlopen(0, RTLD_GLOBAL | RTLD_NOW);   // 获得句柄    ptrace_ptr = dlsym(handle, (const char *)str);      // 动态查找 ptrace 符号    ptrace_ptr(PT_DENY_ATTACH, 0, 0, 0);    dlclose(handle);&#125;\n定义一个 str 数组, 拼接成ptrace字符串，最终会对 ptrace 函数进行调用\nsyscallida查看代码后去调用了系统函数syscall\nvoid __cdecl -[DebugDetection ori_syscall](DebugDetection *self, SEL a2)&#123;  syscall(26, 31LL, 0LL, 0LL, 0LL, a2, self);&#125;\nsyscall的定义如下\nlong syscall(long number, ...);\nfunction hook_syscall()&#123;    var syscallAddr = Module.findExportByName(null, &#x27;syscall&#x27;);    Interceptor.replace(syscallAddr, new NativeCallback(function(i1)&#123;        console.log(&quot;syscall flag is =&gt; &quot;, i1);       &#125;, &#x27;void&#x27;, [&#x27;int&#x27;]))&#125;\nsyscall+svcptrace+svc 的hook改一下就可以\nsyscall+xor同syscall\nsysctl同样找到代码位置\nint __cdecl -[DebugDetection ori_sysctl](DebugDetection *self, SEL a2)&#123;  size_t v3[3]; // [xsp+18h] [xbp-2C8h] BYREF  char v4[32]; // [xsp+30h] [xbp-2B0h] BYREF  int v5; // [xsp+50h] [xbp-290h]  int v6[4]; // [xsp+2B8h] [xbp-28h] BYREF  v3[2] = (size_t)self;  v3[1] = (size_t)a2;  v6[0] = 1;  v6[1] = 14;  v6[2] = 1;  v6[3] = getpid();  v3[0] = 648LL;  v5 = 0;  sysctl(v6, 4u, v4, v3, 0LL, 0LL);  return (v5 &amp; 0x800) != 0;&#125;\nint sysctl(int *name, int namelen, void *oldval, size_t *oldlenp, void *newval, size_t newlen);\nhook代码同上面的差不多sysctl+svc和sysctl+xor都跟上面的也差不多\n","tags":["iOS"]},{"title":"绕过libsscronet.so app sslpinning","url":"/posts/34757/","content":"下了一个app，抓包后发现有ssl校验\nhttps://github.com/WooyunDota/DroidSSLUnpinning/blob/master/ObjectionUnpinningPlus/hooks.js试了这个unsslpinning脚本，把常用的网络框架都给hook上了也是没用,dump证书也是一样失败既然都抓不到那试试r0capture从上一层ssl抓包看看, hook了更深层次点的函数SSL_write也发现没有调用这种既没走标准的http框架和系统ssl的请求，再深入一层就到libc的网络库了，SSL_write函数内部会调用libc提供的send、sendmsg或sendto函数来实际完成数据的网络传输，直接hook这三个函数，查看其调用栈\nfunction main()&#123;    var sendaddr = Module.findExportByName(null, &quot;send&quot;);    console.log(&quot;sendaddr: &quot; + sendaddr);    Interceptor.attach(sendaddr, &#123;        onEnter: function(args) &#123;            console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n\\t&quot;))            console.log(&quot;send called: &quot; + args[1]);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;send return: &quot; + retval);        &#125;    &#125;)    var sendmsgaddr = Module.findExportByName(null, &quot;sendmsg&quot;);    console.log(&quot;sendmsgaddr: &quot; + sendmsgaddr);    Interceptor.attach(sendmsgaddr, &#123;        onEnter: function(args) &#123;            console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n\\t&quot;))            console.log(&quot;sendmsg called: &quot; + hexdump(args[1]), args[2]);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;sendmsg return: &quot; + retval);        &#125;    &#125;)    var sendtoaddr = Module.findExportByName(null, &quot;sendto&quot;);    console.log(&quot;sendtoaddr: &quot; + sendtoaddr);    Interceptor.attach(sendtoaddr, &#123;        onEnter: function(args) &#123;            console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n\\t&quot;))            console.log(&quot;sendto called: &quot; + args[1], args[2]);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;sendto return: &quot; + retval);        &#125;    &#125;)&#125;setImmediate(main);\n...sendmsg called:              0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF7b488320b8  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................7b488320c8  08 21 83 48 7b 00 00 00 02 00 00 00 00 00 00 00  .!.H&#123;...........7b488320d8  f0 20 83 48 7b 00 00 00 18 00 00 00 00 00 00 00  . .H&#123;...........7b488320e8  00 00 00 00 00 00 00 00 14 00 00 00 00 00 00 00  ................7b488320f8  01 00 00 00 01 00 00 00 45 01 00 00 00 00 00 00  ........E.......7b48832108  a0 21 83 48 7b 00 00 00 0c 00 00 00 00 00 00 00  .!.H&#123;...........7b48832118  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................7b48832128  56 32 7d 8d a4 6c 62 5f 00 00 00 00 00 00 00 00  V2&#125;..lb_........7b48832138  80 c9 dd 4d 7b 00 00 00 88 35 83 48 7b 00 00 00  ...M&#123;....5.H&#123;...7b48832148  88 35 83 48 7b 00 00 00 68 24 83 48 7b 00 00 00  .5.H&#123;...h$.H&#123;...7b48832158  10 00 00 00 00 00 00 00 00 7b 27 6c 7b 00 00 00  .........&#123;&#x27;l&#123;...7b48832168  45 01 00 00 00 00 00 00 10 22 83 48 7b 00 00 00  E........&quot;.H&#123;...7b48832178  30 a3 6a f8 7b 00 00 00 88 35 83 48 7b 00 00 00  0.j.&#123;....5.H&#123;...7b48832188  88 35 83 48 7b 00 00 00 46 01 00 00 7b 00 00 00  .5.H&#123;...F...&#123;...7b48832198  60 c8 8e 50 7b 00 00 00 01 00 00 00 00 00 00 00  `..P&#123;...........7b488321a8  00 00 00 00 7b 00 00 00 c0 21 83 48 7b 00 00 00  ....&#123;....!.H&#123;... 0x0sendmsg return: 0xc0x7bf86aa0a0 libnetd_client.so!_ZN12FwmarkClient4sendEP13FwmarkCommandiP17FwmarkConnectInfo+0x128        0x7bf86aa0a0 libnetd_client.so!_ZN12FwmarkClient4sendEP13FwmarkCommandiP17FwmarkConnectInfo+0x128        0x7bf86aa42c libnetd_client.so!0x142c        0x7b4afcbd18 libsscronet.so!0x305d18        0x7b4afcbd18 libsscronet.so!0x305d18...\n其中libnetd_client.so是系统库，就只能怀疑请求是从 libsscronet.so 出来的了，好奇既然没用系统的ssl库，那是用了哪里的ssl库？尝试搜了以下app已加载的so库\nmarlin:/ # cat /proc/12902/maps |grep ssl                                                                                                                                                                                                    7b23df5000-7b23e49000 r--p 00000000 103:13 134190                        /data/app/com.f100.android-Hq36t_d8nNvaQKbyqrIsXA==/lib/arm64/libttboringssl.so7b28180000-7b281c8000 r--p 00000000 103:12 210                           /system/lib64/libssl.so7b4b795000-7b4b7e6000 r-xp 00000000 103:13 134190                        /data/app/com.f100.android-Hq36t_d8nNvaQKbyqrIsXA==/lib/arm64/libttboringssl.so7b4b7e6000-7b4b7e9000 r--p 00050000 103:13 134190                        /data/app/com.f100.android-Hq36t_d8nNvaQKbyqrIsXA==/lib/arm64/libttboringssl.so7b4b7e9000-7b4b7ea000 rw-p 00053000 103:13 134190                        /data/app/com.f100.android-Hq36t_d8nNvaQKbyqrIsXA==/lib/arm64/libttboringssl.so7b6d255000-7b6d298000 r-xp 00000000 103:12 210                           /system/lib64/libssl.so7b6d298000-7b6d29b000 r--p 00042000 103:12 210                           /system/lib64/libssl.so7b6d29b000-7b6d29c000 rw-p 00045000 103:12 210                           /system/lib64/libssl.so\n查了下这个boringssl是由 Google 开发和维护的 BoringSSL 项目的动态链接库文件，尝试hook boringssl中的SSL_write函数打印调用栈\nfunction hook_ssl()&#123;    var boringssl = Process.getModuleByName(&quot;libttboringssl.so&quot;);    var SSL_write = boringssl.findExportByName(&quot;SSL_write&quot;);    Interceptor.attach(SSL_write, &#123;        onEnter: function(args) &#123;            console.log(&quot;Calling SSL_write&quot;);            console.log(Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n\\t&quot;))            console.log(&quot;  ssl:&quot;, ptr(args[0]));            this.ssl = args[0].toString();            this.buf = ptr(args[1]);        &#125;,        onLeave: function(retval) &#123;            console.log(&quot;SSL_write returned:&quot;, retval.toInt32());            // const len = retval.toInt32();            // if (len &gt; 0) &#123;            //     console.log(&#x27;SSL_write\\n&#x27;, this.buf.readByteArray(len), &#x27;\\n&#x27;, &#x27;*&#x27;.repeat(120));            // &#125;        &#125;    &#125;);&#125;setImmediate(hook_ssl)\n...Calling SSL_write0x7b4af25308 libsscronet.so!0x25f308        0x7b4af25308 libsscronet.so!0x25f308        0x7b4af25308 libsscronet.so!0x25f308  ssl: 0x7b476c9f08SSL_write returned: 2861...\n可以看到 libsscronet.so 调用了 libttboringssl.so 的 SSL_write，到这里证实了上面请求从 libsscronet.so 发出的猜想在cronet库中搜索判断是否有调用boringssl中涉及证书验证的函数有两个函数比较可疑 SSL_CTX_set_custom_verify和SSL_CTX_set_reverify_on_resume定位到了调用的地方\nunsigned __int64 sub_25FF94()&#123;  unsigned __int64 v0; // x19  __int64 v1; // x0  __int64 v2; // x0  __int64 v3; // x0  __int64 v4; // x21  __int64 v5; // x0  v0 = atomic_load(&amp;qword_3C07F8);  if ( v0 &lt;= 1 )  &#123;    if ( (sub_1ED810(&amp;qword_3C07F8) &amp; 1) != 0 )    &#123;      v0 = sub_22BC9C(24LL);      *(_QWORD *)(v0 + 8) = 0LL;      *(_QWORD *)(v0 + 16) = 0LL;      CRYPTO_library_init();      *(_DWORD *)v0 = SSL_get_ex_new_index(0LL, 0LL, 0LL, 0LL, 0LL);      v1 = TLS_with_buffers_method();      v2 = SSL_CTX_new(v1);      sub_149BDC(v0 + 8, v2);      SSL_CTX_set_cert_cb(*(_QWORD *)(v0 + 8), sub_260114, 0LL);      SSL_CTX_set_reverify_on_resume();      SSL_CTX_set_custom_verify(*(_QWORD *)(v0 + 8), 1LL, sub_25F7E4);      SSL_CTX_set_session_cache_mode(*(_QWORD *)(v0 + 8), 769LL);      SSL_CTX_sess_set_new_cb(*(_QWORD *)(v0 + 8), sub_2602E4);      SSL_CTX_set_timeout(*(_QWORD *)(v0 + 8), 3600LL);      v3 = SSL_CTX_set_grease_enabled(*(_QWORD *)(v0 + 8), 1LL);      v4 = *(_QWORD *)(v0 + 8);      v5 = sub_2516C4(v3);      SSL_CTX_set0_buffer_pool(v4, v5);      SSL_CTX_set_msg_callback(*(_QWORD *)(v0 + 8), sub_2604B4);      SSL_CTX_add_cert_compression_alg(*(_QWORD *)(v0 + 8), 2LL, 0LL, sub_2605F4);      if ( (sub_1E60D4(&amp;off_3B7840) &amp; 1) != 0 )        SSL_CTX_set1_curves(*(_QWORD *)(v0 + 8), &amp;unk_B49B4, 4LL);      sub_1ED89C(&amp;qword_3C07F8, v0, 0LL, 0LL);    &#125;    else    &#123;      return atomic_load(&amp;qword_3C07F8);    &#125;  &#125;  return v0;&#125;\n这里也去Chrome Code Search搜索（在线的Chrome源码浏览网页，提供了强大的交叉引用和全文搜索功能）https://source.chromium.org/chromium看了SSL_CTX_set_reverify_on_resume源码也没什么\nvoid SSL_CTX_set_reverify_on_resume(SSL_CTX *ctx, int enabled) &#123;  ctx-&gt;reverify_on_resume = !!enabled;&#125;\n而且下一行就调用了SSL_CTX_set_custom_verify，所以重点放在SSL_CTX_set_custom_verify上搜索函数名SSL_CTX_set_custom_verify，定位到\nvoid SSL_CTX_set_custom_verify(    SSL_CTX *ctx, int mode,    enum ssl_verify_result_t (*callback)(SSL *ssl, uint8_t *out_alert)) &#123;  ctx-&gt;verify_mode = mode;  ctx-&gt;custom_verify_callback = callback;&#125;\n第一个参数应该是上下文管理SSL&#x2F;TLS的会话指针，第二个参数可以随便找调用 SSL_CTX_set_custom_verify 函数的地方，查看参数\n// SSL_VERIFY_NONE, on a client, verifies the server certificate but does not// make errors fatal. The result may be checked with |SSL_get_verify_result|. On// a server it does not request a client certificate. This is the default.#define SSL_VERIFY_NONE 0x00// SSL_VERIFY_PEER, on a client, makes server certificate errors fatal. On a// server it requests a client certificate and makes errors fatal. However,// anonymous clients are still allowed. See// |SSL_VERIFY_FAIL_IF_NO_PEER_CERT|.#define SSL_VERIFY_PEER 0x01// SSL_VERIFY_FAIL_IF_NO_PEER_CERT configures a server to reject connections if// the client declines to send a certificate. This flag must be used together// with |SSL_VERIFY_PEER|, otherwise it won&#x27;t work.#define SSL_VERIFY_FAIL_IF_NO_PEER_CERT 0x02// SSL_VERIFY_PEER_IF_NO_OBC configures a server to request a client certificate// if and only if Channel ID is not negotiated.#define SSL_VERIFY_PEER_IF_NO_OBC 0x04\n值为0x0时不校验证书，hook修改参数为0即可第三个参数是回调函数，就是上面的 SSL_CTX_set_custom_verify(*(_QWORD *)(v0 + 8), 1LL, sub_25F7E4);跟进刚才的源码enum ssl_verify_result_t，第三个参数回调函数的返回值就只有以下三种类型，\nenum ssl_verify_result_t BORINGSSL_ENUM_INT &#123;  ssl_verify_ok,  ssl_verify_invalid,  ssl_verify_retry,&#125;;\n看了一些调用的地方，ssl_verify_ok的值是0，所以可以hook回调函数修改返回值为0即可，就不用管函数内部在做什么了这个so会在加载后立即进行证书绑定的判断，只执行一次，所以需要在so加载的时候找到它，并且在so执行第一次的时候进行hookfrida hook代码\nfunction main()&#123;    var android_dlopen_ext = Module.findExportByName(null, &#x27;android_dlopen_ext&#x27;);    console.log(&quot;android_dlopen_ext: &quot;, android_dlopen_ext)    if (android_dlopen_ext != null) &#123;        Interceptor.attach(android_dlopen_ext, &#123;            onEnter: function(args)&#123;                var soName = args[0].readCString();                // console.log(soName)                if (soName.indexOf(&quot;libsscronet.so&quot;) != -1) &#123;                    this.hook = true;                &#125;            &#125;, onLeave: function(retval)&#123;                if (this.hook) &#123;                    hook_cronetssl()                &#125;            &#125;        &#125;)    &#125;&#125;function hook_callback(p)&#123;    var fun = new NativeFunction(p, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;pointer&#x27;]);    var new_fun = new NativeCallback(function(arg1, arg2)&#123;        console.log(&quot;cononono&quot;, fun(arg1, arg2));        return 0;    &#125;, &#x27;int&#x27;, [&#x27;pointer&#x27;, &#x27;pointer&#x27;])    Interceptor.replace(fun, new_fun)&#125;function hook_cronetssl() &#123;    var cronet = Module.findBaseAddress(&quot;libsscronet.so&quot;);    console.log(&quot;cronet: &quot;, cronet)    var verify = Module.findExportByName(&quot;libsscronet.so&quot;, &quot;SSL_CTX_set_custom_verify&quot;);    console.log(&quot;verify: &quot;, verify)    var custom_verify = new NativeFunction(verify, &#x27;pointer&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;, &#x27;pointer&#x27;]);    var new_fun = new NativeCallback(function(arg1, arg2, arg3) &#123;        hook_callback(arg3)        console.log(&quot;SSL_CTX_set_custom_verify called: &quot; + arg1 + &quot; &quot; + arg2 + &quot; &quot; + arg3)        return custom_verify(arg1, 0, arg3)    &#125;, &#x27;pointer&#x27;, [&#x27;pointer&#x27;, &#x27;int&#x27;, &#x27;pointer&#x27;]);    Interceptor.replace(verify, new_fun)&#125;setImmediate(main)\n验证抓包后面通过调用栈和查询发现这是byteDance下的产品，脚本应该是通用的，也有大佬给出了其它方法https://github.com/LanBaiCode/FridaScripts/blob/main/byteDance.js大佬文章：[原创] 更高更妙的抓包——从Chrome源码学习使用Cronet 通讯组件的app的通用抓包方法\n","tags":["抓包"]},{"title":"DFA还原白盒AES密钥","url":"/posts/15785/","content":"介绍DFA攻击简单来说就是在倒数第一轮列混淆和倒数第二轮列混淆之间（在AES-128中也就是第8轮和第9轮之间，因为最后第10轮不做列混淆），修改此时中间结果的一个字节，会导致最终密文和正确密文有4个字节的不同。通过多次的修改，得到多组错误的密文，然后通过正确密文和这些错误密文能够推算出第10轮的密钥（加密模式下），继而能推算出原始密钥。所以实际应用中，就需要先找准列混合的函数位置，然后在他之前去插入缺陷数据。\n起始处发生故障对密文的影响首先是初始轮密钥加，错误限于这一个字节然后是第一轮的字节替换，错误限于这一个字节然后是第一轮的循环左移，因为是第一行，所以没动。然后是第一轮的列混淆步骤，结果的第m行第n列的值等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和，因此结果中第一列的每一个元素都受到矩阵B（即下图左边）第一列中每个元素的影响。因而，一个字节的错误被扩散到了一整列。或者说，正常情况和故障情况在第一轮列混淆结束后，有四个字节的值不同。然后是第一轮的轮密钥加，它只作用用当前字节，不会将差异扩散出去。可以看到，在一轮循环后，一个字节的故障，被扩散到了四个字节上。继续第二轮。第二轮的字节替换第二轮的循环左移，需要注意到，虽然差异还是四个字节，但被扩散到不同的四列去了。第二轮的列混淆，每列存在的差异扩散到整列，这导致state的全部字节都与原先有差异。经过第二轮一个字节的差异就已经扩散到所有字节上了。那么 state 中一个字节的差异，不论循环多少轮，也只会带来一个字节的差异。反过来说，每一次 MixColumns ，都会让一个字节的差异变成四个字节的差异。因为第十轮没有列混淆所以在第九轮列混淆前做故障点\n通过故障密钥得到第十轮密钥标准的AES算法的python代码\nSbox = (    0x63, 0x7C, 0x77, 0x7B, 0xF2, 0x6B, 0x6F, 0xC5, 0x30, 0x01, 0x67, 0x2B, 0xFE, 0xD7, 0xAB, 0x76,    0xCA, 0x82, 0xC9, 0x7D, 0xFA, 0x59, 0x47, 0xF0, 0xAD, 0xD4, 0xA2, 0xAF, 0x9C, 0xA4, 0x72, 0xC0,    0xB7, 0xFD, 0x93, 0x26, 0x36, 0x3F, 0xF7, 0xCC, 0x34, 0xA5, 0xE5, 0xF1, 0x71, 0xD8, 0x31, 0x15,    0x04, 0xC7, 0x23, 0xC3, 0x18, 0x96, 0x05, 0x9A, 0x07, 0x12, 0x80, 0xE2, 0xEB, 0x27, 0xB2, 0x75,    0x09, 0x83, 0x2C, 0x1A, 0x1B, 0x6E, 0x5A, 0xA0, 0x52, 0x3B, 0xD6, 0xB3, 0x29, 0xE3, 0x2F, 0x84,    0x53, 0xD1, 0x00, 0xED, 0x20, 0xFC, 0xB1, 0x5B, 0x6A, 0xCB, 0xBE, 0x39, 0x4A, 0x4C, 0x58, 0xCF,    0xD0, 0xEF, 0xAA, 0xFB, 0x43, 0x4D, 0x33, 0x85, 0x45, 0xF9, 0x02, 0x7F, 0x50, 0x3C, 0x9F, 0xA8,    0x51, 0xA3, 0x40, 0x8F, 0x92, 0x9D, 0x38, 0xF5, 0xBC, 0xB6, 0xDA, 0x21, 0x10, 0xFF, 0xF3, 0xD2,    0xCD, 0x0C, 0x13, 0xEC, 0x5F, 0x97, 0x44, 0x17, 0xC4, 0xA7, 0x7E, 0x3D, 0x64, 0x5D, 0x19, 0x73,    0x60, 0x81, 0x4F, 0xDC, 0x22, 0x2A, 0x90, 0x88, 0x46, 0xEE, 0xB8, 0x14, 0xDE, 0x5E, 0x0B, 0xDB,    0xE0, 0x32, 0x3A, 0x0A, 0x49, 0x06, 0x24, 0x5C, 0xC2, 0xD3, 0xAC, 0x62, 0x91, 0x95, 0xE4, 0x79,    0xE7, 0xC8, 0x37, 0x6D, 0x8D, 0xD5, 0x4E, 0xA9, 0x6C, 0x56, 0xF4, 0xEA, 0x65, 0x7A, 0xAE, 0x08,    0xBA, 0x78, 0x25, 0x2E, 0x1C, 0xA6, 0xB4, 0xC6, 0xE8, 0xDD, 0x74, 0x1F, 0x4B, 0xBD, 0x8B, 0x8A,    0x70, 0x3E, 0xB5, 0x66, 0x48, 0x03, 0xF6, 0x0E, 0x61, 0x35, 0x57, 0xB9, 0x86, 0xC1, 0x1D, 0x9E,    0xE1, 0xF8, 0x98, 0x11, 0x69, 0xD9, 0x8E, 0x94, 0x9B, 0x1E, 0x87, 0xE9, 0xCE, 0x55, 0x28, 0xDF,    0x8C, 0xA1, 0x89, 0x0D, 0xBF, 0xE6, 0x42, 0x68, 0x41, 0x99, 0x2D, 0x0F, 0xB0, 0x54, 0xBB, 0x16,)Rcon = (0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1B, 0x36)def text2matrix(text):    matrix = []    for i in range(16):        byte = (text &gt;&gt; (8 * (15 - i))) &amp; 0xFF        if i % 4 == 0:            matrix.append([byte])        else:            matrix[i // 4].append(byte)    return matrixdef shiftRound(array, num):    '''    :param array: 需要循环左移的数组    :param num: 循环左移的位数    :return: 使用Python切片，返回循环左移num个单位的array    '''    return array[num:] + array[:num]def g(array, index):    '''    g 函数    :param array: 待处理的四字节数组    :index:从1-10，每次使用Rcon中不同的数    '''    # 首先循环左移1位    array = shiftRound(array, 1)    # 字节替换    array = [Sbox[i] for i in array]    # 首字节和rcon中对应元素异或    array = [(Rcon[index] ^ array[0])] + array[1:]    return arraydef xorTwoArray(array1, array2):    '''    返回两个数组逐元素异或的新数组    :param array1: 一个array    :param array2: 另一个array    :return:    '''    assert len(array1) == len(array2)    return [array1[i] ^ array2[i] for i in range(len(array1))]def showRoundKeys(round_keys):    # 将轮密钥从44*4转成11*16    kList = [[] for i in range(11)]    for i in range(len(round_keys)):        kList[i // 4] += round_keys[i]    for i in range(len(kList)):        print(\"K%02d:\" % i + \"\".join(\"%02x\" % k for k in kList[i]))def keyExpand(key):    master_key = text2matrix(key)    round_keys = [[0] * 4 for i in range(44)]    # 规则一(图中红色部分)    for i in range(4):        round_keys[i] = master_key[i]    for i in range(4, 4 * 11):        # 规则二(图中红色部分)        if i % 4 == 0:            round_keys[i] = xorTwoArray(g(round_keys[i - 1], i // 4), round_keys[i - 4])        # 规则三(图中橙色部分)        else:            round_keys[i] = xorTwoArray(round_keys[i - 1], round_keys[i - 4])    showRoundKeys(round_keys)    return round_keysdef AddRoundKeys(state, roundKey):    result = [[] for i in range(4)]    for i in range(4):        result[i] = xorTwoArray(state[i], roundKey[i])    return resultdef SubBytes(state):    result = [[] for i in range(4)]    for i in range(4):        result[i] = [Sbox[i] for i in state[i]]    return resultdef ShiftRows(s):    s[0][1], s[1][1], s[2][1], s[3][1] = s[1][1], s[2][1], s[3][1], s[0][1]    s[0][2], s[1][2], s[2][2], s[3][2] = s[2][2], s[3][2], s[0][2], s[1][2]    s[0][3], s[1][3], s[2][3], s[3][3] = s[3][3], s[0][3], s[1][3], s[2][3]    return sdef mul_by_02(num):    if num &lt; 0x80:        res = (num &lt;&lt; 1)    else:        res = (num &lt;&lt; 1) ^ 0x1b    return res % 0x100def mul_by_03(num):    return mul_by_02(num) ^ numdef MixColumns(state):    for i in range(4):        s0 = mul_by_02(state[i][0]) ^ mul_by_03(state[i][1]) ^ state[i][2] ^ state[i][3]        s1 = state[i][0] ^ mul_by_02(state[i][1]) ^ mul_by_03(state[i][2]) ^ state[i][3]        s2 = state[i][0] ^ state[i][1] ^ mul_by_02(state[i][2]) ^ mul_by_03(state[i][3])        s3 = mul_by_03(state[i][0]) ^ state[i][1] ^ state[i][2] ^ mul_by_02(state[i][3])        state[i][0] = s0        state[i][1] = s1        state[i][2] = s2        state[i][3] = s3    return statedef state2Text(state):    text = sum(state, [])    return \"\".join(\"%02x\" % k for k in text)def encrypt(input_bytes, kList):    '''    :param input_bytes: 输入的明文    :param kList: K0-K10    :return:    '''    plainState = text2matrix(input_bytes)    # 初始轮密钥加    state = AddRoundKeys(plainState, kList[0:4])    for i in range(1, 10):        state = SubBytes(state)        state = ShiftRows(state)        state = MixColumns(state)        state = AddRoundKeys(state, kList[4 * i:4 * (i + 1)])    state = SubBytes(state)    state = ShiftRows(state)    state = AddRoundKeys(state, kList[40:44])    return stateinput_bytes = 0x00112233445566778899aabbccddeeffkey = 0x2b7e151628aed2a6abf7158809cf4f3ckList = keyExpand(key)cipherState = encrypt(input_bytes, kList)cipher = state2Text(cipherState)print(cipher)\n\n上述代码的执行结果为8df4e9aac5c7573a27d8d055d6e4d64b。接下来我们就要去构造故障了，在第九轮加密的行移位和列混合之间修改一个中间结果的数据：\ndef encrypt(input_bytes, kList):    '''    :param input_bytes: 输入的明文    :param kList: K0-K10    :return:    '''    plainState = text2matrix(input_bytes)    # 初始轮密钥加    state = AddRoundKeys(plainState, kList[0:4])    for i in range(1, 10):        state = SubBytes(state)        state = ShiftRows(state)        # 在第9轮改一个字节        if i == 9:            j = 0            print(\"修改第\" + str(j) + \"个\")            state[j//4][j%4] = 0x10        state = MixColumns(state)        state = AddRoundKeys(state, kList[4 * i:4 * (i + 1)])    state = SubBytes(state)    state = ShiftRows(state)    state = AddRoundKeys(state, kList[40:44])    return state\n执行脚本，结果为daf4e9aac5c757c927d85355d637d64b，比对一下：8d f4 e9 aa c5 c7 57 3a 27 d8 d0 55 d6 e4 d6 4bda f4 e9 aa c5 c7 57 c9 27 d8 53 55 d6 37 d6 4b确实有4个字节不一样。以此类推，将上述代码中j的值从0到15依次增加，会得到16个不一样的密文\ndaf4e9aac5c757c927d85355d637d64b47f4e9aac5c7577d27d8a655d61ed64b79f4e9aac5c7572a27d89855d62ad64b30f4e9aac5c7570b27d86555d6a5d64b8d7de9aac8c7573a27d8d09ed6e4be4b8d5ce9aa43c7573a27d8d04cd6e4054b8d0de9aaddc7573a27d8d060d6e4234b8dabe9aacac7573a27d8d009d6e4484b8df48caac598573a62d8d055d6e4d6368df4bbaac5f4573acdd8d055d6e4d6938df47aaac576573ac1d8d055d6e4d61c8df444aac5c8573a23d8d055d6e4d6fb8df4e9e0c5c7b73a2768d055ade4d64b8df4e9f2c5c7063a27a4d055dfe4d64b8df4e942c5c7793a275ed05535e4d64b8df4e98fc5c7fa3a2778d055b3e4d64b\n有了这个以后我们就可以还原得到第十轮的密钥了，这里使用phoenixAES工具，先安装：\npip install phoenixAES\n然后编写python脚本：\n#!/usr/bin/env python3import phoenixAESwith open('tracefile', 'wb') as t:    t.write(\"\"\"8df4e9aac5c7573a27d8d055d6e4d64bdaf4e9aac5c757c927d85355d637d64b47f4e9aac5c7577d27d8a655d61ed64b79f4e9aac5c7572a27d89855d62ad64b30f4e9aac5c7570b27d86555d6a5d64b8d7de9aac8c7573a27d8d09ed6e4be4b8d5ce9aa43c7573a27d8d04cd6e4054b8d0de9aaddc7573a27d8d060d6e4234b8dabe9aacac7573a27d8d009d6e4484b8df48caac598573a62d8d055d6e4d6368df4bbaac5f4573acdd8d055d6e4d6938df47aaac576573ac1d8d055d6e4d61c8df444aac5c8573a23d8d055d6e4d6fb8df4e9e0c5c7b73a2768d055ade4d64b8df4e9f2c5c7063a27a4d055dfe4d64b8df4e942c5c7793a275ed05535e4d64b8df4e98fc5c7fa3a2778d055b3e4d64b\"\"\".encode('utf8'))phoenixAES.crack_file('tracefile', [], True, False, 3)\n\n一共写入了17行数据到文件，其中第一行为正确的密文，剩余16行都是故障密文，最终通过crack_file即可得到第10轮密钥：\nLast round key #N found:D014F9A8C9EE2589E13F0CC8B6630CA6\n\n还原密文接下来还要根据这个密钥去还原原始密钥，这里还需要用到一个工具Stark，它里面有一个aes_keyschedule.c文件，将其拷贝到本地并编译为可执行文件：\ngcc aes_keyschedule.c -o aes_keyschedule\n然后将刚才得到的第10轮密钥喂进去：\n./aes_keyschedule 5D432583B2AA833FC22D53130FDA904C 10\n执行上述命令后\n./aes_keyschedule D014F9A8C9EE2589E13F0CC8B6630CA6 10K00: 2B7E151628AED2A6ABF7158809CF4F3CK01: A0FAFE1788542CB123A339392A6C7605K02: F2C295F27A96B9435935807A7359F67FK03: 3D80477D4716FE3E1E237E446D7A883BK04: EF44A541A8525B7FB671253BDB0BAD00K05: D4D1C6F87C839D87CAF2B8BC11F915BCK06: 6D88A37A110B3EFDDBF98641CA0093FDK07: 4E54F70E5F5FC9F384A64FB24EA6DC4FK08: EAD27321B58DBAD2312BF5607F8D292FK09: AC7766F319FADC2128D12941575C006EK10: D014F9A8C9EE2589E13F0CC8B6630CA6\n\n即可得到密钥为2B7E151628AED2A6ABF7158809CF4F3C，同一开始的密钥一致\n更多关于加密算法的内容可以关注龙哥星球\n","tags":["算法"]},{"title":"某幸咖啡逆向及DFA还原白盒AES密钥","url":"/posts/10070/","content":"样例APP：某幸咖啡版本：5.0.01下面会用DFA方式对该样本白盒AES分析还原\n抓包脱壳首先上来先抓包，这里直接抓包首页商品推荐，无论登录还是搜索接口都是一样的参数加密sign和q值，sign的长度不是固定的38，39，40位都有发现是360的壳使用r0ysue的脱壳工具 https://github.com/r0ysue/frida_dump\nfrida -U --no-pause -f packagename  -l dump_dex.js\n脱壳后的dex文件夹整个拉进jadx用搜索关键词的方式没定位到，可能是字符串加密了请求表单大都是用hashmap put添加，这里也尝试hook hashmap\nfunction hook_hashmap()&#123;    Java.perform(function()&#123;        var hashMap = Java.use(&quot;java.util.HashMap&quot;);        hashMap.put.implementation = function(a, b) &#123;            if(a!=null &amp;&amp; a.equals(&quot;sign&quot;))&#123;                 console.log(&quot;hashMap.put ==&gt; &quot;, a, b);                console.log(Java.use(&quot;android.util.Log&quot;).getStackTraceString(Java.use(&quot;java.lang.Throwable&quot;).$new()));            &#125;            return this.put(a, b);        &#125;    &#125;)&#125;\n使用attach会发现失败，因为该样本存在双进程保护，会占用ptrace，attach 需要使用ptrace实现注入，ptrace被占用无法使用，就会导致attach注入失败。\n└─# adb shellblueline:/ $  ps -A | grep luckyu0_a225      28594  1075 1856704 360324 0                   0 S com.lucky.luckyclientu0_a225      28645 28594 1463932 126400 0                   0 S com.lucky.luckyclient\n查看进程后确实是双进程，那就改用Frida Spawn方式注入\nfrida -U -f 包名 -l js文件 --no-pause -o log.txt\n通过对应的包对比找到了请求参数的位置 com.lucky.lib.http2.AbstractLcRequest.getRequestParams果然跟想的一样字符串加密，主动调用一下看看加密的字符串是什么，顺便看到哪个是结果\nfunction call_getRequestParams()&#123;    Java.perform(function()&#123;        var StubApp = Java.use(&#x27;com.stub.StubApp&#x27;);        var result1 = StubApp[&#x27;getString2&#x27;](&#x27;14154&#x27;);        var result2 = StubApp[&#x27;getString2&#x27;](&#x27;457&#x27;);        var result3 = StubApp[&#x27;getString2&#x27;](&#x27;4005&#x27;);        var result4 = StubApp[&#x27;getString2&#x27;](&#x27;16944&#x27;);        var result5 = StubApp[&#x27;getString2&#x27;](&#x27;7719&#x27;);        console.log(&quot;StubApp.getString2(14154) ==&gt; &quot;, result1)        console.log(&quot;StubApp.getString2(457) ==&gt; &quot;, result2)        console.log(&quot;StubApp.getString2(4005) ==&gt; &quot;, result3)        console.log(&quot;StubApp.getString2(16944) ==&gt; &quot;, result4)        console.log(&quot;StubApp.getString2(7719) ==&gt; &quot;, result5)    &#125;)&#125;\nStubApp.getString2(14154) ==&gt;  appversionStubApp.getString2(457) ==&gt;  qStubApp.getString2(4005) ==&gt;  cidStubApp.getString2(16944) ==&gt;  uidStubApp.getString2(7719) ==&gt;  sign\n多次抓包只有q和sign的值是会变的，sign是由cid，uid，q的值加密来的一路跟进到native方法，其中q是由localAESWork4Api加密生成后转base64，sign是通过参数的拼接成字符串最后调用md5_crypt加密生成，其中最上面加载了lib库，System.loadLibrary(StubApp.getString2(“30491”));用上面的主动调用解密后是 cryptoDD解压apk找到这个so用ida打开在Exports搜java，啥都没搜到，那就只有动态注册了，hook libart找动态注册函数\nfunction find_RegisterNatives() &#123;    let symbols = Module.enumerateSymbolsSync(&quot;libart.so&quot;);    let addrRegisterNatives = null;    for (let i = 0; i &lt; symbols.length; i++) &#123;        let symbol = symbols[i];                //_ZN3art3JNI15RegisterNativesEP7_JNIEnvP7_jclassPK15JNINativeMethodi        if (symbol.name.indexOf(&quot;art&quot;) &gt;= 0 &amp;&amp;                symbol.name.indexOf(&quot;JNI&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;RegisterNatives&quot;) &gt;= 0 &amp;&amp;                 symbol.name.indexOf(&quot;CheckJNI&quot;) &lt; 0) &#123;            addrRegisterNatives = symbol.address;            console.log(&quot;RegisterNatives is at &quot;, symbol.address, symbol.name);            hook_RegisterNatives(addrRegisterNatives)        &#125;    &#125;&#125;function hook_RegisterNatives(addrRegisterNatives) &#123;    if (addrRegisterNatives != null) &#123;        Interceptor.attach(addrRegisterNatives, &#123;            onEnter: function (args) &#123;                // console.log(&quot;[RegisterNatives] method_count:&quot;, args[3]);                let java_class = args[1];                let class_name = Java.vm.tryGetEnv().getClassName(java_class);                //console.log(class_name);                let methods_ptr = ptr(args[2]);                let method_count = parseInt(args[3]);                for (let i = 0; i &lt; method_count; i++) &#123;                    let name_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3));                    let sig_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize));                    let fnPtr_ptr = Memory.readPointer(methods_ptr.add(i * Process.pointerSize * 3 + Process.pointerSize * 2));                    let name = Memory.readCString(name_ptr);                    let sig = Memory.readCString(sig_ptr);                    var find_module = Process.findModuleByAddress(name_ptr);                    if(find_module != null &amp;&amp; find_module.name == &quot;libcryptoDD.so&quot;) &#123;                        console.log(&quot;[RegisterNatives] java_class:&quot;, class_name, &quot;name:&quot;, name, &quot;sig:&quot;, sig, &quot;fnPtr:&quot;, fnPtr_ptr, &quot;offset:&quot;, ptr(fnPtr_ptr).sub(find_module.base));                    &#125;                &#125;            &#125;        &#125;);    &#125;&#125;setImmediate(find_RegisterNatives)\n[RegisterNatives] java_class: com.luckincoffee.safeboxlib.CryptoHelper name: localAESWork sig: ([BI[B)[B fnPtr: 0xbe7f084d offset: 0x1984d[RegisterNatives] java_class: com.luckincoffee.safeboxlib.CryptoHelper name: localConnectWork sig: ([B[B)[B fnPtr: 0xbe7f078d offset: 0x1978d[RegisterNatives] java_class: com.luckincoffee.safeboxlib.CryptoHelper name: md5_crypt sig: ([BI)[B fnPtr: 0xbe7f1981 offset: 0x1a981[RegisterNatives] java_class: com.luckincoffee.safeboxlib.CryptoHelper name: localAESWork4Api sig: ([BI)[B fnPtr: 0xbe7f21cd offset: 0x1b1cd\n只要关注md5_crypt和localAESWork4Api，偏移量分别为0x1a981，0x1b1cdida跳转到0x1b1cd位置函数名是android_native_wbaes，0x1a981函数名是android_native_md5大概浏览跟进android_native_wbaes查看有PKCS5Padding，wbaes_decrypt_ecb函数从这些函数名可以猜测  wbaes_encrypt_ecb 是调用白盒aes的ecb模式加密\n算法分析尝试对 wbaes_encrypt_ecb 进行hook参看参数，从参数名可以得知 in是明文，in_len是长度，out是输出结果，mode是模式既然写了是ecb，那可以主动调用测试下是不是真的是ecb模式，我们知道aes是16字节一组，那可以设置明文两组一样的，然后看加密结果以明文 zskkk.cnzskkk.cn 为例，转为字节是 7a 73 6b 6b 6b 2e 63 6e 7a 73 6b 6b 6b 2e 63 6e\nfunction hexToBytes(hex) &#123;    for (var bytes = [], c = 0; c &lt; hex.length; c += 2)        bytes.push(parseInt(hex.substr(c, 2), 16));    return bytes;&#125;function call_wbaes_encrypt_ecb()&#123;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    var real_addr = base_addr.add(0x17bd5);    var wbaes_encrypt_ecb_func = new NativeFunction(real_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]);    var inputPtr = Memory.alloc(0x20);    var inputArray = hexToBytes(&quot;7a736b6b6b2e636e7a736b6b6b2e636e7a736b6b6b2e636e7a736b6b6b2e636e&quot;);    Memory.writeByteArray(inputPtr, inputArray)    var outputPtr = Memory.alloc(0x20);    wbaes_encrypt_ecb_func(inputPtr, 0x20, outputPtr, 0);    console.log(hexdump(outputPtr,&#123;length: 0x20&#125;));&#125;\n           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFf24005f8  4e 64 b5 10 8d a6 82 b5 13 f3 6e 69 aa a4 63 56  Nd........ni..cVf2400608  4e 64 b5 10 8d a6 82 b5 13 f3 6e 69 aa a4 63 56  Nd........ni..cV\n可以发现，两个分组加密结果一致，看来确实是ECB。现在对其进行hook\nfunction hook_wbaes_encrypt_ecb()&#123;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    // wbaes_encrypt_ecb 的偏移地址0x17bd4，因为thumb所以+1    var real_addr = base_addr.add(0x17bd5)    Interceptor.attach(real_addr, &#123;        onEnter: function (args) &#123;            console.log(&quot;Input&quot;);            this.buffer = args[2];            this.length = args[1].toInt32();            console.log(hexdump(args[0],&#123;length: this.length&#125;));            console.log(&quot;mode:&quot;+args[3]);        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;Output&quot;)            console.log(hexdump(this.buffer,&#123;length: this.length&#125;));        &#125;    &#125;);&#125;\n也是使用spawn的方式启动\n[Pixel 3::com.lucky.luckyclient ]-&gt; Input           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFf6b9ff10  7b 22 70 61 67 65 54 79 70 65 22 3a 22 31 22 2c  &#123;&quot;pageType&quot;:&quot;1&quot;,f6b9ff20  22 74 61 67 49 6e 64 65 78 22 3a 22 42 51 30 32  &quot;tagIndex&quot;:&quot;BQ02f6b9ff30  30 22 2c 22 61 70 70 76 65 72 73 69 6f 6e 22 3a  0&quot;,&quot;appversion&quot;:f6b9ff40  22 35 30 30 31 22 2c 22 70 61 67 65 22 3a 32 2c  &quot;5001&quot;,&quot;page&quot;:2,f6b9ff50  22 72 6f 77 73 22 3a 31 36 2c 22 62 72 61 6e 64  &quot;rows&quot;:16,&quot;brandf6b9ff60  43 6f 64 65 22 3a 22 4c 4b 30 30 31 22 7d 02 02  Code&quot;:&quot;LK001&quot;&#125;..mode:0x0Output           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFf6b89cb0  f0 43 ce dd 27 e5 47 0a c5 8b fa 67 16 20 0d 20  .C..&#x27;.G....g. . f6b89cc0  75 fa d6 ad a4 48 b0 fb 68 5f 81 60 86 53 68 03  u....H..h_.`.Sh.f6b89cd0  c3 0e 21 28 46 ae d2 dc e4 0c 3e 36 4f 10 32 ee  ..!(F.....&gt;6O.2.f6b89ce0  cc b7 57 6c 3c f7 85 c5 86 a4 b4 a6 7f da 47 67  ..Wl&lt;.........Ggf6b89cf0  ef bc 3a 8e 13 e0 30 1a 56 86 76 de 16 26 63 cc  ..:...0.V.v..&amp;c.f6b89d00  a7 93 16 80 8a 23 6d 63 8b 9d 98 55 26 26 cc fb  .....#mc...U&amp;&amp;..[Pixel 3::com.lucky.luckyclient ]-&gt;\n观察输入可以发现，待加密的内容经过了PCKS7填充，末尾缺了2字节用了0x20填充。虽然存在一些混淆，但是符号没去掉给了很大的帮助，从ida的代码中也能看出，wbaes_encrypt_ecb只是外层的简单包装，后面还会调用 aes128_enc_wb_coff 和 aes128_enc_wb_xlc 。\nvoid __fastcall aes128_enc_wb_xlc(uint8_t *in, uint8_t *out)void __fastcall aes128_enc_wb_coff(uint8_t *in, uint8_t *out)\n接下来只关注于单个分组，最后的call代码如下，完善Hook脚本，添加对这两个函数的Hook\nfunction hexToBytes(hex) &#123;    for (var bytes = [], c = 0; c &lt; hex.length; c += 2)        bytes.push(parseInt(hex.substr(c, 2), 16));    return bytes;&#125;function hook_aes128_enc_wb_xlc()&#123;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    // aes128_enc_wb_xlc 的偏移地址0x15c8c，因为thumb所以+1    var real_addr = base_addr.add(0x15c8d);    Interceptor.attach(real_addr, &#123;        onEnter: function (args) &#123;            console.log(&quot;aes128_enc_wb_xlc&quot;);            console.log(hexdump(args[0],&#123;length: 0x10&#125;))        &#125;    &#125;);&#125;function hook_aes128_enc_wb_coff()&#123;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    // aes128_enc_wb_coff 的偏移地址0x15320，因为thumb所以+1    var real_addr = base_addr.add(0x15321);    Interceptor.attach(real_addr, &#123;        onEnter: function (args) &#123;            console.log(&quot;aes128_enc_wb_coff&quot;);            console.log(hexdump(args[0],&#123;length: 0x10&#125;))        &#125;    &#125;);&#125;function call_wbaes_encrypt_ecb()&#123;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    var real_addr = base_addr.add(0x17bd5);    var wbaes_encrypt_ecb_func = new NativeFunction(real_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]);    var inputPtr = Memory.alloc(0x10);    var inputArray = hexToBytes(&quot;7a736b6b6b2e636e7a736b6b6b2e636e&quot;);    Memory.writeByteArray(inputPtr, inputArray)    var outputPtr = Memory.alloc(0x10);    wbaes_encrypt_ecb_func(inputPtr, 0x10, outputPtr, 0);    console.log(hexdump(outputPtr,&#123;length: 0x10&#125;));&#125;\n执行结果\naes128_enc_wb_coff           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFdf194260  7a 73 6b 6b 6b 2e 63 6e 7a 73 6b 6b 6b 2e 63 6e  zskkk.cnzskkk.cn           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFf1ad5988  4e 64 b5 10 8d a6 82 b5 13 f3 6e 69 aa a4 63 56  Nd........ni..cV\n可以确认，逻辑最终走到了aes128_enc_wb_coff，下面分析aes128_enc_wb_coff。观察可以看到三个表\nconst uint8_t Tboxes_[16][256];const uint8_t Txor[16][16];const uint32_t Tyboxes[9][16][256];\n都是不小的表，且程序逻辑中存在大量查表运算，确实是白盒加密。\nDFA攻击获取密钥使用Frida在DFA还原白盒AES密钥这一篇中说过，总结就是三步骤\n\n找轮\n找时机，即具体第几轮做故障注入\n找state由于代码被混淆了，很难静态做出这些判断，只能大概分析，鉴于函数名没有混淆，很快找到 wbShiftRows 这个函数，从名字得知应该是做循环左移，在aes一次加密中，会进行十轮循环左移，对其进行hook验证下function hook_wbShiftRows()&#123;    var count = 0;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    var real_addr = base_addr.add(0x14f99);    Interceptor.attach(real_addr, &#123;        onEnter: function (args) &#123;            count += 1;            console.log(&quot;wbShiftRows:&quot;+count);        &#125;    &#125;);&#125;\n运行结果[Pixel 3::com.lucky.luckyclient ]-&gt; aes128_enc_wb_coff           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFdf194260  7a 73 6b 6b 6b 2e 63 6e 7a 73 6b 6b 6b 2e 63 6e  zskkk.cnzskkk.cnwbShiftRows:1wbShiftRows:2wbShiftRows:3wbShiftRows:4wbShiftRows:5wbShiftRows:6wbShiftRows:7wbShiftRows:8wbShiftRows:9wbShiftRows:10           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFf2c7d930  4e 64 b5 10 8d a6 82 b5 13 f3 6e 69 aa a4 63 56  Nd........ni..cV\n确实是十轮，设置故障点最好的时机就是在第九轮，而循环左移后就是列混淆了，void __fastcall wbShiftRows(uint8_t *out)\n发现，函数就一个参数，out即作输入又当输出，那么可以对这个函数参数进行修改，就可以故障注入，可以将第一个字节改成0。运行结果：aes128_enc_wb_coff           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFdf194260  7a 73 6b 6b 6b 2e 63 6e 7a 73 6b 6b 6b 2e 63 6e  zskkk.cnzskkk.cnwbShiftRows:1wbShiftRows:2wbShiftRows:3wbShiftRows:4wbShiftRows:5wbShiftRows:6wbShiftRows:7wbShiftRows:8wbShiftRows:9wbShiftRows:10           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFf2ad6450  de 64 b5 10 8d a6 82 12 13 f3 9c 69 aa 5f 63 56  .d.........i._cV\n将正确明文和故障密文做对比正确密文：4e 64 b5 10 8d a6 82 b5 13 f3 6e 69 aa a4 63 56故障密文：de 64 b5 10 8d a6 82 12 13 f3 9c 69 aa 5f 63 56注入成功了，接下来只需要收集多点故障密文加上正常密文，喂给phoenixAES就可以得到第十轮密钥了function bufferToHex(buffer) &#123;    return [...new Uint8Array (buffer)]        .map (b =&gt; b.toString (16).padStart (2, &quot;0&quot;))        .join (&quot;&quot;);&#125;function hook_wbShiftRows()&#123;    var count = 0;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    // wbShiftRows 的偏移地址0x14f90，因为thumb所以+1    var real_addr = base_addr.add(0x14f99);    Interceptor.attach(real_addr, &#123;        onEnter: function (args) &#123;            count += 1;            if (count % 9 == 0)&#123;                args[0].add(Math.floor(Math.random() * 16)).writeS8(0x0);            &#125;        &#125;    &#125;);&#125;function call_wbaes_encrypt_ecb()&#123;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    var real_addr = base_addr.add(0x17bd5);    var wbaes_encrypt_ecb_func = new NativeFunction(real_addr, &quot;int&quot;, [&quot;pointer&quot;, &quot;int&quot;, &quot;pointer&quot;, &quot;int&quot;]);    var inputPtr = Memory.alloc(0x10);    var inputArray = hexToBytes(&quot;7a736b6b6b2e636e7a736b6b6b2e636e&quot;);    Memory.writeByteArray(inputPtr, inputArray)    var outputPtr = Memory.alloc(0x10);    wbaes_encrypt_ecb_func(inputPtr, 0x10, outputPtr, 0);    // console.log(hexdump(outputPtr,&#123;length: 0x10&#125;));    var output = Memory.readByteArray(outputPtr, 0x10);    console.log(bufferToHex(output))&#125;function dfa()&#123;    hook_wbShiftRows();    for(var i = 1; i&lt;200; i++) &#123;        call_wbaes_encrypt_ecb();    &#125;&#125;\n这里打印成hexstr而不是hexdump，然后在hook_wbShiftRows中计数器为九的倍数时就注入故障，因为计数器的数字会随着call_wbaes_encrypt_ecb不断增加，注入故障的位置是随机在0-15字节位置修改为0x0，随机字节也可以。然后将正确密文以及输出的200个故障密文放入phoenixAES，结果为Last round key #N found:869D92BBB700D0D25BD9FD3E224B5DF2\n放入 stark./aes_keyschedule 869D92BBB700D0D25BD9FD3E224B5DF2 10K00: 644A4C64434A69566E44764D394A5570K01: B3B61D76F0FC74209EB8026DA7F2571DK02: 38EDB92AC811CD0A56A9CF67F15B987AK03: 05AB638BCDBAAE819B1361E66A48F99CK04: 5F32BD8992881308099B72EE63D38B72K05: 290FFD72BB87EE7AB21C9C94D1CF17E6K06: 83FF734C38789D368A6401A25BAB1644K07: A1B8687599C0F54313A4F4E1480FE2A5K08: 57206E27CEE09B64DD446F85954B8D20K09: FF7DD90D319D4269ECD92DEC7992A0CCK10: 869D92BBB700D0D25BD9FD3E224B5DF2\n得出密钥：644A4C64434A69566E44764D394A5570在cyber中用一开始抓包的密文做测试解密看看成功解密再次抓包hook localAESWork4Api的返回值与aes ecb加密后的结果是否一致，看下是否还有做其它操作新增hook函数function hook_localAESWork4Api()&#123;    Java.perform(function ()&#123;        let CryptoHelper = Java.use(&quot;com.luckincoffee.safeboxlib.CryptoHelper&quot;);        CryptoHelper[&quot;localAESWork4Api&quot;].implementation = function (bArr, i) &#123;            let ret = this.localAESWork4Api(bArr, i);            console.log(&#x27;localAESWork4Api value: &#x27; + bufferToHex(ret));            return ret;        &#125;;    &#125;)&#125;\n[Pixel 3::com.lucky.luckyclient ]-&gt; Input0x9fd42f50           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEF9fd42f50  7b 22 70 61 67 65 54 79 70 65 22 3a 22 31 22 2c  &#123;&quot;pageType&quot;:&quot;1&quot;,9fd42f60  22 74 61 67 49 6e 64 65 78 22 3a 22 42 51 30 32  &quot;tagIndex&quot;:&quot;BQ029fd42f70  30 22 2c 22 61 70 70 76 65 72 73 69 6f 6e 22 3a  0&quot;,&quot;appversion&quot;:9fd42f80  22 35 30 30 31 22 2c 22 70 61 67 65 22 3a 35 2c  &quot;5001&quot;,&quot;page&quot;:5,9fd42f90  22 72 6f 77 73 22 3a 31 36 2c 22 62 72 61 6e 64  &quot;rows&quot;:16,&quot;brand9fd42fa0  43 6f 64 65 22 3a 22 4c 4b 30 30 31 22 7d 02 02  Code&quot;:&quot;LK001&quot;&#125;..mode:0x0Output           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFe7a50000  f0 43 ce dd 27 e5 47 0a c5 8b fa 67 16 20 0d 20  .C..&#x27;.G....g. . e7a50010  75 fa d6 ad a4 48 b0 fb 68 5f 81 60 86 53 68 03  u....H..h_.`.Sh.e7a50020  c3 0e 21 28 46 ae d2 dc e4 0c 3e 36 4f 10 32 ee  ..!(F.....&gt;6O.2.e7a50030  a0 6f a2 2f c6 f5 73 59 b3 5d bb 5b f3 ec 41 bf  .o./..sY.].[..A.e7a50040  ef bc 3a 8e 13 e0 30 1a 56 86 76 de 16 26 63 cc  ..:...0.V.v..&amp;c.e7a50050  a7 93 16 80 8a 23 6d 63 8b 9d 98 55 26 26 cc fb  .....#mc...U&amp;&amp;..localAESWork4Api value: f043cedd27e5470ac58bfa6716200d2075fad6ada448b0fb685f816086536803c30e212846aed2dce40c3e364f1032eea06fa22fc6f57359b35dbb5bf3ec41bfefbc3a8e13e0301a568676de162663cca79316808a236d638b9d98552626ccfb\n结果是一致的，回到localAESWork4Api看密文出来后接下来的处理public synchronized String m29712c(String str) &#123;    byte[] localAESWork4Api;    if (this.f235976e != null) &#123;        String mo24058a = this.f235976e.mo24058a();        if (!mo24058a.endsWith(StubApp.getString2(&quot;30492&quot;))) &#123;            localAESWork4Api = localAESWork(str.getBytes(), 2, Base64.decode(mo24058a.replace(&#x27;-&#x27;, &#x27;+&#x27;).replace(&#x27;_&#x27;, &#x27;/&#x27;).getBytes(), 2));        &#125; else &#123;            localAESWork4Api = localAESWork4Api(str.getBytes(), mo24058a.startsWith(StubApp.getString2(&quot;11453&quot;)) ? 0 : 2);        &#125;    &#125; else &#123;        throw new RuntimeException(StubApp.getString2(&quot;30494&quot;));    &#125;    return new String(Base64.encode(localAESWork4Api, 2)).replace(&#x27;+&#x27;, &#x27;-&#x27;).replace(&#x27;/&#x27;, &#x27;_&#x27;);&#125;\n\n使用Unidbg先搭架子\npackage com.LuckyCoffee;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.memory.Memory;import java.io.File;public class LuckyAES extends AbstractJni &#123;    private final AndroidEmulator emulator;    private final VM vm;    private final Module module;    public LuckyAES()&#123;        emulator = AndroidEmulatorBuilder.for32Bit().build(); // 创建模拟器实例，要模拟32位或者64位，在这里区分        // 模拟器的内存操作接口        final Memory memory = emulator.getMemory();        // 设置系统类库解析        memory.setLibraryResolver(new AndroidResolver(23));        // 创建Android虚拟机        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/LuckyCoffee/ruixing5.0.01.apk&quot;));        vm.setVerbose(true);        // 加载基本库        new AndroidModule(emulator, vm).register(memory);        // 加载so到虚拟内存        DalvikModule dm = vm.loadLibrary(&quot;cryptoDD&quot;, true);        module = dm.getModule();        // 设置JNI        vm.setJni(this);        dm.callJNI_OnLoad(emulator);    &#125;        public static void main(String[] args) &#123;        LuckyAES luckyAES = new LuckyAES();    &#125;&#125;\n运行完没问题后就开始调用函数wbaes_encrypt_ecb，通过分析知道了该函数偏移0x17bd4+1，参数明文跟上面frida一样”zskkk.cnzskkk.cn”\npublic static byte[] hexStringToBytes(String hexString) &#123;    return DatatypeConverter.parseHexBinary(hexString);    //if(hexString.isEmpty())&#123;    //    return null;    //&#125;    //hexString = hexString.toLowerCase();    //byte[] byteArray = new byte[hexString.length() &gt;&gt; 1];    //int index = 0;    //for(int i = 0; i &lt; hexString.length(); i++) &#123;    //    if(index &gt; hexString.length() - 1)&#123;    //        return byteArray;    //    &#125;    //    byte highDit = (byte) (Character.digit(hexString.charAt(index), 16) &amp; 0xFF);    //    byte lowDit = (byte) (Character.digit(hexString.charAt(index + 1), 16) &amp; 0xFF);    //    byteArray[i] = (byte) (highDit &lt;&lt; 4 | lowDit);    //    index += 2;    //&#125;    //return byteArray;&#125;public static String bytesTohexString(byte[] bytes) &#123;    StringBuffer sb = new StringBuffer();    for(int i = 0; i&lt;bytes.length; i++)&#123;        String hex = Integer.toHexString(bytes[i] &amp; 0xFF);        if (hex.length() &lt; 2) &#123;            sb.append(0);        &#125;        sb.append(hex);    &#125;    return sb.toString();&#125;public void call_wbaes_encrypt_ecb()&#123;    MemoryBlock inBlock = emulator.getMemory().malloc(16, true);    UnidbgPointer inPtr = inBlock.getPointer();    MemoryBlock outBlock = emulator.getMemory().malloc(16, true);    UnidbgPointer outPtr = outBlock.getPointer();    byte[] stub = hexStringToBytes(&quot;7a736b6b6b2e636e7a736b6b6b2e636e&quot;);    assert stub != null;    inPtr.write(0, stub, 0, stub.length);    module.callFunction(emulator, 0x17bd5, inPtr, 16, outPtr, 0);    String ret = bytesTohexString(outPtr.getByteArray(0, 0x10));    System.out.println(&quot;white box result:&quot;+ret);    inBlock.free();    outBlock.free();&#125;\n运行后结果也是一致\nJNIEnv-&gt;FindClass(com/luckincoffee/safeboxlib/CryptoHelper) was called from RX@0x1201b43b[libcryptoDD.so]0x1b43bJNIEnv-&gt;RegisterNatives(com/luckincoffee/safeboxlib/CryptoHelper, RW@0x120dfd0c[libcryptoDD.so]0xdfd0c, 4) was called from RX@0x1201b3e3[libcryptoDD.so]0x1b3e3RegisterNative(com/luckincoffee/safeboxlib/CryptoHelper, localAESWork([BI[B)[B, RX@0x1201984d[libcryptoDD.so]0x1984d)RegisterNative(com/luckincoffee/safeboxlib/CryptoHelper, localConnectWork([B[B)[B, RX@0x1201978d[libcryptoDD.so]0x1978d)RegisterNative(com/luckincoffee/safeboxlib/CryptoHelper, md5_crypt([BI)[B, RX@0x1201a981[libcryptoDD.so]0x1a981)RegisterNative(com/luckincoffee/safeboxlib/CryptoHelper, localAESWork4Api([BI)[B, RX@0x1201b1cd[libcryptoDD.so]0x1b1cd)white box result:4e64b5108da682b513f36e69aaa46356\n接下来跟龙哥学了一招，作图因为白盒加密的主要实现方式是查表法，所以加密主体就是大量的内存访问。那么记录函数对内存的访问以及发起访问的地址（PC指针），绘制成折线图，就可以较好的反映加密流程。使用Unidbg的ReadHook规则如下：监控整个SO地址范围内的内存读取操作，记录PC发起的地址，减去SO基地址，只打印偏移，这样呈现效果更好。\npublic void traceAESRead() &#123;    ReadHook readHook = new ReadHook() &#123;        @Override        public void hook(Backend backend, long address, int size, Object user) &#123;            int now = emulator.getBackend().reg_read(ArmConst.UC_ARM_REG_PC).intValue();            if((now &gt; module.base) &amp; (now &lt; (module.base + module.size)))&#123;                System.out.println(now - module.base);            &#125;        &#125;        @Override        public void onAttach(UnHook unHook) &#123;        &#125;        @Override        public void detach() &#123;        &#125;    &#125;;    emulator.getBackend().hook_add_new(readHook, module.base, module.base+module.size, null);&#125;\ntraceAESRead 函数放于如下位置\npublic static void main(String[] args) &#123;    LuckyAES luckyAES = new LuckyAES();    luckyAES.traceAESRead();    luckyAES.call_wbaes_encrypt_ecb();&#125;\n结果如下将这几千条记录拷贝出来，保存在trace.txt 中，在Python中做可视化。需要安装matplotlib以及numpy库。\nimport matplotlib.pyplot as pltimport numpyinput = numpy.loadtxt(&quot;trace.txt&quot;, int)plt.plot(range(len(input)), input)plt.show()\n运行后生成折线图，将其放大是如下效果X轴的计数单位是次数，表示当前是第几次内存访问，如图，在程序的运行过程中，发生了1400余次对SO内存的读操作。Y轴是发起访问的偏移地址。需要注意，X与Y轴的数值表示为十进制。图上可得，Y主要在80000-100000之间，我们修改Y轴范围，增强呈现效果。\nimport matplotlib.pyplot as pltimport numpyinput = numpy.loadtxt(&quot;trace.txt&quot;, int)plt.plot(range(len(input)), input)# 限制Yplt.ylim(80000,100000)plt.plot(range(len(input)), input)plt.show()\n还可以缩小到85000-90000之间，再次缩小Y的范围，可已看到重复了10次的相同模式，代表了十轮运算，这一点可用于区分AES-128&#x2F;192&#x2F;256，分别对应10&#x2F;12&#x2F;14 轮。除此之外，我们发现每轮运算的起点是一个较低的地址，具体在86000附近左右，转成十六进制就是0x14FF0附近。在IDA中查看，是处于wbShiftRows函数中，接下来就再次来到故障攻击的部分，很接近Frida Hook的代码\npublic static int randInt(int min, int max) &#123;    Random rand = new Random();    return rand.nextInt((max - min) + 1) + min;&#125;public void dfaAttack() &#123;    emulator.attach().addBreakPoint(module.base + 0x14f98 + 1, new BreakPointCallback() &#123;        int count = 0;        UnidbgPointer pointer;        @Override        public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;            count += 1;            RegisterContext registerContext = emulator.getContext();            pointer = registerContext.getPointerArg(0);            emulator.attach().addBreakPoint(registerContext.getLRPointer().peer, new BreakPointCallback() &#123;                @Override                public boolean onHit(Emulator&lt;?&gt; emulator, long address) &#123;                    if (count % 9 == 0) &#123;                        pointer.setByte(randInt(0, 15), (byte) randInt(0, 0xff));                    &#125;                    return true;                &#125;            &#125;);            return true;        &#125;    &#125;);&#125;public static void main(String[] args) &#123;    LuckyAES luckyAES = new LuckyAES();    luckyAES.dfaAttack();    for (int i = 0; i &lt; 200; i++) &#123;        luckyAES.call_wbaes_encrypt_ecb();    &#125;&#125;\n运行出来的故障密文同样喂给phoenixAES，也是得到相同第十轮密钥，放入stark得到初始密钥\nsign参数分析上次说到md5_crypt是sign的加密函数，在so中对应的是android_native_md5偏移量0x1a981也是在该函数中很快的发现md5，doMD5sign可疑函数\nvoid __fastcall md5(const uint8_t *initial_msg, size_t initial_len, uint8_t *digest)uint32_t __fastcall doMD5sign(const uint8_t *initial_msg, size_t initial_len, int8_t **digest)\n查看doMD5sign的代码后\nuint32_t __fastcall doMD5sign(const uint8_t *initial_msg, size_t initial_len, int8_t **digest)&#123;  signed int v4; // r0  int v5; // r2  signed int v6; // r0  int v7; // r2  signed int v8; // r2  signed int v9; // r0  int v10; // r2  size_t v11; // r4  int8_t *v12; // r0  uint8_t v14[16]; // [sp+0h] [bp-A8h] BYREF  char s[64]; // [sp+10h] [bp-98h] BYREF  char v16[20]; // [sp+50h] [bp-58h] BYREF  char v17[20]; // [sp+64h] [bp-44h] BYREF  char v18[20]; // [sp+78h] [bp-30h] BYREF  md5(initial_msg, initial_len, v14);  v4 = bytesToInt(v14, 0);  v5 = v4;  if ( v4 &lt; 0 )    v5 = -v4;  sprintf(s, &amp;byte_E0021, v5);  v6 = bytesToInt(v14, 4u);  v7 = v6;  if ( v6 &lt; 0 )    v7 = -v6;  sprintf(v18, &amp;byte_E0021, v7);  v8 = bytesToInt(v14, 8u);  if ( v8 &lt;= -1 )    v8 = -v8;  sprintf(v17, &amp;byte_E0021, v8);  v9 = bytesToInt(v14, 0xCu);  v10 = v9;  if ( v9 &lt; 0 )    v10 = -v9;  sprintf(v16, &amp;byte_E0021, v10);  strcat(s, v18);  strcat(s, v17);  strcat(s, v16);  v11 = strlen(s);  v12 = (int8_t *)malloc(v11);  *digest = v12;  qmemcpy(v12, s, v11);  return v11;&#125;\n调用的了4次bytesToInt，最后经过strcat拼接成字符串，抓包的sign也都是由数字拼接，那会不会跟这个函数有关？hook看下\nfunction hook_doMD5sign()&#123;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    var real_addr = base_addr.add(0x14d55)    Interceptor.attach(real_addr, &#123;        onEnter: function (args) &#123;            console.log(&quot;doMD5sign Input&quot;);            console.log(args[0])            this.length = args[1].toInt32();            this.buffer = args[2];            console.log(hexdump(args[0],&#123;length: this.length&#125;));        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;doMD5sign Output&quot;)            // console.log(retval.toInt32());            console.log(hexdump(this.buffer,&#123;length: retval.toInt32()&#125;));        &#125;    &#125;);&#125;function hook_md5()&#123;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    var real_addr = base_addr.add(0x13e3d)    Interceptor.attach(real_addr, &#123;        onEnter: function (args) &#123;            console.log(&quot;md5 Input&quot;);            console.log(args[0])            this.length = args[1].toInt32();            this.buffer = args[2];            console.log(hexdump(args[0],&#123;length: this.length&#125;));        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;md5 Output&quot;)            console.log(hexdump(this.buffer,&#123;length: 32&#125;));        &#125;    &#125;);&#125;function hook_bytesToInt()&#123;    var base_addr = Module.findBaseAddress(&quot;libcryptoDD.so&quot;);    var real_addr = base_addr.add(0x13925)    Interceptor.attach(real_addr, &#123;        onEnter: function (args) &#123;            console.log(&quot;bytesToInt Input&quot;);            console.log(args[0])            this.offset = args[1].toInt32();            console.log(hexdump(args[0]));        &#125;,        onLeave: function (retval) &#123;            console.log(&quot;bytesToInt Output&quot;)            console.log(retval.toInt32());        &#125;    &#125;);&#125;\n执行结果\n[Pixel 3::com.lucky.luckyclient ]-&gt; doMD5sign Input0xe239f5a0           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFe239f5a0  63 69 64 3d 32 31 30 31 30 31 3b 71 3d 38 45 50  cid=210101;q=8EPe239f5b0  4f 33 53 66 6c 52 77 72 46 69 5f 70 6e 46 69 41  O3SflRwrFi_pnFiAe239f5c0  4e 49 4f 5f 68 46 5f 7a 74 57 75 5f 33 49 77 77  NIO_hF_ztWu_3Iwwe239f5d0  4c 48 71 4b 71 73 49 66 43 5f 70 65 58 73 6b 70  LHqKqsIfC_peXskpe239f5e0  53 38 76 6e 44 54 5a 6e 72 4b 37 43 62 4c 73 4f  S8vnDTZnrK7CbLsOe239f5f0  59 54 51 59 37 79 33 45 65 31 6f 6d 49 75 4c 48  YTQY7y3Ee1omIuLHe239f600  56 45 2d 2d 38 4f 6f 34 54 34 44 41 61 56 6f 5a  VE--8Oo4T4DAaVoZe239f610  32 33 68 59 6d 59 38 79 6e 6b 78 61 41 69 69 4e  23hYmY8ynkxaAiiNe239f620  74 59 34 75 64 6d 46 55 6d 4a 73 7a 37 3b 75 69  tY4udmFUmJsz7;uie239f630  64 3d 65 32 65 63 33 38 37 31 2d 37 33 63 35 2d  d=e2ec3871-73c5-e239f640  34 38 32 33 2d 62 36 63 35 2d 32 31 33 33 66 38  4823-b6c5-2133f8e239f650  30 63 32 36 37 66 31 37 32 35 38 30 30 37 34 31  0c267f1725800741e239f660  31 32 36 64 4a 4c 64 43 4a 69 56 6e 44 76 4d 39  126dJLdCJiVnDvM9e239f670  4a 55 70 73 6f 6d 39                             JUpsom9md5 Input0xe239f5a0           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFe239f5a0  63 69 64 3d 32 31 30 31 30 31 3b 71 3d 38 45 50  cid=210101;q=8EPe239f5b0  4f 33 53 66 6c 52 77 72 46 69 5f 70 6e 46 69 41  O3SflRwrFi_pnFiAe239f5c0  4e 49 4f 5f 68 46 5f 7a 74 57 75 5f 33 49 77 77  NIO_hF_ztWu_3Iwwe239f5d0  4c 48 71 4b 71 73 49 66 43 5f 70 65 58 73 6b 70  LHqKqsIfC_peXskpe239f5e0  53 38 76 6e 44 54 5a 6e 72 4b 37 43 62 4c 73 4f  S8vnDTZnrK7CbLsOe239f5f0  59 54 51 59 37 79 33 45 65 31 6f 6d 49 75 4c 48  YTQY7y3Ee1omIuLHe239f600  56 45 2d 2d 38 4f 6f 34 54 34 44 41 61 56 6f 5a  VE--8Oo4T4DAaVoZe239f610  32 33 68 59 6d 59 38 79 6e 6b 78 61 41 69 69 4e  23hYmY8ynkxaAiiNe239f620  74 59 34 75 64 6d 46 55 6d 4a 73 7a 37 3b 75 69  tY4udmFUmJsz7;uie239f630  64 3d 65 32 65 63 33 38 37 31 2d 37 33 63 35 2d  d=e2ec3871-73c5-e239f640  34 38 32 33 2d 62 36 63 35 2d 32 31 33 33 66 38  4823-b6c5-2133f8e239f650  30 63 32 36 37 66 31 37 32 35 38 30 30 37 34 31  0c267f1725800741e239f660  31 32 36 64 4a 4c 64 43 4a 69 56 6e 44 76 4d 39  126dJLdCJiVnDvM9e239f670  4a 55 70 73 6f 6d 39                             JUpsom9md5 Output           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFffb70848  46 6b 91 12 1c 7c 30 66 92 da 99 8e 63 15 70 6c  Fk...|0f....c.plbytesToInt Input offset:  0bytesToInt Output:  1181454610 bytesToInt Input offset:  4bytesToInt Output:  477900902 bytesToInt Input offset:  8bytesToInt Output:  -1831167602 bytesToInt Input offset:  12bytesToInt Output:  1662349420 doMD5sign Output           0  1  2  3  4  5  6  7  8  9  A  B  C  D  E  F  0123456789ABCDEFffb70964  90 78 ba af a1 70 40 18 00 00 00 00 10 00 dc de  .x...p@.........ffb70974  a0 09 b7 ff 10 00 dc de 89 6a ad eb 34 0a b7 ff  .........j..4...ffb70984  24 0a b7 ff 03 00 00                             $......\n多次抓包发现除了由刚才说的几个另外的参数拼接，还加了uid+盐值 dJLdCJiVnDvM9JUpsom9验证下是不是标准的md5是标准的md5，没有经过魔改再看看抓包的sign和hook对比发现bytesToInt的4个返回值的绝对值拼接起来就是sign1181454610 477900902 1831167602 1662349420查看bytesToInt(const uint8_t *src, uint32_t offset)的代码只要的就是\nv9 = (src[offset + 1] &lt;&lt; 16) | (src[offset] &lt;&lt; 24) | (src[offset + 2] &lt;&lt; 8) | src[offset + 3];\n现在就很清晰了，sign由md5(cid，q，uid，dJLdCJiVnDvM9JUpsom9拼接)的第1，4，10，15字节偏移而来response也是aes ebc加密的，先replace(&quot;_&quot;,&quot;&#x2F;&quot;).replace(&quot;-&quot;,&quot;+&quot;)，base64解码，再用上面的密钥解密就可以了\n","tags":["算法"]},{"title":"绕过libmsaoaidsec.so的Frida检测","url":"/posts/45698/","content":"已知使用libmsaoaidsec.so frida反调试的应用有：知乎，爱奇艺，携程，bilibili\n以知乎10.37.0为例\nFrida反检测\n分析Frida检测一般都是在Native层实现的，那么我们首先需要定位检测机制是在哪个so中实现的，这里我们就需要先hook Andoid的动态链接库加载函数，观察它加载到哪个so的时候会崩溃。\nandroid_dlopen_ext 是专门为 Android 系统设计的，直接支持 Android 系统的优化和特性。因此，hook 这个函数可以避免可能的兼容性问题，确保你能够捕获到真正的库加载事件。\nhook android_dlopen_ext\nhook*android_dlopen_ext查看so的加载流程，观察它加载到哪个so的时候会崩溃\nfunction hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                this.fileName = args[0].readCString()                console.log(`android_dlopen_ext onEnter: $&#123;this.fileName&#125;`)            &#125;, onLeave: function(retval)&#123;                console.log(`android_dlopen_ext onLeave: $&#123;this.fileName&#125;\\n`)                if(this.fileName != null &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0)&#123;                    let JNI_OnLoad = Module.getExportByName(this.fileName, &#x27;JNI_OnLoad&#x27;)                    console.log(`android_dlopen_ext onLeave JNI_OnLoad: $&#123;JNI_OnLoad&#125;`)                &#125;            &#125;        &#125;    );&#125;\n\n\n从打印的结果看最是加载的so是libmsaoaidsec.so，没有调用onLeave，由此可知崩溃点就在libmsaoaidsec.so中，并且是在JNI_OnLoad之前检测的，so在加载之后会先调用.init_proc函数或类似的函数  ，接着调用.init_array中的函数，最后才是JNI_OnLoad函数，所以根据log可以确定检测点在JNI_OnLoad之前，接下来选择的注入时机可以选择在dlopen加载libmsaoaidsec.so之后\n需要注意的一点是在dlopen函数调用完成之后.init_xxx已经执行完成了\nxref: &#x2F;bionic&#x2F;linker&#x2F;linker.cpp\n\n那么我们就hook这里的call_constructors函数，在onEnter里注入代码在设备中找到call_constructors的offsetreadelf -sW /apex/com.android.runtime/bin/linker64 | grep call_constructors\nλ adb shellblueline:/ $ sublueline:/ # readelf -sW /apex/com.android.runtime/bin/linker64 | grep call_constructors   754: 0000000000051120   896 FUNC    LOCAL  HIDDEN    11 __dl__ZN6soinfo17call_constructorsEvblueline:/ #\nfunction hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x51120    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (secmodule != null)&#123;                // do something            &#125;        &#125;    &#125;)&#125;\n确定hook点了之后，接下来定位具体的Frida检测点对Frida的检测通常会使用openat、open、strstr、pthread_create、snprintf、sprintf、readlinkat等一系列函数\nhook pthread_create 定位检测点在加载libmsaoaidsec.so时，call_constructors之前对pthread_create进行hook，打印新线程要执行的函数地址\nfunction hook_pthred_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&#x27;libc.so&#x27;,&#x27;pthread_create&#x27;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(`The thread Called function address is: $&#123;func_addr&#125;`)        &#125;    &#125;)&#125;\nhook_linker_call_constructors onEnterlibmsaoaidsec.so --- 0x77c5402000The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00hook_linker_call_constructors onEnterlibmsaoaidsec.so --- 0x77c5402000The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00...The thread Called function address is: 0x77c541cee4The thread Called function address is: 0x77c541cee4The thread Called function address is: 0x77c541cee4...The thread Called function address is: 0x7898678d00The thread Called function address is: 0x7898678d00...\n根据打印的结果可以看到有个线程是libmsaoaidsec.so创建的计算对应的偏移:\nlibmsaoaidsec.so — 0x77c5402000\n使用0x7898678d00去计算偏移 -&gt; D327 6D00 太大在so中找不到，换成The thread Called function address is: 0x77c541cee4 偏移-&gt; 1AEE4\n既然libmsaoaidsec.so创建了个线程，猜测这其中是和Frida检测有关的用IDA打开libmsaoaidsec.so，查找偏移\n查看0x1AEE4地址处对应的函数\nsub_1AEE4函数的代码看不懂根据引用找到调用其的地方\n__int64 sub_1B88C()&#123;  pthread_t v1[2]; // [xsp+0h] [xbp-20h] BYREF  v1[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);  return pthread_create(v1, 0LL, (void *(*)(void *))&#125;\nsub_1B88C的引用是sub_1A5B0，可以对sub_1A5B0进行hook，在调用sub_1B88C的时候可以选择直接nop掉pthread_create或者替换检测函数的代码逻辑都可以，我们这里选择replace掉sub_1A5B0\n最终代码function hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                this.fileName = args[0].readCString()                console.log(`android_dlopen_ext onEnter: $&#123;this.fileName&#125;`)                if (this.fileName != undefined &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    hook_linker_call_constructors()                &#125;            &#125;, onLeave: function(retval)&#123;                console.log(`android_dlopen_ext onLeave: $&#123;this.fileName&#125;\\n`)                if(this.fileName != null &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0)&#123;                    let JNI_OnLoad = Module.getExportByName(this.fileName, &#x27;JNI_OnLoad&#x27;)                    console.log(`android_dlopen_ext onLeave JNI_OnLoad: $&#123;JNI_OnLoad&#125;`)                &#125;            &#125;        &#125;    );&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x51120    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (secmodule != null)&#123;                // do something                // hook_pthred_create()                hook_sub_1A5B0()                listener.detach()            &#125;        &#125;    &#125;)&#125;function hook_pthred_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&#x27;libc.so&#x27;,&#x27;pthread_create&#x27;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(`The thread Called function address is: $&#123;func_addr&#125;`)        &#125;    &#125;)&#125;function hook_sub_1A5B0()&#123;    let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    Interceptor.replace(secmodule.base.add(0x1a5b0), new NativeCallback(function () &#123;        console.log(`hook_sub_1b924 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)      &#125;, &#x27;void&#x27;, []));&#125;setImmediate(hook_dlopen)\n\n另一种定位检测点方式检测的位置在JNI_OnLoad函数之前，所以我需要hook .init_xxx的函数，但这里有一个问题，dlopen函数调用完成之后.init_xxx函数已经执行完成了，这个时候不容易使用frida进行hook\n因为想要hook linker的call_function并不容易，这里面涉及到linker的自举,可以在.init_proc函数中找一个调用了外部函数的位置，时机越早越好ida中搜索init_proc函数，\n期间调用了 sub_118FC()\n__int64 sub_118FC()&#123;  _QWORD v1[2]; // [xsp+0h] [xbp-20h] BYREF  v1[1] = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) + 40);  v1[0] = 0LL;  _system_property_get(&quot;ro.build.version.sdk&quot;, v1);  return atoi((const char *)v1);&#125;\n\n选择_system_property_get函数，接下来使用frida hook dlopen函数，当加载libmsaoaidsec.so时，在onEnter回调方法中hook _system_property_get函数，以”ro.build.version.sdk”字符串作为过滤器。\n如果_system_property_get函数被调用了，那么这个时候也就是.init_proc函数刚刚调用的时候，在这个时机点可以注入想要的代码，具体实现如下：\nfunction hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    if (path.indexOf(soName) &gt;= 0) &#123;                        locate_init()                    &#125;                &#125;            &#125;        &#125;    );&#125; function locate_init() &#123;    let secmodule = null    Interceptor.attach(Module.findExportByName(null, &quot;__system_property_get&quot;),        &#123;            // _system_property_get(&quot;ro.build.version.sdk&quot;, v1);            onEnter: function (args) &#123;                secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)                var name = args[0];                if (name !== undefined &amp;&amp; name != null) &#123;                    name = ptr(name).readCString();                    if (name.indexOf(&quot;ro.build.version.sdk&quot;) &gt;= 0) &#123;                        // 这是.init_proc刚开始执行的地方，是一个比较早的时机点                        // do something                    &#125;                &#125;            &#125;        &#125;    );&#125; setImmediate(hook_dlopen, &quot;libmsaoaidsec.so&quot;)\n在获取了一个非常早的注入时机之后，就可以定位具体的frida检测点了。网上对frida的检测通常会使用openat、open、strstr、pthread_create、snprintf、sprintf、readlinkat等一系列函数，从这里下手是一个不错的选择。\n对pthread_create函数进行hook，打印一下新线程要执行的函数地址\nfunction hook_pthread_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(&quot;The thread function address is &quot; + func_addr)        &#125;    &#125;)&#125;\n[Remote::com.zhihu.android ]-&gt; libmsaoaidsec.so --- 0x780070c000The thread function address is 0x7898678d00The thread function address is 0x7800726ee4The thread function address is 0x7800726574The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00The thread function address is 0x7898678d00\n这里面有两个线程是libmsaoaidsec.so创建的，对应的函数偏移分别是0x97F6CD00和0x1AEE4，前者明显不对，\n绕过的方法直接nop掉pthread_create或者替换检测函数的代码逻辑都可以，下面是完整代码。\nfunction hook_dlopen(soName = &#x27;&#x27;) &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                var pathptr = args[0];                if (pathptr !== undefined &amp;&amp; pathptr != null) &#123;                    var path = ptr(pathptr).readCString();                    if (path.indexOf(soName) &gt;= 0) &#123;                        locate_init()                    &#125;                &#125;            &#125;        &#125;    );&#125; function locate_init() &#123;    let secmodule = null    Interceptor.attach(Module.findExportByName(null, &quot;__system_property_get&quot;), &#123;        // _system_property_get(&quot;ro.build.version.sdk&quot;, v1);        onEnter: function (args) &#123;            secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            var name = args[0];            if (name !== undefined &amp;&amp; name != null) &#123;                name = ptr(name).readCString();                if (name.indexOf(&quot;ro.build.version.sdk&quot;) &gt;= 0) &#123;                        // 这是.init_proc刚开始执行的地方，是一个比较早的时机点                        // do something                        // hook_pthread_create();                        bypass();                &#125;            &#125;        &#125;    &#125;);&#125;function hook_pthread_create()&#123;    console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)    Interceptor.attach(Module.findExportByName(&quot;libc.so&quot;, &quot;pthread_create&quot;),&#123;        onEnter(args)&#123;            let func_addr = args[2]            console.log(&quot;The thread function address is &quot; + func_addr)        &#125;    &#125;)&#125;function nop(addr) &#123;    Memory.patchCode(ptr(addr), 4, code =&gt; &#123;        const cw = new Arm64Writer(code, &#123; pc: ptr(addr) &#125;);        cw.putNop();        cw.putNop();        cw.putNop();        cw.putNop();        cw.flush();    &#125;);&#125; function bypass()&#123;    let module = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)    // nop(module.base.add(0x1AEE4))    Interceptor.replace(module.base.add(0x1B88C), new           NativeCallback(function () &#123;        console.log(`hook_sub_1B88C &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)    &#125;, &#x27;void&#x27;, []));&#125; setImmediate(hook_dlopen, &quot;libmsaoaidsec.so&quot;)\n\n没走pthread_create另一种定位方式携程也使用了libmsaoaidsec.so，但是不是通过pthread_create线程方式去检测的，面对这种情况如何定位\n通过栈回溯的方式来定位Frida检测点\n这里我们的思路是：\n既然挂上Frida就会退出，那么我们就来分析最终是调用了哪个系统调用导致的退出，找到之后再通过栈回溯定位到Frida检测点\n\n使用sleep让进程暂停在加载了libmsaoaidsec.so处\n使用工具strace监控系统调用\n找到系统调用后，通过栈回溯定位检测点\n\n1. 定位kill进程调用blueline:/system/lib64 #readelf -sW /apex/com.android.runtime/bin/linker64 | grep __dl__Z9do_dlopenPKciPK17android_dlextinfoPKv 219: 000000000003b508  2408 FUNC    LOCAL  HIDDEN    11 __dl__Z9do_dlopenPKciPK17android_dlextinfoPKv\nfunction hookDlopen() &#123;    let Func_sleep = new NativeFunction(Module.getExportByName(&#x27;libc.so&#x27;, &#x27;sleep&#x27;), &#x27;uint&#x27;, [&#x27;uint&#x27;])    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x3b508 // __dl__Z9do_dlopenPKciPK17android_dlextinfoPKv    let android_dlopen_ext = linker64_base_addr.add(offset)    Interceptor.attach(android_dlopen_ext, &#123;        onEnter: function (args) &#123;            this.name = args[0].readCString()            console.log(`Current PID: $&#123;Process.id&#125;`)            console.log(`dlopen onEnter $&#123;this.name&#125;`)            if (this.name != null &amp;&amp; this.name.indexOf(&#x27;libmsaoaidsec.so&#x27;) &gt;= 0) &#123;                Func_sleep(10)                // hook_mmap()            &#125;        &#125;, onLeave: function (retval) &#123;            console.log(`dlopen onLeave name: $&#123;this.name&#125;`)        &#125;    &#125;)&#125;\nCurrent PID: 21203dlopen onEnter libandroid.sodlopen onLeave name: libandroid.soCurrent PID: 21203dlopen onEnter /data/app/~~QB20iVpvVrCqCfx6DKaduA==/ctrip.android.view-e4dkBKlAkLS9PH0omGuXkw==/lib/arm64/libtrace-canary.sodlopen onLeave name: /data/app/~~QB20iVpvVrCqCfx6DKaduA==/ctrip.android.view-e4dkBKlAkLS9PH0omGuXkw==/lib/arm64/libtrace-canary.soCurrent PID: 21203dlopen onEnter /data/app/~~QB20iVpvVrCqCfx6DKaduA==/ctrip.android.view-e4dkBKlAkLS9PH0omGuXkw==/lib/arm64/libmsaoaidsec.soCurrent PID: 21203dlopen onEnter libc.sodlopen onLeave name: libc.so\n趁着进程暂停在Func_sleep(10)立即去执行：\nstrace -e trace=process -i -f -p 21203\nblueline:/ # strace -e trace=process -i -f -p 21203strace: Process 21203 attached with 116 threads[pid 21311] [0000007878d4d7d8] wait4(21435,  &lt;unfinished ...&gt;[pid 21407] [0000007878cfafb4] exit(0)  = ?[pid 21407] [????????????????] +++ exited with 0 +++[pid 21537] [0000007878cfafb4] exit(0)  = ?[pid 21537] [????????????????] +++ exited with 0 +++[pid 21235] [0000007878cfafb4] exit(0)  = ?[pid 21235] [????????????????] +++ exited with 0 +++[pid 21286] [0000007878cfafb4] exit(0)  = ?[pid 21286] [????????????????] +++ exited with 0 +++[pid 21285] [0000007878cfaf7c] clone(strace: Process 21566 attachedchild_stack=0x75b8bedca0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x75b8bedcc0, tls=0x75b8bee000, child_tidptr=0x75b8bedcc0) = 21566[pid 21285] [0000007878cfaf7c] clone(strace: Process 21567 attachedchild_stack=0x75b57bbca0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x75b57bbcc0, tls=0x75b57bc000, child_tidptr=0x75b57bbcc0) = 21567[pid 21285] [0000007878cfafb4] exit(0)  = ?[pid 21285] [????????????????] +++ exited with 0 +++[pid 21362] [0000007878cfaf7c] clone(strace: Process 21568 attachedchild_stack=0x75b4fb5ca0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x75b4fb5cc0, tls=0x75b4fb6000, child_tidptr=0x75b4fb5cc0) = 21568[pid 21297] [0000007878cfaf7c] clone(child_stack=0x75b4eabca0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x75b4eabcc0, tls=0x75b4eac000, child_tidptr=0x75b4eabcc0) = 21569strace: Process 21569 attached[pid 21419] [0000007878cfaf7c] clone(child_stack=0x75b4da1ca0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x75b4da1cc0, tls=0x75b4da2000, child_tidptr=0x75b4da1cc0) = 21570strace: Process 21570 attached[pid 21272] [0000007878cfb35c] --- SIGCHLD &#123;si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=21435, si_uid=10132, si_status=2, si_utime=0, si_stime=0&#125; ---[pid 21311] [0000007878d4d7d8] &lt;... wait4 resumed&gt; [&#123;WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 2&#125;], 0, NULL) = 21435[pid 21272] [0000007878cfb3a0] clone(strace: Process 21571 attached &lt;unfinished ...&gt;[pid 21345] [0000007878cfaf7c] clone(child_stack=0x753f027ca0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x753f027cc0, tls=0x753f028000, child_tidptr=0x753f027cc0) = 21572strace: Process 21572 attached[pid 21444] [0000007878cfaf7c] clone(strace: Process 21573 attachedchild_stack=0x753a678ca0, flags=CLONE_VM|CLONE_FS|CLONE_FILES|CLONE_SIGHAND|CLONE_THREAD|CLONE_SYSVSEM|CLONE_SETTLS|CLONE_PARENT_SETTID|CLONE_CHILD_CLEARTID, parent_tidptr=0x753a678cc0, tls=0x753a679000, child_tidptr=0x753a678cc0) = 21573[pid 21571] [0000007878d4be98] execve(&quot;/product/bin/sh&quot;, [&quot;sh&quot;], 0x7ff5f809c0 /* 17 vars */) = -1 ENOENT (No such file or directory)[pid 21571] [0000007878d4be98] execve(&quot;/apex/com.android.runtime/bin/sh&quot;, [&quot;sh&quot;], 0x7ff5f809c0 /* 17 vars */) = -1 ENOENT (No such file or directory)[pid 21571] [0000007878d4be98] execve(&quot;/apex/com.android.art/bin/sh&quot;, [&quot;sh&quot;], 0x7ff5f809c0 /* 17 vars */) = -1 ENOENT (No such file or directory)[pid 21571] [0000007878d4be98] execve(&quot;/system_ext/bin/sh&quot;, [&quot;sh&quot;], 0x7ff5f809c0 /* 17 vars */) = -1 ENOENT (No such file or directory)[pid 21571] [0000007878d4be98] execve(&quot;/system/bin/sh&quot;, [&quot;sh&quot;], 0x7ff5f809c0 /* 17 vars */) = 0[pid 21272] [0000007878cfb3a0] &lt;... clone resumed&gt; child_stack=NULL, flags=CLONE_VM|CLONE_VFORK|SIGCHLD) = 21571[pid 21311] [0000007878d4d7d8] wait4(21571,  &lt;unfinished ...&gt;[pid 21243] [0000007889dc4008] exit_group(0 &lt;unfinished ...&gt;[pid 21573] [????????????????] +++ exited with 0 +++[pid 21572] [????????????????] +++ exited with 0 +++[pid 21570] [????????????????] +++ exited with 0 +++[pid 21568] [????????????????] +++ exited with 0 +++[pid 21567] [????????????????] +++ exited with 0 +++[pid 21566] [????????????????] +++ exited with 0 +++[pid 21547] [????????????????] +++ exited with 0 +++[pid 21569] [????????????????] +++ exited with 0 +++\n执行到 [pid 21243] [0000007889dc4008] exit_group(0 &lt;unfinished ...&gt;就退出了\n通过proc/pid/maps libc查看libc.so的地址范围\nblueline:/ # cat /proc/21898/maps |grep libc.so7878caf000-7878ceb000 r--p 00000000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878ceb000-7878cfb000 r-xp 0003c000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878cfb000-7878cfc000 rwxp 0004c000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878cfc000-7878cfe000 r-xp 0004d000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878cfe000-7878cff000 rwxp 0004f000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878cff000-7878d00000 r-xp 00050000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d00000-7878d02000 rwxp 00051000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d02000-7878d03000 r-xp 00053000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d03000-7878d04000 rwxp 00054000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d04000-7878d0c000 r-xp 00055000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d0c000-7878d0e000 rwxp 0005d000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d0e000-7878d4b000 r-xp 0005f000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d4b000-7878d4e000 rwxp 0009c000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d4e000-7878d55000 r-xp 0009f000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d55000-7878d56000 rwxp 000a6000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d56000-7878d64000 r-xp 000a7000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d64000-7878d65000 rwxp 000b5000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d65000-7878d69000 r-xp 000b6000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d69000-7878d6a000 rwxp 000ba000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d6a000-7878d6c000 r-xp 000bb000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d6c000-7878d70000 r--p 000bd000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so7878d70000-7878d72000 rw-p 000c0000 07:58 38                             /apex/com.android.runtime/lib64/bionic/libc.so\n\nexit_group 是一个 Linux 系统调用，用于终止一个进程及其所有线程。如果使用 C 库（libc.so）中的相关函数（如 exit() 或 _exit()），它们会在内部调用 exit_group 来终结进程。而这里调用exit_group的地址范围不在libc中，说明exit_group没有通过标准库来调用。那么大概率是使用了动态分配的内存区域或者自定义加载的库\n2. 获取kill进程的调用栈使用动态调用的话就涉及到内存的动态分配\n接下来使用与刚才相同的方法让进程sleep，使用strace来监控与内存相关的系统调用\nstrace -e trace=process,memory -i -f -p pid\n[pid 22870] [0000007878d4ca78] mmap(NULL, 28, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0x7889dc4000[pid 22870] [0000007889dc4008] exit_group(0 &lt;unfinished ...&gt;\n根据这两行可以看出来exit_group的地址来自于mmap申请的28字节空间\n从mmap的地址0x0000007878d4ca78可以看出来它是libc.so中的函数，那么接下来可以hook mmap方法，打印其调用栈\nfunction hookDlopen() &#123;    let Func_sleep = new NativeFunction(Module.getExportByName(&#x27;libc.so&#x27;, &#x27;sleep&#x27;), &#x27;uint&#x27;, [&#x27;uint&#x27;])    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x3b508 // __dl__Z9do_dlopenPKciPK17android_dlextinfoPKv    let android_dlopen_ext = linker64_base_addr.add(offset)    Interceptor.attach(android_dlopen_ext, &#123;        onEnter: function (args) &#123;            this.name = args[0].readCString()            console.log(`Current PID: $&#123;Process.id&#125;`)            console.log(`dlopen onEnter $&#123;this.name&#125;`)            if (this.name != null &amp;&amp; this.name.indexOf(&#x27;libmsaoaidsec.so&#x27;) &gt;= 0) &#123;                // Func_sleep(10)                hook_mmap()            &#125;        &#125;, onLeave: function (retval) &#123;            console.log(`dlopen onLeave name: $&#123;this.name&#125;`)        &#125;    &#125;)&#125;function hook_mmap() &#123;    var mmap_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;mmap&quot;)    console.log(&quot;mmap_addr ==&gt;&quot;, mmap_addr)    Interceptor.attach(mmap_addr, &#123;        onEnter: function (args) &#123;            // console.log(&quot;args ==&gt; &quot;,)            var length = args[1].toInt32()            if (length === 28) &#123;                console.log(`mmap length: $&#123;length&#125;`)                console.log(&#x27;backtrace:\\n&#x27; + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n&quot;) + &#x27;\\n&#x27;);                console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)            &#125;        &#125;    &#125;)&#125;setImmediate(hookDlopen)\nandroid_dlopen_ext onEnter: /data/app/~~QB20iVpvVrCqCfx6DKaduA==/ctrip.android.view-e4dkBKlAkLS9PH0omGuXkw==/lib/arm64/libmsaoaidsec.sommap_addr ==&gt; 0x7878d4ca70mmap length: 28backtrace:0x7538e3158c0x7538e3158c0x7538e2b2f00x7538e29dcc0x7538e29f7c0x7538e226240x788b2914700x788b27bd180x788b2770e80x78755470cc libdl.so!android_dlopen_ext+0x140x787c362dd0 libnativeloader.so!_ZNK7android21NativeLoaderNamespace4LoadEPKc+0xc00x787c362dd0 libnativeloader.so!_ZNK7android21NativeLoaderNamespace4LoadEPKc+0xc0libmsaoaidsec.so --- 0x7538e0e000\n成功的打印出了调用栈用 0x7538e3158c - 0x7538e0e000 得到偏移 0x2358C\n3. 在IDA中定位检测函数用IDA打开libmsaoaidsec.so并跳转到栈回溯位置\n\n根据交叉引用继续往上回溯找到调用的位置 sub_1CEF8\n\n4. 代码那么接下来我们还是通过hook call_constructors方法，在加载到libmsaoaidsec.so时替换掉其中偏移sub_1CEF8处的函数\nfunction hook_dlopen() &#123;    Interceptor.attach(Module.findExportByName(null, &quot;android_dlopen_ext&quot;),        &#123;            onEnter: function (args) &#123;                this.fileName = args[0].readCString()                console.log(`android_dlopen_ext onEnter: $&#123;this.fileName&#125;`)                if (this.fileName != undefined &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0) &#123;                    hook_linker_call_constructors()                    // hook_mmap()                &#125;            &#125;, onLeave: function(retval)&#123;                console.log(`android_dlopen_ext onLeave: $&#123;this.fileName&#125;\\n`)                if(this.fileName != null &amp;&amp; this.fileName.indexOf(&quot;libmsaoaidsec.so&quot;) &gt;= 0)&#123;                    let JNI_OnLoad = Module.getExportByName(this.fileName, &#x27;JNI_OnLoad&#x27;)                    console.log(`android_dlopen_ext onLeave JNI_OnLoad: $&#123;JNI_OnLoad&#125;`)                &#125;            &#125;        &#125;    );&#125;function hook_linker_call_constructors() &#123;    let linker64_base_addr = Module.getBaseAddress(&#x27;linker64&#x27;)    let offset = 0x51120    // __dl__ZN6soinfo17call_constructorsEv    let call_constructors = linker64_base_addr.add(offset)    let listener = Interceptor.attach(call_constructors,&#123;        onEnter:function(args)&#123;            console.log(&#x27;hook_linker_call_constructors onEnter&#x27;)            let secmodule = Process.findModuleByName(&quot;libmsaoaidsec.so&quot;)            if (secmodule != null)&#123;                // do something                hook_sub_1CEF8(secmodule)                listener.detach()            &#125;        &#125;    &#125;)&#125;function hook_mmap() &#123;    var mmap_addr = Module.findExportByName(&quot;libc.so&quot;, &quot;mmap&quot;)    console.log(&quot;mmap_addr ==&gt;&quot;, mmap_addr)    Interceptor.attach(mmap_addr, &#123;        onEnter: function (args) &#123;            // console.log(&quot;args ==&gt; &quot;,)            var length = args[1].toInt32()            if (length === 28) &#123;                console.log(`mmap length: $&#123;length&#125;`)                console.log(&#x27;backtrace:\\n&#x27; + Thread.backtrace(this.context, Backtracer.ACCURATE).map(DebugSymbol.fromAddress).join(&quot;\\n&quot;) + &#x27;\\n&#x27;);                console.log(&quot;libmsaoaidsec.so --- &quot; + Process.findModuleByName(&quot;libmsaoaidsec.so&quot;).base)            &#125;        &#125;    &#125;)&#125;function hook_sub_1CEF8(secmodule)&#123;    Interceptor.replace(secmodule.base.add(0x1cef8), new NativeCallback(function () &#123;        console.log(`hook_sub_1CEF8 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; replace`)      &#125;, &#x27;void&#x27;, []));&#125;setImmediate(hook_dlopen)","tags":["frida"]},{"title":"某乎x-zse-96逆向","url":"/posts/34066/","content":"app的版本是 10.37.0\n定位抓包啥的没啥好说的，参数定位直接jadx搜索，很快定位到，直接上图最终调用so加密的函数\n\n该app有frida检测，怎么绕过看上一篇绕过libmsaoaidsec.so的Frida检测\n从函数看加密跟aes相关，但其实魔改了多很，其中laesEncryptByteArr的三个参数，bArr是明文，str可以理解为扩展后的key，bArr2是iv，str和bArr2都是固定的\nunidng分析直接搭起框架，函数调用\npackage com.zhihu;import com.github.unidbg.AndroidEmulator;import com.github.unidbg.Module;import com.github.unidbg.linux.android.AndroidEmulatorBuilder;import com.github.unidbg.linux.android.AndroidResolver;import com.github.unidbg.linux.android.dvm.AbstractJni;import com.github.unidbg.linux.android.dvm.DalvikModule;import com.github.unidbg.linux.android.dvm.StringObject;import com.github.unidbg.linux.android.dvm.VM;import com.github.unidbg.linux.android.dvm.array.ByteArray;import com.github.unidbg.memory.Memory;import com.github.unidbg.virtualmodule.android.AndroidModule;import com.github.unidbg.virtualmodule.android.JniGraphics;import com.github.unidbg.virtualmodule.android.MediaNdkModule;import com.github.unidbg.virtualmodule.android.SystemProperties;import java.io.File;import java.util.ArrayList;import java.util.List;/** * Created by zsk * on 2025/03/06 02:00 */public class encrypt extends AbstractJni&#123;    private final AndroidEmulator emulator;    private final VM vm;    private final Module module;    public encrypt() &#123;        emulator = AndroidEmulatorBuilder.for64Bit().setProcessName(&quot;com.zhihu.android&quot;).build(); // 创建模拟器实例，要模拟32位或者64位，在这里区分        // 模拟器的内存操作接口        final Memory memory = emulator.getMemory();        // 设置系统类库解析        memory.setLibraryResolver(new AndroidResolver(23));        // 创建Android虚拟机        vm = emulator.createDalvikVM(new File(&quot;unidbg-android/src/test/resources/zhihu/zhihu10.37.0.apk&quot;));        // 设置JNI        vm.setJni(this);        // 打印日志        vm.setVerbose(true);        // 加载基本库        new AndroidModule(emulator, vm).register(memory);        new MediaNdkModule(emulator, vm).register(memory);        new JniGraphics(emulator, vm).register(memory);        new SystemProperties(emulator, null).register(memory);        // 加载so到虚拟内存        DalvikModule dm = vm.loadLibrary(&quot;bangcle_crypto_tool&quot;, true);        module = dm.getModule();        dm.callJNI_OnLoad(emulator);    &#125;    public static String bytesToHex(byte[] bytes) &#123;        StringBuilder hexString = new StringBuilder();        for (byte b : bytes) &#123;            String hex = Integer.toHexString(b &amp; 0xFF);            if (hex.length() == 1) &#123;                hexString.append(&#x27;0&#x27;);            &#125;            hexString.append(hex);        &#125;        return hexString.toString();    &#125;    public void callAesEncryptByteArr() &#123;        // args list        List&lt;Object&gt; list = new ArrayList&lt;&gt;(10);        // jnienv        list.add(vm.getJNIEnv());        // jclazz        list.add(0);                // hex 8b8d8089212822818d23298d23298180218229882280238883808a2a2a238082        byte[] input = &#123;-117, -115, -128, -119, 33, 40, 34, -127, -115, 35, 41, -115, 35, 41, -127, -128, 33, -126, 41, -120, 34, -128, 35, -120, -125, -128, -118, 42, 42, 35, -128, -126&#125;;        // hex 99303a3a32343a3992923a3b3a999292        byte[] iv = &#123;-103, 48, 58, 58, 50, 52, 58, 57, -110, -110, 58, 59, 58, -103, -110, -110&#125;;        String key = &quot;541a3a5896fbefd351917c8251328a236a7efbf27d0fad8283ef59ef07aa386dbb2b1fcbba167135d575877ba0205a02f0aac2d31957bc7f028ed5888d4bbe69ed6768efc15ab703dc0f406b301845a0a64cf3c427c82870053bd7ba6721649c3a9aca8c3c31710a6be5ce71e4686842732d9314d6898cc3fdca075db46d1ccf3a7f9b20615f4a303c5235bd02c5cdc791eb123b9d9f7e72e954de3bcbf7d314064a1eced78d13679d040dd4080640d18c37bbde&quot;;        ByteArray arr1 = new ByteArray(vm, input);        ByteArray arr2 = new ByteArray(vm, iv);        list.add(vm.addLocalObject(arr1));        list.add(vm.addLocalObject(new StringObject(vm, key)));        list.add(vm.addLocalObject(arr2));        Number number = module.callFunction(emulator, 0x9e98, list.toArray());        ByteArray resultArr = vm.getObject(number.intValue());        System.out.println(&quot;result: &quot; + bytesToHex(resultArr.getValue()));    &#125;    public static void main(String[] args) &#123;        encrypt e = new encrypt();        e.callAesEncryptByteArr();    &#125;&#125;\n\n运行报错了，该问题内存未分配，调用free释放内存导致的问题\n\n这里可以直接在调用free的地方patch掉，不执行free就可以了\n把traceCode开启，看报错的位置\nemulator.traceCode(module.base, module.base + module.size);\n\n[00:19:30 167][libbangcle_crypto_tool.so 0x048c8] [a01740f9] 0x120048c8: &quot;ldr x0, [x29, #0x28]&quot; x29=0xe4fff5b0 =&gt; x0=0x12052000[00:19:30 168][libbangcle_crypto_tool.so 0x048cc] [1f001feb] 0x120048cc: &quot;cmp x0, xzr&quot; =&gt; nzcv: N=0, Z=0, C=1, V=0 x0=0x12052000[00:19:30 168][libbangcle_crypto_tool.so 0x048d0] [20010054] 0x120048d0: &quot;b.eq #0x120048f4&quot; nzcv: N=0, Z=0, C=1, V=0[00:19:30 169][libbangcle_crypto_tool.so 0x048d4] [a01740f9] 0x120048d4: &quot;ldr x0, [x29, #0x28]&quot; x29=0xe4fff5b0 =&gt; x0=0x12052000[00:19:30 169][libbangcle_crypto_tool.so 0x048d8] [52f6ff97] 0x120048d8: &quot;bl #0x12002220&quot;[00:19:30 177][libbangcle_crypto_tool.so 0x02220] [f00000b0] 0x12002220: &quot;adrp x16, #0x1201f000&quot; =&gt; x16=0x1201f000[00:19:30 179][libbangcle_crypto_tool.so 0x02224] [11ba47f9] 0x12002224: &quot;ldr x17, [x16, #0xf70]&quot; x16=0x1201f000 =&gt; x17=0x1218bac0[00:19:30 182][libbangcle_crypto_tool.so 0x02228] [10c23d91] 0x12002228: &quot;add x16, x16, #0xf70&quot; x16=0x1201f000 =&gt; x16=0x1201ff70[00:19:30 184][libbangcle_crypto_tool.so 0x0222c] [20021fd6] 0x1200222c: &quot;br x17&quot; x17=0x1218bac0Invalid address 0x12052000 passed to free: value not allocated[crash]A/libc: Invalid address 0x12052000 passed to free: value not allocated\n\n程序是在0x0222c这个位置奔溃的，ida调到对应位置\nvoid free(void *p)&#123;  free(p);&#125;\n\nfree函数，可以往上一点调到调用它的位置，0x048d8，\nvoid __fastcall check_package_name(__int64 a1)&#123;  char *pkgname; // [xsp+28h] [xbp+28h]  if ( aComZhihuAndroi[0] )  &#123;    pkgname = get_pkgname(a1);    if ( !strcmp(aComZhihuAndroi, pkgname) )      dword_20024 = 1;    if ( pkgname )      free(pkgname);  &#125;  else  &#123;    dword_20024 = 1;  &#125;&#125;\n\n直接在 0x48d8 调转到free那里把指令改为npo，就不会执行了。\npublic void patch() &#123;    try (Keystone keystone = new Keystone(KeystoneArchitecture.Arm64, KeystoneMode.LittleEndian);) &#123;        KeystoneEncoded encoded = keystone.assemble(&quot;nop&quot;);        byte[] patchCode = encoded.getMachineCode();        emulator.getMemory().pointer(module.base + 0x48d8).write(patchCode);    &#125;&#125;\n\n很顺利不用补环境直接跑出来了结果\nresult: 0f02c75267dd7becc6b32f941837721f6f89610d4c49c3b5a8ddd649767e953de0a02e505b8e684fb5654137c266f12e\n\n\n开始ida分析函数\nida分析\n整个函数看下来，只有 sub_8B2C 这个函数最可疑跟进查看\n\n好多aes加密相关的函数，怎么判断程序调用了哪个\n记录函数对内存的访问以及发起访问的地址（PC指针），绘制成折线图，可以看函数的调用情况\n使用Unidbg的ReadHook，监控这个函数的地址范围\npublic void traceAESRead() &#123;    ReadHook readHook = new ReadHook() &#123;        @Override        public void hook(Backend backend, long address, int size, Object user) &#123;            int now = emulator.getBackend().reg_read(Arm64Const.UC_ARM64_REG_PC).intValue();            if((now &gt; module.base) &amp; (now &lt; (module.base + module.size)))&#123;                System.out.println(now - module.base);            &#125;        &#125;        @Override        public void onAttach(UnHook unHook) &#123;&#125;        @Override        public void detach() &#123;&#125;    &#125;;    emulator.getBackend().hook_add_new(readHook, module.base+0x8b2c, module.base+module.size+0x9080, null);&#125;\n\ntrade函数放在调用函数前执行，将打印出来的地址放到一个文件里，用python执行\n\nimport matplotlib.pyplot as pltimport numpyinput = numpy.loadtxt(&quot;trace.txt&quot;, int)plt.plot(range(len(input)), input)# 限制Yplt.ylim(23500,29000)plt.plot(range(len(input)), input)plt.show()\n\n\n三次分组，每次分组执行都一样10轮调用，跳到24000即 0x5dc0 的位置\n\n调用的函数是 Bangcle_WB_LAES_encrypt ，这里就是aes的加密逻辑了，查找引用看参数来源\n\n把 Bangcle_WB_LAES_encrypt; 作为参数传给了 Bangcle_CRYPTO_cbc128_encrypt，\n__int64 __fastcall Bangcle_CRYPTO_cbc128_encrypt(        __int64 input_data,        __int64 buff,        int input_data_len,        __int64 iv,        __int64 key,        void (__fastcall *Bangcle_WB_LAES_encrypt)(__int64, __int64, __int64, unsigned int *))&#123;  unsigned int v12; // [xsp+4Ch] [xbp+4Ch] BYREF  __int64 iv_1; // [xsp+50h] [xbp+50h]  int i; // [xsp+5Ch] [xbp+5Ch]  v12 = 0;  iv_1 = iv;  while ( input_data_len &gt; 15 )  &#123;    for ( i = 0; i &lt;= 15; ++i )      *(_BYTE *)(buff + i) = *(_BYTE *)(input_data + i) ^ *(_BYTE *)(iv_1 + i);    Bangcle_WB_LAES_encrypt(buff, buff, key, &amp;v12);    iv_1 = buff;    input_data_len -= 16;    input_data += 16LL;    buff += 16LL;  &#125;  return v12;&#125;\n\nunidbg调试函数使用unidbg对 Bangcle_CRYPTO_cbc128_encrypt 进行hook查看参数\n参数一跟我们一开始前面的明文hex对比8b8d8089212822818d23298d23298180218229882280238883808a2a2a238082\n后面填充了16字节的 9b，这里填充是固定的，有兴趣的可以自己探索\nmx0&gt;-----------------------------------------------------------------------------&lt;[01:24:35 310]x0=RW@0x12353060, md5=630d2fa2c2528055ad2374d1d4f9419b, hex=8b8d8089212822818d23298d23298180218229882280238883808a2a2a2380829b9b9b9b9b9b9b9b9b9b9b9b9b9b9b9b00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000size: 1120000: 8B 8D 80 89 21 28 22 81 8D 23 29 8D 23 29 81 80    ....!(&quot;..#).#)..0010: 21 82 29 88 22 80 23 88 83 80 8A 2A 2A 23 80 82    !.).&quot;.#....**#..0020: 9B 9B 9B 9B 9B 9B 9B 9B 9B 9B 9B 9B 9B 9B 9B 9B    ................0030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................^-----------------------------------------------------------------------------^\n\n参数二是空的，用来存放结果的\n参数三是 0x30，明文填充后的长度\n参数四是 iv\nmx3&gt;-----------------------------------------------------------------------------&lt;[01:34:12 007]x3=RW@0x12054000[libc++.so]0x4000, md5=d2b01352c3f52a790b79eb18ddc8938c, hex=99303a3a32343a3992923a3b3a999292000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000size: 1120000: 99 30 3A 3A 32 34 3A 39 92 92 3A 3B 3A 99 92 92    .0::24:9..:;:...0010: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0020: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0030: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0040: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0050: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................0060: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00    ................^-----------------------------------------------------------------------------^\n\n参数五看不出是啥，也没跟key对应，需要在往上看来源，这里注意参数五出来的是指针，需要打印指针的内存\nm0x123580c0 176&gt;-----------------------------------------------------------------------------&lt;[01:56:59 956]RW@0x123580c0, md5=070a52023ae19a58ba6af416776beb5f, hex=8cc1bbc96bc566b80528b0777044afe8475bb7b8d7f563bb1d906c77817f05f1ee0c4b61cf4fd3619a744038a4b0f887036de86538dacfb2d951843df75d3cf5fb0ead3988157a3f2a2211ba9c18e9fe73d212241f0183a05d757ea66e80f0d8260b251051b1d44bb07252166917c70eecdd96f9a9d03d09ae5748d5002b811a35457064266861a73891d7fdc5f1286f87a52a68d300c4019fede9401c704ad4edd9095dc91e3780123c14cbb663a1e4size: 1760000: 8C C1 BB C9 6B C5 66 B8 05 28 B0 77 70 44 AF E8    ....k.f..(.wpD..0010: 47 5B B7 B8 D7 F5 63 BB 1D 90 6C 77 81 7F 05 F1    G[....c...lw....0020: EE 0C 4B 61 CF 4F D3 61 9A 74 40 38 A4 B0 F8 87    ..Ka.O.a.t@8....0030: 03 6D E8 65 38 DA CF B2 D9 51 84 3D F7 5D 3C F5    .m.e8....Q.=.]&lt;.0040: FB 0E AD 39 88 15 7A 3F 2A 22 11 BA 9C 18 E9 FE    ...9..z?*&quot;......0050: 73 D2 12 24 1F 01 83 A0 5D 75 7E A6 6E 80 F0 D8    s..$....]u~.n...0060: 26 0B 25 10 51 B1 D4 4B B0 72 52 16 69 17 C7 0E    &amp;.%.Q..K.rR.i...0070: EC DD 96 F9 A9 D0 3D 09 AE 57 48 D5 00 2B 81 1A    ......=..WH..+..0080: 35 45 70 64 26 68 61 A7 38 91 D7 FD C5 F1 28 6F    5Epd&amp;ha.8.....(o0090: 87 A5 2A 68 D3 00 C4 01 9F ED E9 40 1C 70 4A D4    ..*h.......@.pJ.00A0: ED D9 09 5D C9 1E 37 80 12 3C 14 CB B6 63 A1 E4    ...]..7..&lt;...c..^-----------------------------------------------------------------------------^\n\n\n就sub_3BA8和sub_47BC调用了v19，既上面的参数五\n其实是在 sub_3BA8 对key做了一个异或\nfor ( i = 4; i &lt; str_data_len; ++i )    *(_BYTE *)(*(_QWORD *)buff + i - 4LL) = str_data[i] ^ str_data[i % 3];*(_DWORD *)(buff + 8) = str_data_len - 4;\n\nkey的长度是180字节，这里出来的结果是176个字节，所以这里就是密钥编排了，可以对这个函数hook，在返回前打印，因为key是固定的，所以可以直接拿编排后的使用。这里出来的结果就是上面的参数五了\n好了，参数来源有了，回到上面继续看 Bangcle_CRYPTO_cbc128_encrypt 的逻辑，明文长度填充后是48，刚好3个分组，每次明文加密后会作为iv进行下一分组的加密\nv12 = 0;iv_1 = iv;while ( input_data_len &gt; 15 )&#123;    for ( i = 0; i &lt;= 15; ++i )      *(_BYTE *)(buff + i) = *(_BYTE *)(input_data + i) ^ *(_BYTE *)(iv_1 + i);    Bangcle_WB_LAES_encrypt(buff, buff, key, &amp;v12);    iv_1 = buff;    input_data_len -= 16;    input_data += 16LL;    buff += 16LL;&#125;\n\n\n\n跟进Bangcle_WB_LAES_encrypt\n__int64 __fastcall Bangcle_WB_LAES_encrypt(__int64 input_data, __int64 buff, __int64 *key_state)&#123;  // [COLLAPSED LOCAL DECLARATIONS. PRESS NUMPAD &quot;+&quot; TO EXPAND]  key_state_1 = *key_state;  round_count = *((_DWORD *)key_state + 4) / 32 + 6;  for ( i = 0; i &lt;= 15; ++i )    *(&amp;v36 + i) = (16                 * (byte_B248[(unsigned __int8)(16 * (*(_BYTE *)(input_data + i) &gt;&gt; 4)) ^ (*(unsigned __int8 *)(key_state_1 + i) &gt;&gt; 4) &amp; 0xF] &gt;&gt; 4)) ^ (byte_B248[(unsigned __int8)(16 * *(_BYTE *)(input_data + i)) ^ *(_BYTE *)(key_state_1 + i) &amp; 0xF] &gt;&gt; 4);  for ( j = 1; j &lt; round_count; ++j )  &#123;    v20 = HIBYTE(dword_B548[v36]);    v21 = BYTE2(dword_B548[v36]);    v22 = BYTE1(dword_B548[v36]);    v23 = dword_B548[v36];    v24 = HIBYTE(dword_B548[v40]);    v25 = BYTE2(dword_B548[v40]);    v26 = BYTE1(dword_B548[v40]);    v27 = dword_B548[v40];    v28 = HIBYTE(dword_B548[v44]);    v29 = BYTE2(dword_B548[v44]);    v30 = BYTE1(dword_B548[v44]);    v31 = dword_B548[v44];    v32 = HIBYTE(dword_B548[v48]);    v33 = BYTE2(dword_B548[v48]);    v34 = BYTE1(dword_B548[v48]);    v35 = dword_B548[v48];    v4 = HIBYTE(dword_B948[v41]);    v5 = BYTE2(dword_B948[v41]);    v6 = BYTE1(dword_B948[v41]);    v7 = dword_B948[v41];    v8 = HIBYTE(dword_B948[v45]);    v9 = BYTE2(dword_B948[v45]);    v10 = BYTE1(dword_B948[v45]);    v11 = dword_B948[v45];    v12 = HIBYTE(dword_B948[v49]);    v13 = BYTE2(dword_B948[v49]);    v14 = BYTE1(dword_B948[v49]);    v15 = dword_B948[v49];    v16 = HIBYTE(dword_B948[v37]);    v17 = BYTE2(dword_B948[v37]);    v18 = BYTE1(dword_B948[v37]);    v19 = dword_B948[v37];    for ( i = 0; i &lt;= 15; ++i )      *(&amp;v20 + i) = (16                   * (byte_B348[(unsigned __int8)(16 * ((unsigned __int8)*(&amp;v20 + i) &gt;&gt; 4)) ^ ((unsigned __int8)*(&amp;v4 + i) &gt;&gt; 4) &amp; 0xF] &gt;&gt; 4)) ^ (byte_B348[(unsigned __int8)(16 * *(&amp;v20 + i)) ^ *(&amp;v4 + i) &amp; 0xF] &gt;&gt; 4);    v4 = HIBYTE(dword_BD48[v46]);    v5 = BYTE2(dword_BD48[v46]);    v6 = BYTE1(dword_BD48[v46]);    v7 = dword_BD48[v46];    v8 = HIBYTE(dword_BD48[v50]);    v9 = BYTE2(dword_BD48[v50]);    v10 = BYTE1(dword_BD48[v50]);    v11 = dword_BD48[v50];    v12 = HIBYTE(dword_BD48[v38]);    v13 = BYTE2(dword_BD48[v38]);    v14 = BYTE1(dword_BD48[v38]);    v15 = dword_BD48[v38];    v16 = HIBYTE(dword_BD48[v42]);    v17 = BYTE2(dword_BD48[v42]);    v18 = BYTE1(dword_BD48[v42]);    v19 = dword_BD48[v42];    for ( i = 0; i &lt;= 15; ++i )      *(&amp;v20 + i) = (16                   * (byte_B348[(unsigned __int8)(16 * ((unsigned __int8)*(&amp;v20 + i) &gt;&gt; 4)) ^ ((unsigned __int8)*(&amp;v4 + i) &gt;&gt; 4) &amp; 0xF] &gt;&gt; 4)) ^ (byte_B348[(unsigned __int8)(16 * *(&amp;v20 + i)) ^ *(&amp;v4 + i) &amp; 0xF] &gt;&gt; 4);    v4 = HIBYTE(dword_C148[v51]);    v5 = BYTE2(dword_C148[v51]);    v6 = BYTE1(dword_C148[v51]);    v7 = dword_C148[v51];    v8 = HIBYTE(dword_C148[v39]);    v9 = BYTE2(dword_C148[v39]);    v10 = BYTE1(dword_C148[v39]);    v11 = dword_C148[v39];    v12 = HIBYTE(dword_C148[v43]);    v13 = BYTE2(dword_C148[v43]);    v14 = BYTE1(dword_C148[v43]);    v15 = dword_C148[v43];    v16 = HIBYTE(dword_C148[v47]);    v17 = BYTE2(dword_C148[v47]);    v18 = BYTE1(dword_C148[v47]);    v19 = dword_C148[v47];    for ( i = 0; i &lt;= 15; ++i )      *(&amp;v20 + i) = (16                   * (byte_B348[(unsigned __int8)(16 * ((unsigned __int8)*(&amp;v20 + i) &gt;&gt; 4)) ^ ((unsigned __int8)*(&amp;v4 + i) &gt;&gt; 4) &amp; 0xF] &gt;&gt; 4)) ^ (byte_B348[(unsigned __int8)(16 * *(&amp;v20 + i)) ^ *(&amp;v4 + i) &amp; 0xF] &gt;&gt; 4);    for ( i = 0; i &lt;= 15; ++i )      *(&amp;v36 + i) = (16                   * (byte_B348[(unsigned __int8)(16 * ((unsigned __int8)*(&amp;v20 + i) &gt;&gt; 4)) ^ (*(unsigned __int8 *)(key_state_1 + 16 * j + i) &gt;&gt; 4) &amp; 0xF] &gt;&gt; 4)) ^ (byte_B348[(unsigned __int8)(16 * *(&amp;v20 + i)) ^ *(_BYTE *)(key_state_1 + 16 * j + i) &amp; 0xF] &gt;&gt; 4);  &#125;  v20 = byte_C548[v36];  v21 = byte_C548[v41];  v22 = byte_C548[v46];  v23 = byte_C548[v51];  v24 = byte_C548[v40];  v25 = byte_C548[v45];  v26 = byte_C548[v50];  v27 = byte_C548[v39];  v28 = byte_C548[v44];  v29 = byte_C548[v49];  v30 = byte_C548[v38];  v31 = byte_C548[v43];  v32 = byte_C548[v48];  v33 = byte_C548[v37];  v34 = byte_C548[v42];  v35 = byte_C548[v47];  for ( i = 0; ; ++i )  &#123;    result = (unsigned int)i;    if ( i &gt; 15 )      break;    *(_BYTE *)(buff + i) = (16                          * (byte_B448[(unsigned __int8)(16 * ((unsigned __int8)*(&amp;v20 + i) &gt;&gt; 4)) ^ (*(unsigned __int8 *)(key_state_1 + 16 * j + i) &gt;&gt; 4) &amp; 0xF] &gt;&gt; 4)) ^ (byte_B448[(unsigned __int8)(16 * *(&amp;v20 + i)) ^ *(_BYTE *)(key_state_1 + 16 * j + i) &amp; 0xF] &gt;&gt; 4);  &#125;  return result;&#125;\n\n看到里面的dword_B548，dword_B948等等都是一些大表\n\n在还原算法时候可以直接拿来用。\n既然 Bangcle_WB_LAES_encrypt 是加密的地方了，那应该或多或少有aes影子\n\n可以先看以下round_count是不是真的是10\nround_count &#x3D; *((_DWORD *)data_ptr + 4) &#x2F; 32 + 6;\n用unidbg查看，这里是_DWORD类型，每4个字节一组，查看第4*4的字节位置截取4字节\nmx2&gt;-----------------------------------------------------------------------------&lt;[02:20:49 310]x2=unidbg@0xe4fff530, md5=70dda4f32687556b499d15b8cca17ed6, hex=c080351200000000b0000000040000008000000001000000000000000000000000000000000000007c5d00120000000000000000000000001000000030000000603035120000000000000000ffffffffe0f5ffe400000000000000000000000010f6ffe4000000004c8f001200000000size: 1120000: C0 80 35 12 00 00 00 00 B0 00 00 00 04 00 00 00    ..5.............0010: 80 00 00 00 01 00 00 00 00 00 00 00 00 00 00 00    ................0020: 00 00 00 00 00 00 00 00 7C 5D 00 12 00 00 00 00    ........|]......0030: 00 00 00 00 00 00 00 00 10 00 00 00 30 00 00 00    ............0...0040: 60 30 35 12 00 00 00 00 00 00 00 00 FF FF FF FF    `05.............0050: E0 F5 FF E4 00 00 00 00 00 00 00 00 00 00 00 00    ................0060: 10 F6 FF E4 00 00 00 00 4C 8F 00 12 00 00 00 00    ........L.......^-----------------------------------------------------------------------------^\n\n80 00 00 00 就是我们要的，记得转为小端序 00 00 00 80，对应的十进制是128，计算结果是 128&#x2F;32+6 &#x3D; 10\nfor ( j &#x3D; 1; j &lt; round_count; ++j ) 刚好9轮\n整个看下来多多少少能看出来，一开始就使用input_data和key_state进行异或，可以标记为初始轮密钥加\nfor ( i = 0; i &lt;= 15; ++i )    *(&amp;v36 + i) = (16 * (byte_B248[(unsigned __int8)(16 * (*(_BYTE *)(input_data + i) &gt;&gt; 4)) ^ (*(unsigned __int8 *)(key_state_1 + i) &gt;&gt; 4) &amp; 0xF] &gt;&gt; 4)) ^ (byte_B248[(unsigned __int8)(16 * *(_BYTE *)(input_data + i)) ^ *(_BYTE *)(key_state_1 + i) &amp; 0xF] &gt;&gt; 4);\n\n\n\n每个for循环结束前的异或也是轮密钥加，中间整块就是字节替换，循环左移，列混淆\nfor循环结束后\nv20 = byte_C548[v36];v21 = byte_C548[v41];v22 = byte_C548[v46];v23 = byte_C548[v51];v24 = byte_C548[v40];v25 = byte_C548[v45];v26 = byte_C548[v50];v27 = byte_C548[v39];v28 = byte_C548[v44];v29 = byte_C548[v49];v30 = byte_C548[v38];v31 = byte_C548[v43];v32 = byte_C548[v48];v33 = byte_C548[v37];v34 = byte_C548[v42];v35 = byte_C548[v47];\n\n编排后就是 字节替换和循环左移了\nv36\tv40\tv44\tv48  \tv36\tv40\tv44\tv48v37\tv41\tv45\tv49 ==&gt; v41\tv45\tv49\tv37v38\tv42\tv46\tv50 \tv46\tv50\tv38\tv42v39\tv43\tv47\tv51\t\tv51\tv39\tv43\tv47\n\n最后结束前就是轮密钥加\n这个加密看下来很顺滑，没有混淆过，扔给gpd就能让它给出对应的python代码了。\n其中几个点，比如\nv20 = HIBYTE(dword_B548[v36]);v21 = BYTE2(dword_B548[v36]);v22 = BYTE1(dword_B548[v36]);v23 = dword_B548[v36];\n\n假设一个 &lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;DWORD&lt;/font&gt; 的值为 &lt;font style=&quot;color:rgb(64, 64, 64);&quot;&gt;0xAABBCCDD&lt;/font&gt;，它的字节结构如下：\n\n\n\n字节位置\n字节值\n\n\n\n\n字节 3\nAA\n最高有效字节\n\n\n字节 2\nBB\n\n\n\n字节 1\nCC\n\n\n\n字节 0\nDD\n最低有效字节\n\n\n还有v20,v21,v22等都是连续存储的，通过v20的指针按偏移取后面的值\n上结果0f02c75267dd7becc6b32f941837721f6f89610d4c49c3b5a8ddd649767e953de0a02e505b8e684fb5654137c266f12e\n跟unidbg跑出来的一样\n  \n","tags":["安卓逆向","Unidbg"]}]